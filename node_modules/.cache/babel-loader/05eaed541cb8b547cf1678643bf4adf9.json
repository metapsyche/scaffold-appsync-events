{"ast":null,"code":"/**\n * Copyright (c) 2017-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { isAsyncIterable } from 'iterall';\nimport { GraphQLError } from '../error/GraphQLError';\nimport { locatedError } from '../error/locatedError';\nimport { addPath, assertValidExecutionArguments, buildExecutionContext, buildResolveInfo, collectFields, execute, getFieldDef, getOperationRootType, resolveFieldValueOrError, responsePathAsArray } from '../execution/execute';\nimport { GraphQLSchema } from '../type/schema';\nimport mapAsyncIterator from './mapAsyncIterator';\n/**\n * Implements the \"Subscribe\" algorithm described in the GraphQL specification.\n *\n * Returns a Promise which resolves to either an AsyncIterator (if successful)\n * or an ExecutionResult (client error). The promise will be rejected if a\n * server error occurs.\n *\n * If the client-provided arguments to this function do not result in a\n * compliant subscription, a GraphQL Response (ExecutionResult) with\n * descriptive errors and no data will be returned.\n *\n * If the the source stream could not be created due to faulty subscription\n * resolver logic or underlying systems, the promise will resolve to a single\n * ExecutionResult containing `errors` and no `data`.\n *\n * If the operation succeeded, the promise resolves to an AsyncIterator, which\n * yields a stream of ExecutionResults representing the response stream.\n *\n * Accepts either an object with named arguments, or individual arguments.\n */\n\n/* eslint-disable no-redeclare */\n\nexport function subscribe(argsOrSchema, document, rootValue, contextValue, variableValues, operationName, fieldResolver, subscribeFieldResolver) {\n  /* eslint-enable no-redeclare */\n  // Extract arguments from object args if provided.\n  return arguments.length === 1 ? subscribeImpl(argsOrSchema.schema, argsOrSchema.document, argsOrSchema.rootValue, argsOrSchema.contextValue, argsOrSchema.variableValues, argsOrSchema.operationName, argsOrSchema.fieldResolver, argsOrSchema.subscribeFieldResolver) : subscribeImpl(argsOrSchema, document, rootValue, contextValue, variableValues, operationName, fieldResolver, subscribeFieldResolver);\n}\n/**\n * This function checks if the error is a GraphQLError. If it is, report it as\n * an ExecutionResult, containing only errors and no data. Otherwise treat the\n * error as a system-class error and re-throw it.\n */\n\nfunction reportGraphQLError(error) {\n  if (error instanceof GraphQLError) {\n    return {\n      errors: [error]\n    };\n  }\n\n  throw error;\n}\n\nfunction subscribeImpl(schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver, subscribeFieldResolver) {\n  var sourcePromise = createSourceEventStream(schema, document, rootValue, contextValue, variableValues, operationName, subscribeFieldResolver); // For each payload yielded from a subscription, map it over the normal\n  // GraphQL `execute` function, with `payload` as the rootValue.\n  // This implements the \"MapSourceToResponseEvent\" algorithm described in\n  // the GraphQL specification. The `execute` function provides the\n  // \"ExecuteSubscriptionEvent\" algorithm, as it is nearly identical to the\n  // \"ExecuteQuery\" algorithm, for which `execute` is also used.\n\n  var mapSourceToResponse = function mapSourceToResponse(payload) {\n    return execute(schema, document, payload, contextValue, variableValues, operationName, fieldResolver);\n  }; // Resolve the Source Stream, then map every source value to a\n  // ExecutionResult value as described above.\n\n\n  return sourcePromise.then(function (resultOrStream) {\n    return (// Note: Flow can't refine isAsyncIterable, so explicit casts are used.\n      isAsyncIterable(resultOrStream) ? mapAsyncIterator(resultOrStream, mapSourceToResponse, reportGraphQLError) : resultOrStream\n    );\n  }, reportGraphQLError);\n}\n/**\n * Implements the \"CreateSourceEventStream\" algorithm described in the\n * GraphQL specification, resolving the subscription source event stream.\n *\n * Returns a Promise<AsyncIterable>.\n *\n * If the client-provided invalid arguments, the source stream could not be\n * created, or the resolver did not return an AsyncIterable, this function will\n * will throw an error, which should be caught and handled by the caller.\n *\n * A Source Event Stream represents a sequence of events, each of which triggers\n * a GraphQL execution for that event.\n *\n * This may be useful when hosting the stateful subscription service in a\n * different process or machine than the stateless GraphQL execution engine,\n * or otherwise separating these two steps. For more on this, see the\n * \"Supporting Subscriptions at Scale\" information in the GraphQL specification.\n */\n\n\nexport function createSourceEventStream(schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver) {\n  // If arguments are missing or incorrectly typed, this is an internal\n  // developer mistake which should throw an early error.\n  assertValidExecutionArguments(schema, document, variableValues);\n\n  try {\n    // If a valid context cannot be created due to incorrect arguments,\n    // this will throw an error.\n    var exeContext = buildExecutionContext(schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver); // Return early errors if execution context failed.\n\n    if (Array.isArray(exeContext)) {\n      return Promise.resolve({\n        errors: exeContext\n      });\n    }\n\n    var type = getOperationRootType(schema, exeContext.operation);\n    var fields = collectFields(exeContext, type, exeContext.operation.selectionSet, Object.create(null), Object.create(null));\n    var responseNames = Object.keys(fields);\n    var responseName = responseNames[0];\n    var fieldNodes = fields[responseName];\n    var fieldNode = fieldNodes[0];\n    var fieldName = fieldNode.name.value;\n    var fieldDef = getFieldDef(schema, type, fieldName);\n\n    if (!fieldDef) {\n      throw new GraphQLError('The subscription field \"' + fieldName + '\" is not defined.', fieldNodes);\n    } // Call the `subscribe()` resolver or the default resolver to produce an\n    // AsyncIterable yielding raw payloads.\n\n\n    var resolveFn = fieldDef.subscribe || exeContext.fieldResolver;\n    var path = addPath(undefined, responseName);\n    var info = buildResolveInfo(exeContext, fieldDef, fieldNodes, type, path); // resolveFieldValueOrError implements the \"ResolveFieldEventStream\"\n    // algorithm from GraphQL specification. It differs from\n    // \"ResolveFieldValue\" due to providing a different `resolveFn`.\n\n    var result = resolveFieldValueOrError(exeContext, fieldDef, fieldNodes, resolveFn, rootValue, info); // Coerce to Promise for easier error handling and consistent return type.\n\n    return Promise.resolve(result).then(function (eventStream) {\n      // If eventStream is an Error, rethrow a located error.\n      if (eventStream instanceof Error) {\n        throw locatedError(eventStream, fieldNodes, responsePathAsArray(path));\n      } // Assert field returned an event stream, otherwise yield an error.\n\n\n      if (isAsyncIterable(eventStream)) {\n        // Note: isAsyncIterable above ensures this will be correct.\n        return eventStream;\n      }\n\n      throw new Error('Subscription field must return Async Iterable. Received: ' + String(eventStream));\n    });\n  } catch (error) {\n    return Promise.reject(error);\n  }\n}","map":{"version":3,"names":["isAsyncIterable","GraphQLError","locatedError","addPath","assertValidExecutionArguments","buildExecutionContext","buildResolveInfo","collectFields","execute","getFieldDef","getOperationRootType","resolveFieldValueOrError","responsePathAsArray","GraphQLSchema","mapAsyncIterator","subscribe","argsOrSchema","document","rootValue","contextValue","variableValues","operationName","fieldResolver","subscribeFieldResolver","arguments","length","subscribeImpl","schema","reportGraphQLError","error","errors","sourcePromise","createSourceEventStream","mapSourceToResponse","payload","then","resultOrStream","exeContext","Array","isArray","Promise","resolve","type","operation","fields","selectionSet","Object","create","responseNames","keys","responseName","fieldNodes","fieldNode","fieldName","name","value","fieldDef","resolveFn","path","undefined","info","result","eventStream","Error","String","reject"],"sources":["/Users/roaldmaravillas/ro/github/scaffold-appsync-events/node_modules/aws-appsync/node_modules/graphql/module/subscription/subscribe.js"],"sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nimport { isAsyncIterable } from 'iterall';\nimport { GraphQLError } from '../error/GraphQLError';\nimport { locatedError } from '../error/locatedError';\nimport { addPath, assertValidExecutionArguments, buildExecutionContext, buildResolveInfo, collectFields, execute, getFieldDef, getOperationRootType, resolveFieldValueOrError, responsePathAsArray } from '../execution/execute';\nimport { GraphQLSchema } from '../type/schema';\nimport mapAsyncIterator from './mapAsyncIterator';\n\n/**\n * Implements the \"Subscribe\" algorithm described in the GraphQL specification.\n *\n * Returns a Promise which resolves to either an AsyncIterator (if successful)\n * or an ExecutionResult (client error). The promise will be rejected if a\n * server error occurs.\n *\n * If the client-provided arguments to this function do not result in a\n * compliant subscription, a GraphQL Response (ExecutionResult) with\n * descriptive errors and no data will be returned.\n *\n * If the the source stream could not be created due to faulty subscription\n * resolver logic or underlying systems, the promise will resolve to a single\n * ExecutionResult containing `errors` and no `data`.\n *\n * If the operation succeeded, the promise resolves to an AsyncIterator, which\n * yields a stream of ExecutionResults representing the response stream.\n *\n * Accepts either an object with named arguments, or individual arguments.\n */\n\n/* eslint-disable no-redeclare */\n\nexport function subscribe(argsOrSchema, document, rootValue, contextValue, variableValues, operationName, fieldResolver, subscribeFieldResolver) {\n  /* eslint-enable no-redeclare */\n  // Extract arguments from object args if provided.\n  return arguments.length === 1 ? subscribeImpl(argsOrSchema.schema, argsOrSchema.document, argsOrSchema.rootValue, argsOrSchema.contextValue, argsOrSchema.variableValues, argsOrSchema.operationName, argsOrSchema.fieldResolver, argsOrSchema.subscribeFieldResolver) : subscribeImpl(argsOrSchema, document, rootValue, contextValue, variableValues, operationName, fieldResolver, subscribeFieldResolver);\n}\n\n/**\n * This function checks if the error is a GraphQLError. If it is, report it as\n * an ExecutionResult, containing only errors and no data. Otherwise treat the\n * error as a system-class error and re-throw it.\n */\nfunction reportGraphQLError(error) {\n  if (error instanceof GraphQLError) {\n    return { errors: [error] };\n  }\n  throw error;\n}\n\nfunction subscribeImpl(schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver, subscribeFieldResolver) {\n  var sourcePromise = createSourceEventStream(schema, document, rootValue, contextValue, variableValues, operationName, subscribeFieldResolver);\n\n  // For each payload yielded from a subscription, map it over the normal\n  // GraphQL `execute` function, with `payload` as the rootValue.\n  // This implements the \"MapSourceToResponseEvent\" algorithm described in\n  // the GraphQL specification. The `execute` function provides the\n  // \"ExecuteSubscriptionEvent\" algorithm, as it is nearly identical to the\n  // \"ExecuteQuery\" algorithm, for which `execute` is also used.\n  var mapSourceToResponse = function mapSourceToResponse(payload) {\n    return execute(schema, document, payload, contextValue, variableValues, operationName, fieldResolver);\n  };\n\n  // Resolve the Source Stream, then map every source value to a\n  // ExecutionResult value as described above.\n  return sourcePromise.then(function (resultOrStream) {\n    return (\n      // Note: Flow can't refine isAsyncIterable, so explicit casts are used.\n      isAsyncIterable(resultOrStream) ? mapAsyncIterator(resultOrStream, mapSourceToResponse, reportGraphQLError) : resultOrStream\n    );\n  }, reportGraphQLError);\n}\n\n/**\n * Implements the \"CreateSourceEventStream\" algorithm described in the\n * GraphQL specification, resolving the subscription source event stream.\n *\n * Returns a Promise<AsyncIterable>.\n *\n * If the client-provided invalid arguments, the source stream could not be\n * created, or the resolver did not return an AsyncIterable, this function will\n * will throw an error, which should be caught and handled by the caller.\n *\n * A Source Event Stream represents a sequence of events, each of which triggers\n * a GraphQL execution for that event.\n *\n * This may be useful when hosting the stateful subscription service in a\n * different process or machine than the stateless GraphQL execution engine,\n * or otherwise separating these two steps. For more on this, see the\n * \"Supporting Subscriptions at Scale\" information in the GraphQL specification.\n */\nexport function createSourceEventStream(schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver) {\n  // If arguments are missing or incorrectly typed, this is an internal\n  // developer mistake which should throw an early error.\n  assertValidExecutionArguments(schema, document, variableValues);\n\n  try {\n    // If a valid context cannot be created due to incorrect arguments,\n    // this will throw an error.\n    var exeContext = buildExecutionContext(schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver);\n\n    // Return early errors if execution context failed.\n    if (Array.isArray(exeContext)) {\n      return Promise.resolve({ errors: exeContext });\n    }\n\n    var type = getOperationRootType(schema, exeContext.operation);\n    var fields = collectFields(exeContext, type, exeContext.operation.selectionSet, Object.create(null), Object.create(null));\n    var responseNames = Object.keys(fields);\n    var responseName = responseNames[0];\n    var fieldNodes = fields[responseName];\n    var fieldNode = fieldNodes[0];\n    var fieldName = fieldNode.name.value;\n    var fieldDef = getFieldDef(schema, type, fieldName);\n\n    if (!fieldDef) {\n      throw new GraphQLError('The subscription field \"' + fieldName + '\" is not defined.', fieldNodes);\n    }\n\n    // Call the `subscribe()` resolver or the default resolver to produce an\n    // AsyncIterable yielding raw payloads.\n    var resolveFn = fieldDef.subscribe || exeContext.fieldResolver;\n\n    var path = addPath(undefined, responseName);\n\n    var info = buildResolveInfo(exeContext, fieldDef, fieldNodes, type, path);\n\n    // resolveFieldValueOrError implements the \"ResolveFieldEventStream\"\n    // algorithm from GraphQL specification. It differs from\n    // \"ResolveFieldValue\" due to providing a different `resolveFn`.\n    var result = resolveFieldValueOrError(exeContext, fieldDef, fieldNodes, resolveFn, rootValue, info);\n\n    // Coerce to Promise for easier error handling and consistent return type.\n    return Promise.resolve(result).then(function (eventStream) {\n      // If eventStream is an Error, rethrow a located error.\n      if (eventStream instanceof Error) {\n        throw locatedError(eventStream, fieldNodes, responsePathAsArray(path));\n      }\n\n      // Assert field returned an event stream, otherwise yield an error.\n      if (isAsyncIterable(eventStream)) {\n        // Note: isAsyncIterable above ensures this will be correct.\n        return eventStream;\n      }\n      throw new Error('Subscription field must return Async Iterable. Received: ' + String(eventStream));\n    });\n  } catch (error) {\n    return Promise.reject(error);\n  }\n}"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,SAASA,eAAT,QAAgC,SAAhC;AACA,SAASC,YAAT,QAA6B,uBAA7B;AACA,SAASC,YAAT,QAA6B,uBAA7B;AACA,SAASC,OAAT,EAAkBC,6BAAlB,EAAiDC,qBAAjD,EAAwEC,gBAAxE,EAA0FC,aAA1F,EAAyGC,OAAzG,EAAkHC,WAAlH,EAA+HC,oBAA/H,EAAqJC,wBAArJ,EAA+KC,mBAA/K,QAA0M,sBAA1M;AACA,SAASC,aAAT,QAA8B,gBAA9B;AACA,OAAOC,gBAAP,MAA6B,oBAA7B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,OAAO,SAASC,SAAT,CAAmBC,YAAnB,EAAiCC,QAAjC,EAA2CC,SAA3C,EAAsDC,YAAtD,EAAoEC,cAApE,EAAoFC,aAApF,EAAmGC,aAAnG,EAAkHC,sBAAlH,EAA0I;EAC/I;EACA;EACA,OAAOC,SAAS,CAACC,MAAV,KAAqB,CAArB,GAAyBC,aAAa,CAACV,YAAY,CAACW,MAAd,EAAsBX,YAAY,CAACC,QAAnC,EAA6CD,YAAY,CAACE,SAA1D,EAAqEF,YAAY,CAACG,YAAlF,EAAgGH,YAAY,CAACI,cAA7G,EAA6HJ,YAAY,CAACK,aAA1I,EAAyJL,YAAY,CAACM,aAAtK,EAAqLN,YAAY,CAACO,sBAAlM,CAAtC,GAAkQG,aAAa,CAACV,YAAD,EAAeC,QAAf,EAAyBC,SAAzB,EAAoCC,YAApC,EAAkDC,cAAlD,EAAkEC,aAAlE,EAAiFC,aAAjF,EAAgGC,sBAAhG,CAAtR;AACD;AAED;AACA;AACA;AACA;AACA;;AACA,SAASK,kBAAT,CAA4BC,KAA5B,EAAmC;EACjC,IAAIA,KAAK,YAAY5B,YAArB,EAAmC;IACjC,OAAO;MAAE6B,MAAM,EAAE,CAACD,KAAD;IAAV,CAAP;EACD;;EACD,MAAMA,KAAN;AACD;;AAED,SAASH,aAAT,CAAuBC,MAAvB,EAA+BV,QAA/B,EAAyCC,SAAzC,EAAoDC,YAApD,EAAkEC,cAAlE,EAAkFC,aAAlF,EAAiGC,aAAjG,EAAgHC,sBAAhH,EAAwI;EACtI,IAAIQ,aAAa,GAAGC,uBAAuB,CAACL,MAAD,EAASV,QAAT,EAAmBC,SAAnB,EAA8BC,YAA9B,EAA4CC,cAA5C,EAA4DC,aAA5D,EAA2EE,sBAA3E,CAA3C,CADsI,CAGtI;EACA;EACA;EACA;EACA;EACA;;EACA,IAAIU,mBAAmB,GAAG,SAASA,mBAAT,CAA6BC,OAA7B,EAAsC;IAC9D,OAAO1B,OAAO,CAACmB,MAAD,EAASV,QAAT,EAAmBiB,OAAnB,EAA4Bf,YAA5B,EAA0CC,cAA1C,EAA0DC,aAA1D,EAAyEC,aAAzE,CAAd;EACD,CAFD,CATsI,CAatI;EACA;;;EACA,OAAOS,aAAa,CAACI,IAAd,CAAmB,UAAUC,cAAV,EAA0B;IAClD,OACE;MACApC,eAAe,CAACoC,cAAD,CAAf,GAAkCtB,gBAAgB,CAACsB,cAAD,EAAiBH,mBAAjB,EAAsCL,kBAAtC,CAAlD,GAA8GQ;IAFhH;EAID,CALM,EAKJR,kBALI,CAAP;AAMD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,SAASI,uBAAT,CAAiCL,MAAjC,EAAyCV,QAAzC,EAAmDC,SAAnD,EAA8DC,YAA9D,EAA4EC,cAA5E,EAA4FC,aAA5F,EAA2GC,aAA3G,EAA0H;EAC/H;EACA;EACAlB,6BAA6B,CAACuB,MAAD,EAASV,QAAT,EAAmBG,cAAnB,CAA7B;;EAEA,IAAI;IACF;IACA;IACA,IAAIiB,UAAU,GAAGhC,qBAAqB,CAACsB,MAAD,EAASV,QAAT,EAAmBC,SAAnB,EAA8BC,YAA9B,EAA4CC,cAA5C,EAA4DC,aAA5D,EAA2EC,aAA3E,CAAtC,CAHE,CAKF;;IACA,IAAIgB,KAAK,CAACC,OAAN,CAAcF,UAAd,CAAJ,EAA+B;MAC7B,OAAOG,OAAO,CAACC,OAAR,CAAgB;QAAEX,MAAM,EAAEO;MAAV,CAAhB,CAAP;IACD;;IAED,IAAIK,IAAI,GAAGhC,oBAAoB,CAACiB,MAAD,EAASU,UAAU,CAACM,SAApB,CAA/B;IACA,IAAIC,MAAM,GAAGrC,aAAa,CAAC8B,UAAD,EAAaK,IAAb,EAAmBL,UAAU,CAACM,SAAX,CAAqBE,YAAxC,EAAsDC,MAAM,CAACC,MAAP,CAAc,IAAd,CAAtD,EAA2ED,MAAM,CAACC,MAAP,CAAc,IAAd,CAA3E,CAA1B;IACA,IAAIC,aAAa,GAAGF,MAAM,CAACG,IAAP,CAAYL,MAAZ,CAApB;IACA,IAAIM,YAAY,GAAGF,aAAa,CAAC,CAAD,CAAhC;IACA,IAAIG,UAAU,GAAGP,MAAM,CAACM,YAAD,CAAvB;IACA,IAAIE,SAAS,GAAGD,UAAU,CAAC,CAAD,CAA1B;IACA,IAAIE,SAAS,GAAGD,SAAS,CAACE,IAAV,CAAeC,KAA/B;IACA,IAAIC,QAAQ,GAAG/C,WAAW,CAACkB,MAAD,EAASe,IAAT,EAAeW,SAAf,CAA1B;;IAEA,IAAI,CAACG,QAAL,EAAe;MACb,MAAM,IAAIvD,YAAJ,CAAiB,6BAA6BoD,SAA7B,GAAyC,mBAA1D,EAA+EF,UAA/E,CAAN;IACD,CArBC,CAuBF;IACA;;;IACA,IAAIM,SAAS,GAAGD,QAAQ,CAACzC,SAAT,IAAsBsB,UAAU,CAACf,aAAjD;IAEA,IAAIoC,IAAI,GAAGvD,OAAO,CAACwD,SAAD,EAAYT,YAAZ,CAAlB;IAEA,IAAIU,IAAI,GAAGtD,gBAAgB,CAAC+B,UAAD,EAAamB,QAAb,EAAuBL,UAAvB,EAAmCT,IAAnC,EAAyCgB,IAAzC,CAA3B,CA7BE,CA+BF;IACA;IACA;;IACA,IAAIG,MAAM,GAAGlD,wBAAwB,CAAC0B,UAAD,EAAamB,QAAb,EAAuBL,UAAvB,EAAmCM,SAAnC,EAA8CvC,SAA9C,EAAyD0C,IAAzD,CAArC,CAlCE,CAoCF;;IACA,OAAOpB,OAAO,CAACC,OAAR,CAAgBoB,MAAhB,EAAwB1B,IAAxB,CAA6B,UAAU2B,WAAV,EAAuB;MACzD;MACA,IAAIA,WAAW,YAAYC,KAA3B,EAAkC;QAChC,MAAM7D,YAAY,CAAC4D,WAAD,EAAcX,UAAd,EAA0BvC,mBAAmB,CAAC8C,IAAD,CAA7C,CAAlB;MACD,CAJwD,CAMzD;;;MACA,IAAI1D,eAAe,CAAC8D,WAAD,CAAnB,EAAkC;QAChC;QACA,OAAOA,WAAP;MACD;;MACD,MAAM,IAAIC,KAAJ,CAAU,8DAA8DC,MAAM,CAACF,WAAD,CAA9E,CAAN;IACD,CAZM,CAAP;EAaD,CAlDD,CAkDE,OAAOjC,KAAP,EAAc;IACd,OAAOW,OAAO,CAACyB,MAAR,CAAepC,KAAf,CAAP;EACD;AACF"},"metadata":{},"sourceType":"module"}