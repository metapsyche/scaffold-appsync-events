{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.extendSchema = extendSchema;\n\nvar _invariant = require('../jsutils/invariant');\n\nvar _invariant2 = _interopRequireDefault(_invariant);\n\nvar _keyMap = require('../jsutils/keyMap');\n\nvar _keyMap2 = _interopRequireDefault(_keyMap);\n\nvar _keyValMap = require('../jsutils/keyValMap');\n\nvar _keyValMap2 = _interopRequireDefault(_keyValMap);\n\nvar _buildASTSchema = require('./buildASTSchema');\n\nvar _valueFromAST = require('./valueFromAST');\n\nvar _GraphQLError = require('../error/GraphQLError');\n\nvar _schema = require('../type/schema');\n\nvar _definition = require('../type/definition');\n\nvar _directives = require('../type/directives');\n\nvar _introspection = require('../type/introspection');\n\nvar _scalars = require('../type/scalars');\n\nvar _kinds = require('../language/kinds');\n\nvar Kind = _interopRequireWildcard(_kinds);\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Produces a new schema given an existing schema and a document which may\n * contain GraphQL type extensions and definitions. The original schema will\n * remain unaltered.\n *\n * Because a schema represents a graph of references, a schema cannot be\n * extended without effectively making an entire copy. We do not know until it's\n * too late if subgraphs remain unchanged.\n *\n * This algorithm copies the provided schema, applying extensions while\n * producing the copy. The original schema remains unaltered.\n */\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\nfunction extendSchema(schema, documentAST) {\n  !(schema instanceof _schema.GraphQLSchema) ? (0, _invariant2.default)(0, 'Must provide valid GraphQLSchema') : void 0;\n  !(documentAST && documentAST.kind === Kind.DOCUMENT) ? (0, _invariant2.default)(0, 'Must provide valid Document AST') : void 0; // Collect the type definitions and extensions found in the document.\n\n  var typeDefinitionMap = Object.create(null);\n  var typeExtensionsMap = Object.create(null); // New directives and types are separate because a directives and types can\n  // have the same name. For example, a type named \"skip\".\n\n  var directiveDefinitions = [];\n\n  for (var i = 0; i < documentAST.definitions.length; i++) {\n    var def = documentAST.definitions[i];\n\n    switch (def.kind) {\n      case Kind.OBJECT_TYPE_DEFINITION:\n      case Kind.INTERFACE_TYPE_DEFINITION:\n      case Kind.ENUM_TYPE_DEFINITION:\n      case Kind.UNION_TYPE_DEFINITION:\n      case Kind.SCALAR_TYPE_DEFINITION:\n      case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n        // Sanity check that none of the defined types conflict with the\n        // schema's existing types.\n        var typeName = def.name.value;\n\n        if (schema.getType(typeName)) {\n          throw new _GraphQLError.GraphQLError('Type \"' + typeName + '\" already exists in the schema. It cannot also ' + 'be defined in this type definition.', [def]);\n        }\n\n        typeDefinitionMap[typeName] = def;\n        break;\n\n      case Kind.TYPE_EXTENSION_DEFINITION:\n        // Sanity check that this type extension exists within the\n        // schema's existing types.\n        var extendedTypeName = def.definition.name.value;\n        var existingType = schema.getType(extendedTypeName);\n\n        if (!existingType) {\n          throw new _GraphQLError.GraphQLError('Cannot extend type \"' + extendedTypeName + '\" because it does not ' + 'exist in the existing schema.', [def.definition]);\n        }\n\n        if (!(existingType instanceof _definition.GraphQLObjectType)) {\n          throw new _GraphQLError.GraphQLError('Cannot extend non-object type \"' + extendedTypeName + '\".', [def.definition]);\n        }\n\n        var extensions = typeExtensionsMap[extendedTypeName];\n\n        if (extensions) {\n          extensions.push(def);\n        } else {\n          extensions = [def];\n        }\n\n        typeExtensionsMap[extendedTypeName] = extensions;\n        break;\n\n      case Kind.DIRECTIVE_DEFINITION:\n        var directiveName = def.name.value;\n        var existingDirective = schema.getDirective(directiveName);\n\n        if (existingDirective) {\n          throw new _GraphQLError.GraphQLError('Directive \"' + directiveName + '\" already exists in the schema. It ' + 'cannot be redefined.', [def]);\n        }\n\n        directiveDefinitions.push(def);\n        break;\n    }\n  } // If this document contains no new types, extensions, or directives then\n  // return the same unmodified GraphQLSchema instance.\n\n\n  if (Object.keys(typeExtensionsMap).length === 0 && Object.keys(typeDefinitionMap).length === 0 && directiveDefinitions.length === 0) {\n    return schema;\n  } // A cache to use to store the actual GraphQLType definition objects by name.\n  // Initialize to the GraphQL built in scalars and introspection types. All\n  // functions below are inline so that this type def cache is within the scope\n  // of the closure.\n\n\n  var typeDefCache = {\n    String: _scalars.GraphQLString,\n    Int: _scalars.GraphQLInt,\n    Float: _scalars.GraphQLFloat,\n    Boolean: _scalars.GraphQLBoolean,\n    ID: _scalars.GraphQLID,\n    __Schema: _introspection.__Schema,\n    __Directive: _introspection.__Directive,\n    __DirectiveLocation: _introspection.__DirectiveLocation,\n    __Type: _introspection.__Type,\n    __Field: _introspection.__Field,\n    __InputValue: _introspection.__InputValue,\n    __EnumValue: _introspection.__EnumValue,\n    __TypeKind: _introspection.__TypeKind\n  }; // Get the root Query, Mutation, and Subscription object types.\n\n  var queryType = getTypeFromDef(schema.getQueryType());\n  var existingMutationType = schema.getMutationType();\n  var mutationType = existingMutationType ? getTypeFromDef(existingMutationType) : null;\n  var existingSubscriptionType = schema.getSubscriptionType();\n  var subscriptionType = existingSubscriptionType ? getTypeFromDef(existingSubscriptionType) : null; // Iterate through all types, getting the type definition for each, ensuring\n  // that any type not directly referenced by a field will get created.\n\n  var typeMap = schema.getTypeMap();\n  var types = Object.keys(typeMap).map(function (typeName) {\n    return getTypeFromDef(typeMap[typeName]);\n  }); // Do the same with new types, appending to the list of defined types.\n\n  Object.keys(typeDefinitionMap).forEach(function (typeName) {\n    types.push(getTypeFromAST(typeDefinitionMap[typeName]));\n  }); // Then produce and return a Schema with these types.\n\n  return new _schema.GraphQLSchema({\n    query: queryType,\n    mutation: mutationType,\n    subscription: subscriptionType,\n    types: types,\n    directives: getMergedDirectives(),\n    astNode: schema.astNode\n  }); // Below are functions used for producing this schema that have closed over\n  // this scope and have access to the schema, cache, and newly defined types.\n\n  function getMergedDirectives() {\n    var existingDirectives = schema.getDirectives();\n    !existingDirectives ? (0, _invariant2.default)(0, 'schema must have default directives') : void 0;\n    var newDirectives = directiveDefinitions.map(function (directiveNode) {\n      return getDirective(directiveNode);\n    });\n    return existingDirectives.concat(newDirectives);\n  }\n\n  function getTypeFromDef(typeDef) {\n    var type = _getNamedType(typeDef.name);\n\n    !type ? (0, _invariant2.default)(0, 'Missing type from schema') : void 0;\n    return type;\n  }\n\n  function getTypeFromAST(node) {\n    var type = _getNamedType(node.name.value);\n\n    if (!type) {\n      throw new _GraphQLError.GraphQLError('Unknown type: \"' + node.name.value + '\". Ensure that this type exists ' + 'either in the original schema, or is added in a type definition.', [node]);\n    }\n\n    return type;\n  }\n\n  function getObjectTypeFromAST(node) {\n    var type = getTypeFromAST(node);\n    !(type instanceof _definition.GraphQLObjectType) ? (0, _invariant2.default)(0, 'Must be Object type.') : void 0;\n    return type;\n  }\n\n  function getInterfaceTypeFromAST(node) {\n    var type = getTypeFromAST(node);\n    !(type instanceof _definition.GraphQLInterfaceType) ? (0, _invariant2.default)(0, 'Must be Interface type.') : void 0;\n    return type;\n  }\n\n  function getInputTypeFromAST(node) {\n    return (0, _definition.assertInputType)(getTypeFromAST(node));\n  }\n\n  function getOutputTypeFromAST(node) {\n    return (0, _definition.assertOutputType)(getTypeFromAST(node));\n  } // Given a name, returns a type from either the existing schema or an\n  // added type.\n\n\n  function _getNamedType(typeName) {\n    var cachedTypeDef = typeDefCache[typeName];\n\n    if (cachedTypeDef) {\n      return cachedTypeDef;\n    }\n\n    var existingType = schema.getType(typeName);\n\n    if (existingType) {\n      var typeDef = extendType(existingType);\n      typeDefCache[typeName] = typeDef;\n      return typeDef;\n    }\n\n    var typeNode = typeDefinitionMap[typeName];\n\n    if (typeNode) {\n      var _typeDef = buildType(typeNode);\n\n      typeDefCache[typeName] = _typeDef;\n      return _typeDef;\n    }\n  } // Given a type's introspection result, construct the correct\n  // GraphQLType instance.\n\n\n  function extendType(type) {\n    if (type instanceof _definition.GraphQLObjectType) {\n      return extendObjectType(type);\n    }\n\n    if (type instanceof _definition.GraphQLInterfaceType) {\n      return extendInterfaceType(type);\n    }\n\n    if (type instanceof _definition.GraphQLUnionType) {\n      return extendUnionType(type);\n    }\n\n    return type;\n  }\n\n  function extendObjectType(type) {\n    var name = type.name;\n    var extensionASTNodes = type.extensionASTNodes;\n\n    if (typeExtensionsMap[name]) {\n      extensionASTNodes = extensionASTNodes.concat(typeExtensionsMap[name]);\n    }\n\n    return new _definition.GraphQLObjectType({\n      name: name,\n      description: type.description,\n      interfaces: function interfaces() {\n        return extendImplementedInterfaces(type);\n      },\n      fields: function fields() {\n        return extendFieldMap(type);\n      },\n      astNode: type.astNode,\n      extensionASTNodes: extensionASTNodes,\n      isTypeOf: type.isTypeOf\n    });\n  }\n\n  function extendInterfaceType(type) {\n    return new _definition.GraphQLInterfaceType({\n      name: type.name,\n      description: type.description,\n      fields: function fields() {\n        return extendFieldMap(type);\n      },\n      astNode: type.astNode,\n      resolveType: type.resolveType\n    });\n  }\n\n  function extendUnionType(type) {\n    return new _definition.GraphQLUnionType({\n      name: type.name,\n      description: type.description,\n      types: type.getTypes().map(getTypeFromDef),\n      astNode: type.astNode,\n      resolveType: type.resolveType\n    });\n  }\n\n  function extendImplementedInterfaces(type) {\n    var interfaces = type.getInterfaces().map(getTypeFromDef); // If there are any extensions to the interfaces, apply those here.\n\n    var extensions = typeExtensionsMap[type.name];\n\n    if (extensions) {\n      extensions.forEach(function (extension) {\n        extension.definition.interfaces.forEach(function (namedType) {\n          var interfaceName = namedType.name.value;\n\n          if (interfaces.some(function (def) {\n            return def.name === interfaceName;\n          })) {\n            throw new _GraphQLError.GraphQLError('Type \"' + type.name + '\" already implements \"' + interfaceName + '\". ' + 'It cannot also be implemented in this type extension.', [namedType]);\n          }\n\n          interfaces.push(getInterfaceTypeFromAST(namedType));\n        });\n      });\n    }\n\n    return interfaces;\n  }\n\n  function extendFieldMap(type) {\n    var newFieldMap = Object.create(null);\n    var oldFieldMap = type.getFields();\n    Object.keys(oldFieldMap).forEach(function (fieldName) {\n      var field = oldFieldMap[fieldName];\n      newFieldMap[fieldName] = {\n        description: field.description,\n        deprecationReason: field.deprecationReason,\n        type: extendFieldType(field.type),\n        args: (0, _keyMap2.default)(field.args, function (arg) {\n          return arg.name;\n        }),\n        astNode: field.astNode,\n        resolve: field.resolve\n      };\n    }); // If there are any extensions to the fields, apply those here.\n\n    var extensions = typeExtensionsMap[type.name];\n\n    if (extensions) {\n      extensions.forEach(function (extension) {\n        extension.definition.fields.forEach(function (field) {\n          var fieldName = field.name.value;\n\n          if (oldFieldMap[fieldName]) {\n            throw new _GraphQLError.GraphQLError('Field \"' + type.name + '.' + fieldName + '\" already exists in the ' + 'schema. It cannot also be defined in this type extension.', [field]);\n          }\n\n          newFieldMap[fieldName] = {\n            description: (0, _buildASTSchema.getDescription)(field),\n            type: buildOutputFieldType(field.type),\n            args: buildInputValues(field.arguments),\n            deprecationReason: (0, _buildASTSchema.getDeprecationReason)(field),\n            astNode: field\n          };\n        });\n      });\n    }\n\n    return newFieldMap;\n  }\n\n  function extendFieldType(typeDef) {\n    if (typeDef instanceof _definition.GraphQLList) {\n      return new _definition.GraphQLList(extendFieldType(typeDef.ofType));\n    }\n\n    if (typeDef instanceof _definition.GraphQLNonNull) {\n      return new _definition.GraphQLNonNull(extendFieldType(typeDef.ofType));\n    }\n\n    return getTypeFromDef(typeDef);\n  }\n\n  function buildType(typeNode) {\n    switch (typeNode.kind) {\n      case Kind.OBJECT_TYPE_DEFINITION:\n        return buildObjectType(typeNode);\n\n      case Kind.INTERFACE_TYPE_DEFINITION:\n        return buildInterfaceType(typeNode);\n\n      case Kind.UNION_TYPE_DEFINITION:\n        return buildUnionType(typeNode);\n\n      case Kind.SCALAR_TYPE_DEFINITION:\n        return buildScalarType(typeNode);\n\n      case Kind.ENUM_TYPE_DEFINITION:\n        return buildEnumType(typeNode);\n\n      case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n        return buildInputObjectType(typeNode);\n    }\n\n    throw new TypeError('Unknown type kind ' + typeNode.kind);\n  }\n\n  function buildObjectType(typeNode) {\n    return new _definition.GraphQLObjectType({\n      name: typeNode.name.value,\n      description: (0, _buildASTSchema.getDescription)(typeNode),\n      interfaces: function interfaces() {\n        return buildImplementedInterfaces(typeNode);\n      },\n      fields: function fields() {\n        return buildFieldMap(typeNode);\n      },\n      astNode: typeNode\n    });\n  }\n\n  function buildInterfaceType(typeNode) {\n    return new _definition.GraphQLInterfaceType({\n      name: typeNode.name.value,\n      description: (0, _buildASTSchema.getDescription)(typeNode),\n      fields: function fields() {\n        return buildFieldMap(typeNode);\n      },\n      astNode: typeNode,\n      resolveType: cannotExecuteExtendedSchema\n    });\n  }\n\n  function buildUnionType(typeNode) {\n    return new _definition.GraphQLUnionType({\n      name: typeNode.name.value,\n      description: (0, _buildASTSchema.getDescription)(typeNode),\n      types: typeNode.types.map(getObjectTypeFromAST),\n      astNode: typeNode,\n      resolveType: cannotExecuteExtendedSchema\n    });\n  }\n\n  function buildScalarType(typeNode) {\n    return new _definition.GraphQLScalarType({\n      name: typeNode.name.value,\n      description: (0, _buildASTSchema.getDescription)(typeNode),\n      astNode: typeNode,\n      serialize: function serialize(id) {\n        return id;\n      },\n      // Note: validation calls the parse functions to determine if a\n      // literal value is correct. Returning null would cause use of custom\n      // scalars to always fail validation. Returning false causes them to\n      // always pass validation.\n      parseValue: function parseValue() {\n        return false;\n      },\n      parseLiteral: function parseLiteral() {\n        return false;\n      }\n    });\n  }\n\n  function buildEnumType(typeNode) {\n    return new _definition.GraphQLEnumType({\n      name: typeNode.name.value,\n      description: (0, _buildASTSchema.getDescription)(typeNode),\n      values: (0, _keyValMap2.default)(typeNode.values, function (enumValue) {\n        return enumValue.name.value;\n      }, function (enumValue) {\n        return {\n          description: (0, _buildASTSchema.getDescription)(enumValue),\n          deprecationReason: (0, _buildASTSchema.getDeprecationReason)(enumValue),\n          astNode: enumValue\n        };\n      }),\n      astNode: typeNode\n    });\n  }\n\n  function buildInputObjectType(typeNode) {\n    return new _definition.GraphQLInputObjectType({\n      name: typeNode.name.value,\n      description: (0, _buildASTSchema.getDescription)(typeNode),\n      fields: function fields() {\n        return buildInputValues(typeNode.fields);\n      },\n      astNode: typeNode\n    });\n  }\n\n  function getDirective(directiveNode) {\n    return new _directives.GraphQLDirective({\n      name: directiveNode.name.value,\n      description: (0, _buildASTSchema.getDescription)(directiveNode),\n      locations: directiveNode.locations.map(function (node) {\n        return node.value;\n      }),\n      args: directiveNode.arguments && buildInputValues(directiveNode.arguments),\n      astNode: directiveNode\n    });\n  }\n\n  function buildImplementedInterfaces(typeNode) {\n    return typeNode.interfaces && typeNode.interfaces.map(getInterfaceTypeFromAST);\n  }\n\n  function buildFieldMap(typeNode) {\n    return (0, _keyValMap2.default)(typeNode.fields, function (field) {\n      return field.name.value;\n    }, function (field) {\n      return {\n        type: buildOutputFieldType(field.type),\n        description: (0, _buildASTSchema.getDescription)(field),\n        args: buildInputValues(field.arguments),\n        deprecationReason: (0, _buildASTSchema.getDeprecationReason)(field),\n        astNode: field\n      };\n    });\n  }\n\n  function buildInputValues(values) {\n    return (0, _keyValMap2.default)(values, function (value) {\n      return value.name.value;\n    }, function (value) {\n      var type = buildInputFieldType(value.type);\n      return {\n        type: type,\n        description: (0, _buildASTSchema.getDescription)(value),\n        defaultValue: (0, _valueFromAST.valueFromAST)(value.defaultValue, type),\n        astNode: value\n      };\n    });\n  }\n\n  function buildInputFieldType(typeNode) {\n    if (typeNode.kind === Kind.LIST_TYPE) {\n      return new _definition.GraphQLList(buildInputFieldType(typeNode.type));\n    }\n\n    if (typeNode.kind === Kind.NON_NULL_TYPE) {\n      var nullableType = buildInputFieldType(typeNode.type);\n      !!(nullableType instanceof _definition.GraphQLNonNull) ? (0, _invariant2.default)(0, 'Must be nullable') : void 0;\n      return new _definition.GraphQLNonNull(nullableType);\n    }\n\n    return getInputTypeFromAST(typeNode);\n  }\n\n  function buildOutputFieldType(typeNode) {\n    if (typeNode.kind === Kind.LIST_TYPE) {\n      return new _definition.GraphQLList(buildOutputFieldType(typeNode.type));\n    }\n\n    if (typeNode.kind === Kind.NON_NULL_TYPE) {\n      var nullableType = buildOutputFieldType(typeNode.type);\n      !!(nullableType instanceof _definition.GraphQLNonNull) ? (0, _invariant2.default)(0, 'Must be nullable') : void 0;\n      return new _definition.GraphQLNonNull(nullableType);\n    }\n\n    return getOutputTypeFromAST(typeNode);\n  }\n}\n\nfunction cannotExecuteExtendedSchema() {\n  throw new Error('Extended Schema cannot use Interface or Union types for execution.');\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","extendSchema","_invariant","require","_invariant2","_interopRequireDefault","_keyMap","_keyMap2","_keyValMap","_keyValMap2","_buildASTSchema","_valueFromAST","_GraphQLError","_schema","_definition","_directives","_introspection","_scalars","_kinds","Kind","_interopRequireWildcard","obj","__esModule","newObj","key","prototype","hasOwnProperty","call","default","schema","documentAST","GraphQLSchema","kind","DOCUMENT","typeDefinitionMap","create","typeExtensionsMap","directiveDefinitions","i","definitions","length","def","OBJECT_TYPE_DEFINITION","INTERFACE_TYPE_DEFINITION","ENUM_TYPE_DEFINITION","UNION_TYPE_DEFINITION","SCALAR_TYPE_DEFINITION","INPUT_OBJECT_TYPE_DEFINITION","typeName","name","getType","GraphQLError","TYPE_EXTENSION_DEFINITION","extendedTypeName","definition","existingType","GraphQLObjectType","extensions","push","DIRECTIVE_DEFINITION","directiveName","existingDirective","getDirective","keys","typeDefCache","String","GraphQLString","Int","GraphQLInt","Float","GraphQLFloat","Boolean","GraphQLBoolean","ID","GraphQLID","__Schema","__Directive","__DirectiveLocation","__Type","__Field","__InputValue","__EnumValue","__TypeKind","queryType","getTypeFromDef","getQueryType","existingMutationType","getMutationType","mutationType","existingSubscriptionType","getSubscriptionType","subscriptionType","typeMap","getTypeMap","types","map","forEach","getTypeFromAST","query","mutation","subscription","directives","getMergedDirectives","astNode","existingDirectives","getDirectives","newDirectives","directiveNode","concat","typeDef","type","_getNamedType","node","getObjectTypeFromAST","getInterfaceTypeFromAST","GraphQLInterfaceType","getInputTypeFromAST","assertInputType","getOutputTypeFromAST","assertOutputType","cachedTypeDef","extendType","typeNode","_typeDef","buildType","extendObjectType","extendInterfaceType","GraphQLUnionType","extendUnionType","extensionASTNodes","description","interfaces","extendImplementedInterfaces","fields","extendFieldMap","isTypeOf","resolveType","getTypes","getInterfaces","extension","namedType","interfaceName","some","newFieldMap","oldFieldMap","getFields","fieldName","field","deprecationReason","extendFieldType","args","arg","resolve","getDescription","buildOutputFieldType","buildInputValues","arguments","getDeprecationReason","GraphQLList","ofType","GraphQLNonNull","buildObjectType","buildInterfaceType","buildUnionType","buildScalarType","buildEnumType","buildInputObjectType","TypeError","buildImplementedInterfaces","buildFieldMap","cannotExecuteExtendedSchema","GraphQLScalarType","serialize","id","parseValue","parseLiteral","GraphQLEnumType","values","enumValue","GraphQLInputObjectType","GraphQLDirective","locations","buildInputFieldType","defaultValue","valueFromAST","LIST_TYPE","NON_NULL_TYPE","nullableType","Error"],"sources":["/Users/roaldmaravillas/ro/github/scaffold-appsync-events/node_modules/graphql/utilities/extendSchema.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.extendSchema = extendSchema;\n\nvar _invariant = require('../jsutils/invariant');\n\nvar _invariant2 = _interopRequireDefault(_invariant);\n\nvar _keyMap = require('../jsutils/keyMap');\n\nvar _keyMap2 = _interopRequireDefault(_keyMap);\n\nvar _keyValMap = require('../jsutils/keyValMap');\n\nvar _keyValMap2 = _interopRequireDefault(_keyValMap);\n\nvar _buildASTSchema = require('./buildASTSchema');\n\nvar _valueFromAST = require('./valueFromAST');\n\nvar _GraphQLError = require('../error/GraphQLError');\n\nvar _schema = require('../type/schema');\n\nvar _definition = require('../type/definition');\n\nvar _directives = require('../type/directives');\n\nvar _introspection = require('../type/introspection');\n\nvar _scalars = require('../type/scalars');\n\nvar _kinds = require('../language/kinds');\n\nvar Kind = _interopRequireWildcard(_kinds);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Produces a new schema given an existing schema and a document which may\n * contain GraphQL type extensions and definitions. The original schema will\n * remain unaltered.\n *\n * Because a schema represents a graph of references, a schema cannot be\n * extended without effectively making an entire copy. We do not know until it's\n * too late if subgraphs remain unchanged.\n *\n * This algorithm copies the provided schema, applying extensions while\n * producing the copy. The original schema remains unaltered.\n */\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nfunction extendSchema(schema, documentAST) {\n  !(schema instanceof _schema.GraphQLSchema) ? (0, _invariant2.default)(0, 'Must provide valid GraphQLSchema') : void 0;\n\n  !(documentAST && documentAST.kind === Kind.DOCUMENT) ? (0, _invariant2.default)(0, 'Must provide valid Document AST') : void 0;\n\n  // Collect the type definitions and extensions found in the document.\n  var typeDefinitionMap = Object.create(null);\n  var typeExtensionsMap = Object.create(null);\n\n  // New directives and types are separate because a directives and types can\n  // have the same name. For example, a type named \"skip\".\n  var directiveDefinitions = [];\n\n  for (var i = 0; i < documentAST.definitions.length; i++) {\n    var def = documentAST.definitions[i];\n    switch (def.kind) {\n      case Kind.OBJECT_TYPE_DEFINITION:\n      case Kind.INTERFACE_TYPE_DEFINITION:\n      case Kind.ENUM_TYPE_DEFINITION:\n      case Kind.UNION_TYPE_DEFINITION:\n      case Kind.SCALAR_TYPE_DEFINITION:\n      case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n        // Sanity check that none of the defined types conflict with the\n        // schema's existing types.\n        var typeName = def.name.value;\n        if (schema.getType(typeName)) {\n          throw new _GraphQLError.GraphQLError('Type \"' + typeName + '\" already exists in the schema. It cannot also ' + 'be defined in this type definition.', [def]);\n        }\n        typeDefinitionMap[typeName] = def;\n        break;\n      case Kind.TYPE_EXTENSION_DEFINITION:\n        // Sanity check that this type extension exists within the\n        // schema's existing types.\n        var extendedTypeName = def.definition.name.value;\n        var existingType = schema.getType(extendedTypeName);\n        if (!existingType) {\n          throw new _GraphQLError.GraphQLError('Cannot extend type \"' + extendedTypeName + '\" because it does not ' + 'exist in the existing schema.', [def.definition]);\n        }\n        if (!(existingType instanceof _definition.GraphQLObjectType)) {\n          throw new _GraphQLError.GraphQLError('Cannot extend non-object type \"' + extendedTypeName + '\".', [def.definition]);\n        }\n        var extensions = typeExtensionsMap[extendedTypeName];\n        if (extensions) {\n          extensions.push(def);\n        } else {\n          extensions = [def];\n        }\n        typeExtensionsMap[extendedTypeName] = extensions;\n        break;\n      case Kind.DIRECTIVE_DEFINITION:\n        var directiveName = def.name.value;\n        var existingDirective = schema.getDirective(directiveName);\n        if (existingDirective) {\n          throw new _GraphQLError.GraphQLError('Directive \"' + directiveName + '\" already exists in the schema. It ' + 'cannot be redefined.', [def]);\n        }\n        directiveDefinitions.push(def);\n        break;\n    }\n  }\n\n  // If this document contains no new types, extensions, or directives then\n  // return the same unmodified GraphQLSchema instance.\n  if (Object.keys(typeExtensionsMap).length === 0 && Object.keys(typeDefinitionMap).length === 0 && directiveDefinitions.length === 0) {\n    return schema;\n  }\n\n  // A cache to use to store the actual GraphQLType definition objects by name.\n  // Initialize to the GraphQL built in scalars and introspection types. All\n  // functions below are inline so that this type def cache is within the scope\n  // of the closure.\n  var typeDefCache = {\n    String: _scalars.GraphQLString,\n    Int: _scalars.GraphQLInt,\n    Float: _scalars.GraphQLFloat,\n    Boolean: _scalars.GraphQLBoolean,\n    ID: _scalars.GraphQLID,\n    __Schema: _introspection.__Schema,\n    __Directive: _introspection.__Directive,\n    __DirectiveLocation: _introspection.__DirectiveLocation,\n    __Type: _introspection.__Type,\n    __Field: _introspection.__Field,\n    __InputValue: _introspection.__InputValue,\n    __EnumValue: _introspection.__EnumValue,\n    __TypeKind: _introspection.__TypeKind\n  };\n\n  // Get the root Query, Mutation, and Subscription object types.\n  var queryType = getTypeFromDef(schema.getQueryType());\n\n  var existingMutationType = schema.getMutationType();\n  var mutationType = existingMutationType ? getTypeFromDef(existingMutationType) : null;\n\n  var existingSubscriptionType = schema.getSubscriptionType();\n  var subscriptionType = existingSubscriptionType ? getTypeFromDef(existingSubscriptionType) : null;\n\n  // Iterate through all types, getting the type definition for each, ensuring\n  // that any type not directly referenced by a field will get created.\n  var typeMap = schema.getTypeMap();\n  var types = Object.keys(typeMap).map(function (typeName) {\n    return getTypeFromDef(typeMap[typeName]);\n  });\n\n  // Do the same with new types, appending to the list of defined types.\n  Object.keys(typeDefinitionMap).forEach(function (typeName) {\n    types.push(getTypeFromAST(typeDefinitionMap[typeName]));\n  });\n\n  // Then produce and return a Schema with these types.\n  return new _schema.GraphQLSchema({\n    query: queryType,\n    mutation: mutationType,\n    subscription: subscriptionType,\n    types: types,\n    directives: getMergedDirectives(),\n    astNode: schema.astNode\n  });\n\n  // Below are functions used for producing this schema that have closed over\n  // this scope and have access to the schema, cache, and newly defined types.\n\n  function getMergedDirectives() {\n    var existingDirectives = schema.getDirectives();\n    !existingDirectives ? (0, _invariant2.default)(0, 'schema must have default directives') : void 0;\n\n    var newDirectives = directiveDefinitions.map(function (directiveNode) {\n      return getDirective(directiveNode);\n    });\n    return existingDirectives.concat(newDirectives);\n  }\n\n  function getTypeFromDef(typeDef) {\n    var type = _getNamedType(typeDef.name);\n    !type ? (0, _invariant2.default)(0, 'Missing type from schema') : void 0;\n    return type;\n  }\n\n  function getTypeFromAST(node) {\n    var type = _getNamedType(node.name.value);\n    if (!type) {\n      throw new _GraphQLError.GraphQLError('Unknown type: \"' + node.name.value + '\". Ensure that this type exists ' + 'either in the original schema, or is added in a type definition.', [node]);\n    }\n    return type;\n  }\n\n  function getObjectTypeFromAST(node) {\n    var type = getTypeFromAST(node);\n    !(type instanceof _definition.GraphQLObjectType) ? (0, _invariant2.default)(0, 'Must be Object type.') : void 0;\n    return type;\n  }\n\n  function getInterfaceTypeFromAST(node) {\n    var type = getTypeFromAST(node);\n    !(type instanceof _definition.GraphQLInterfaceType) ? (0, _invariant2.default)(0, 'Must be Interface type.') : void 0;\n    return type;\n  }\n\n  function getInputTypeFromAST(node) {\n    return (0, _definition.assertInputType)(getTypeFromAST(node));\n  }\n\n  function getOutputTypeFromAST(node) {\n    return (0, _definition.assertOutputType)(getTypeFromAST(node));\n  }\n\n  // Given a name, returns a type from either the existing schema or an\n  // added type.\n  function _getNamedType(typeName) {\n    var cachedTypeDef = typeDefCache[typeName];\n    if (cachedTypeDef) {\n      return cachedTypeDef;\n    }\n\n    var existingType = schema.getType(typeName);\n    if (existingType) {\n      var typeDef = extendType(existingType);\n      typeDefCache[typeName] = typeDef;\n      return typeDef;\n    }\n\n    var typeNode = typeDefinitionMap[typeName];\n    if (typeNode) {\n      var _typeDef = buildType(typeNode);\n      typeDefCache[typeName] = _typeDef;\n      return _typeDef;\n    }\n  }\n\n  // Given a type's introspection result, construct the correct\n  // GraphQLType instance.\n  function extendType(type) {\n    if (type instanceof _definition.GraphQLObjectType) {\n      return extendObjectType(type);\n    }\n    if (type instanceof _definition.GraphQLInterfaceType) {\n      return extendInterfaceType(type);\n    }\n    if (type instanceof _definition.GraphQLUnionType) {\n      return extendUnionType(type);\n    }\n    return type;\n  }\n\n  function extendObjectType(type) {\n    var name = type.name;\n    var extensionASTNodes = type.extensionASTNodes;\n    if (typeExtensionsMap[name]) {\n      extensionASTNodes = extensionASTNodes.concat(typeExtensionsMap[name]);\n    }\n\n    return new _definition.GraphQLObjectType({\n      name: name,\n      description: type.description,\n      interfaces: function interfaces() {\n        return extendImplementedInterfaces(type);\n      },\n      fields: function fields() {\n        return extendFieldMap(type);\n      },\n      astNode: type.astNode,\n      extensionASTNodes: extensionASTNodes,\n      isTypeOf: type.isTypeOf\n    });\n  }\n\n  function extendInterfaceType(type) {\n    return new _definition.GraphQLInterfaceType({\n      name: type.name,\n      description: type.description,\n      fields: function fields() {\n        return extendFieldMap(type);\n      },\n      astNode: type.astNode,\n      resolveType: type.resolveType\n    });\n  }\n\n  function extendUnionType(type) {\n    return new _definition.GraphQLUnionType({\n      name: type.name,\n      description: type.description,\n      types: type.getTypes().map(getTypeFromDef),\n      astNode: type.astNode,\n      resolveType: type.resolveType\n    });\n  }\n\n  function extendImplementedInterfaces(type) {\n    var interfaces = type.getInterfaces().map(getTypeFromDef);\n\n    // If there are any extensions to the interfaces, apply those here.\n    var extensions = typeExtensionsMap[type.name];\n    if (extensions) {\n      extensions.forEach(function (extension) {\n        extension.definition.interfaces.forEach(function (namedType) {\n          var interfaceName = namedType.name.value;\n          if (interfaces.some(function (def) {\n            return def.name === interfaceName;\n          })) {\n            throw new _GraphQLError.GraphQLError('Type \"' + type.name + '\" already implements \"' + interfaceName + '\". ' + 'It cannot also be implemented in this type extension.', [namedType]);\n          }\n          interfaces.push(getInterfaceTypeFromAST(namedType));\n        });\n      });\n    }\n\n    return interfaces;\n  }\n\n  function extendFieldMap(type) {\n    var newFieldMap = Object.create(null);\n    var oldFieldMap = type.getFields();\n    Object.keys(oldFieldMap).forEach(function (fieldName) {\n      var field = oldFieldMap[fieldName];\n      newFieldMap[fieldName] = {\n        description: field.description,\n        deprecationReason: field.deprecationReason,\n        type: extendFieldType(field.type),\n        args: (0, _keyMap2.default)(field.args, function (arg) {\n          return arg.name;\n        }),\n        astNode: field.astNode,\n        resolve: field.resolve\n      };\n    });\n\n    // If there are any extensions to the fields, apply those here.\n    var extensions = typeExtensionsMap[type.name];\n    if (extensions) {\n      extensions.forEach(function (extension) {\n        extension.definition.fields.forEach(function (field) {\n          var fieldName = field.name.value;\n          if (oldFieldMap[fieldName]) {\n            throw new _GraphQLError.GraphQLError('Field \"' + type.name + '.' + fieldName + '\" already exists in the ' + 'schema. It cannot also be defined in this type extension.', [field]);\n          }\n          newFieldMap[fieldName] = {\n            description: (0, _buildASTSchema.getDescription)(field),\n            type: buildOutputFieldType(field.type),\n            args: buildInputValues(field.arguments),\n            deprecationReason: (0, _buildASTSchema.getDeprecationReason)(field),\n            astNode: field\n          };\n        });\n      });\n    }\n\n    return newFieldMap;\n  }\n\n  function extendFieldType(typeDef) {\n    if (typeDef instanceof _definition.GraphQLList) {\n      return new _definition.GraphQLList(extendFieldType(typeDef.ofType));\n    }\n    if (typeDef instanceof _definition.GraphQLNonNull) {\n      return new _definition.GraphQLNonNull(extendFieldType(typeDef.ofType));\n    }\n    return getTypeFromDef(typeDef);\n  }\n\n  function buildType(typeNode) {\n    switch (typeNode.kind) {\n      case Kind.OBJECT_TYPE_DEFINITION:\n        return buildObjectType(typeNode);\n      case Kind.INTERFACE_TYPE_DEFINITION:\n        return buildInterfaceType(typeNode);\n      case Kind.UNION_TYPE_DEFINITION:\n        return buildUnionType(typeNode);\n      case Kind.SCALAR_TYPE_DEFINITION:\n        return buildScalarType(typeNode);\n      case Kind.ENUM_TYPE_DEFINITION:\n        return buildEnumType(typeNode);\n      case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n        return buildInputObjectType(typeNode);\n    }\n    throw new TypeError('Unknown type kind ' + typeNode.kind);\n  }\n\n  function buildObjectType(typeNode) {\n    return new _definition.GraphQLObjectType({\n      name: typeNode.name.value,\n      description: (0, _buildASTSchema.getDescription)(typeNode),\n      interfaces: function interfaces() {\n        return buildImplementedInterfaces(typeNode);\n      },\n      fields: function fields() {\n        return buildFieldMap(typeNode);\n      },\n      astNode: typeNode\n    });\n  }\n\n  function buildInterfaceType(typeNode) {\n    return new _definition.GraphQLInterfaceType({\n      name: typeNode.name.value,\n      description: (0, _buildASTSchema.getDescription)(typeNode),\n      fields: function fields() {\n        return buildFieldMap(typeNode);\n      },\n      astNode: typeNode,\n      resolveType: cannotExecuteExtendedSchema\n    });\n  }\n\n  function buildUnionType(typeNode) {\n    return new _definition.GraphQLUnionType({\n      name: typeNode.name.value,\n      description: (0, _buildASTSchema.getDescription)(typeNode),\n      types: typeNode.types.map(getObjectTypeFromAST),\n      astNode: typeNode,\n      resolveType: cannotExecuteExtendedSchema\n    });\n  }\n\n  function buildScalarType(typeNode) {\n    return new _definition.GraphQLScalarType({\n      name: typeNode.name.value,\n      description: (0, _buildASTSchema.getDescription)(typeNode),\n      astNode: typeNode,\n      serialize: function serialize(id) {\n        return id;\n      },\n      // Note: validation calls the parse functions to determine if a\n      // literal value is correct. Returning null would cause use of custom\n      // scalars to always fail validation. Returning false causes them to\n      // always pass validation.\n      parseValue: function parseValue() {\n        return false;\n      },\n      parseLiteral: function parseLiteral() {\n        return false;\n      }\n    });\n  }\n\n  function buildEnumType(typeNode) {\n    return new _definition.GraphQLEnumType({\n      name: typeNode.name.value,\n      description: (0, _buildASTSchema.getDescription)(typeNode),\n      values: (0, _keyValMap2.default)(typeNode.values, function (enumValue) {\n        return enumValue.name.value;\n      }, function (enumValue) {\n        return {\n          description: (0, _buildASTSchema.getDescription)(enumValue),\n          deprecationReason: (0, _buildASTSchema.getDeprecationReason)(enumValue),\n          astNode: enumValue\n        };\n      }),\n      astNode: typeNode\n    });\n  }\n\n  function buildInputObjectType(typeNode) {\n    return new _definition.GraphQLInputObjectType({\n      name: typeNode.name.value,\n      description: (0, _buildASTSchema.getDescription)(typeNode),\n      fields: function fields() {\n        return buildInputValues(typeNode.fields);\n      },\n      astNode: typeNode\n    });\n  }\n\n  function getDirective(directiveNode) {\n    return new _directives.GraphQLDirective({\n      name: directiveNode.name.value,\n      description: (0, _buildASTSchema.getDescription)(directiveNode),\n      locations: directiveNode.locations.map(function (node) {\n        return node.value;\n      }),\n      args: directiveNode.arguments && buildInputValues(directiveNode.arguments),\n      astNode: directiveNode\n    });\n  }\n\n  function buildImplementedInterfaces(typeNode) {\n    return typeNode.interfaces && typeNode.interfaces.map(getInterfaceTypeFromAST);\n  }\n\n  function buildFieldMap(typeNode) {\n    return (0, _keyValMap2.default)(typeNode.fields, function (field) {\n      return field.name.value;\n    }, function (field) {\n      return {\n        type: buildOutputFieldType(field.type),\n        description: (0, _buildASTSchema.getDescription)(field),\n        args: buildInputValues(field.arguments),\n        deprecationReason: (0, _buildASTSchema.getDeprecationReason)(field),\n        astNode: field\n      };\n    });\n  }\n\n  function buildInputValues(values) {\n    return (0, _keyValMap2.default)(values, function (value) {\n      return value.name.value;\n    }, function (value) {\n      var type = buildInputFieldType(value.type);\n      return {\n        type: type,\n        description: (0, _buildASTSchema.getDescription)(value),\n        defaultValue: (0, _valueFromAST.valueFromAST)(value.defaultValue, type),\n        astNode: value\n      };\n    });\n  }\n\n  function buildInputFieldType(typeNode) {\n    if (typeNode.kind === Kind.LIST_TYPE) {\n      return new _definition.GraphQLList(buildInputFieldType(typeNode.type));\n    }\n    if (typeNode.kind === Kind.NON_NULL_TYPE) {\n      var nullableType = buildInputFieldType(typeNode.type);\n      !!(nullableType instanceof _definition.GraphQLNonNull) ? (0, _invariant2.default)(0, 'Must be nullable') : void 0;\n      return new _definition.GraphQLNonNull(nullableType);\n    }\n    return getInputTypeFromAST(typeNode);\n  }\n\n  function buildOutputFieldType(typeNode) {\n    if (typeNode.kind === Kind.LIST_TYPE) {\n      return new _definition.GraphQLList(buildOutputFieldType(typeNode.type));\n    }\n    if (typeNode.kind === Kind.NON_NULL_TYPE) {\n      var nullableType = buildOutputFieldType(typeNode.type);\n      !!(nullableType instanceof _definition.GraphQLNonNull) ? (0, _invariant2.default)(0, 'Must be nullable') : void 0;\n      return new _definition.GraphQLNonNull(nullableType);\n    }\n    return getOutputTypeFromAST(typeNode);\n  }\n}\n\nfunction cannotExecuteExtendedSchema() {\n  throw new Error('Extended Schema cannot use Interface or Union types for execution.');\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}