{"ast":null,"code":"import { isTest, warnOnceInDevelopment } from 'apollo-utilities';\nvar haveWarned = false;\n\nvar HeuristicFragmentMatcher = function () {\n  function HeuristicFragmentMatcher() {}\n\n  HeuristicFragmentMatcher.prototype.ensureReady = function () {\n    return Promise.resolve();\n  };\n\n  HeuristicFragmentMatcher.prototype.canBypassInit = function () {\n    return true;\n  };\n\n  HeuristicFragmentMatcher.prototype.match = function (idValue, typeCondition, context) {\n    var obj = context.store.get(idValue.id);\n\n    if (!obj && idValue.id === 'ROOT_QUERY') {\n      return true;\n    }\n\n    if (!obj) {\n      return false;\n    }\n\n    if (!obj.__typename) {\n      if (!haveWarned) {\n        console.warn(\"You're using fragments in your queries, but either don't have the addTypename:\\n  true option set in Apollo Client, or you are trying to write a fragment to the store without the __typename.\\n   Please turn on the addTypename option and include __typename when writing fragments so that Apollo Client\\n   can accurately match fragments.\");\n        console.warn('Could not find __typename on Fragment ', typeCondition, obj);\n        console.warn(\"DEPRECATION WARNING: using fragments without __typename is unsupported behavior \" + \"and will be removed in future versions of Apollo client. You should fix this and set addTypename to true now.\");\n\n        if (!isTest()) {\n          haveWarned = true;\n        }\n      }\n\n      return 'heuristic';\n    }\n\n    if (obj.__typename === typeCondition) {\n      return true;\n    }\n\n    warnOnceInDevelopment('You are using the simple (heuristic) fragment matcher, but your ' + 'queries contain union or interface types. Apollo Client will not be ' + 'able to accurately map fragments. To make this error go away, use ' + 'the `IntrospectionFragmentMatcher` as described in the docs: ' + 'https://www.apollographql.com/docs/react/recipes/fragment-matching.html', 'error');\n    return 'heuristic';\n  };\n\n  return HeuristicFragmentMatcher;\n}();\n\nexport { HeuristicFragmentMatcher };\n\nvar IntrospectionFragmentMatcher = function () {\n  function IntrospectionFragmentMatcher(options) {\n    if (options && options.introspectionQueryResultData) {\n      this.possibleTypesMap = this.parseIntrospectionResult(options.introspectionQueryResultData);\n      this.isReady = true;\n    } else {\n      this.isReady = false;\n    }\n\n    this.match = this.match.bind(this);\n  }\n\n  IntrospectionFragmentMatcher.prototype.match = function (idValue, typeCondition, context) {\n    if (!this.isReady) {\n      throw new Error('FragmentMatcher.match() was called before FragmentMatcher.init()');\n    }\n\n    var obj = context.store.get(idValue.id);\n\n    if (!obj) {\n      return false;\n    }\n\n    if (!obj.__typename) {\n      throw new Error(\"Cannot match fragment because __typename property is missing: \" + JSON.stringify(obj));\n    }\n\n    if (obj.__typename === typeCondition) {\n      return true;\n    }\n\n    var implementingTypes = this.possibleTypesMap[typeCondition];\n\n    if (implementingTypes && implementingTypes.indexOf(obj.__typename) > -1) {\n      return true;\n    }\n\n    return false;\n  };\n\n  IntrospectionFragmentMatcher.prototype.parseIntrospectionResult = function (introspectionResultData) {\n    var typeMap = {};\n\n    introspectionResultData.__schema.types.forEach(function (type) {\n      if (type.kind === 'UNION' || type.kind === 'INTERFACE') {\n        typeMap[type.name] = type.possibleTypes.map(function (implementingType) {\n          return implementingType.name;\n        });\n      }\n    });\n\n    return typeMap;\n  };\n\n  return IntrospectionFragmentMatcher;\n}();\n\nexport { IntrospectionFragmentMatcher };","map":{"version":3,"sources":["../src/fragmentMatcher.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isTest, warnOnceInDevelopment } from 'apollo-utilities';\nvar haveWarned = false;\nvar HeuristicFragmentMatcher = (function () {\n    function HeuristicFragmentMatcher() {\n    }\n    HeuristicFragmentMatcher.prototype.ensureReady = function () {\n        return Promise.resolve();\n    };\n    HeuristicFragmentMatcher.prototype.canBypassInit = function () {\n        return true;\n    };\n    HeuristicFragmentMatcher.prototype.match = function (idValue, typeCondition, context) {\n        var obj = context.store.get(idValue.id);\n        if (!obj && idValue.id === 'ROOT_QUERY') {\n            return true;\n        }\n        if (!obj) {\n            return false;\n        }\n        if (!obj.__typename) {\n            if (!haveWarned) {\n                console.warn(\"You're using fragments in your queries, but either don't have the addTypename:\\n  true option set in Apollo Client, or you are trying to write a fragment to the store without the __typename.\\n   Please turn on the addTypename option and include __typename when writing fragments so that Apollo Client\\n   can accurately match fragments.\");\n                console.warn('Could not find __typename on Fragment ', typeCondition, obj);\n                console.warn(\"DEPRECATION WARNING: using fragments without __typename is unsupported behavior \" +\n                    \"and will be removed in future versions of Apollo client. You should fix this and set addTypename to true now.\");\n                if (!isTest()) {\n                    haveWarned = true;\n                }\n            }\n            return 'heuristic';\n        }\n        if (obj.__typename === typeCondition) {\n            return true;\n        }\n        warnOnceInDevelopment('You are using the simple (heuristic) fragment matcher, but your ' +\n            'queries contain union or interface types. Apollo Client will not be ' +\n            'able to accurately map fragments. To make this error go away, use ' +\n            'the `IntrospectionFragmentMatcher` as described in the docs: ' +\n            'https://www.apollographql.com/docs/react/recipes/fragment-matching.html', 'error');\n        return 'heuristic';\n    };\n    return HeuristicFragmentMatcher;\n}());\nexport { HeuristicFragmentMatcher };\nvar IntrospectionFragmentMatcher = (function () {\n    function IntrospectionFragmentMatcher(options) {\n        if (options && options.introspectionQueryResultData) {\n            this.possibleTypesMap = this.parseIntrospectionResult(options.introspectionQueryResultData);\n            this.isReady = true;\n        }\n        else {\n            this.isReady = false;\n        }\n        this.match = this.match.bind(this);\n    }\n    IntrospectionFragmentMatcher.prototype.match = function (idValue, typeCondition, context) {\n        if (!this.isReady) {\n            throw new Error('FragmentMatcher.match() was called before FragmentMatcher.init()');\n        }\n        var obj = context.store.get(idValue.id);\n        if (!obj) {\n            return false;\n        }\n        if (!obj.__typename) {\n            throw new Error(\"Cannot match fragment because __typename property is missing: \" + JSON.stringify(obj));\n        }\n        if (obj.__typename === typeCondition) {\n            return true;\n        }\n        var implementingTypes = this.possibleTypesMap[typeCondition];\n        if (implementingTypes && implementingTypes.indexOf(obj.__typename) > -1) {\n            return true;\n        }\n        return false;\n    };\n    IntrospectionFragmentMatcher.prototype.parseIntrospectionResult = function (introspectionResultData) {\n        var typeMap = {};\n        introspectionResultData.__schema.types.forEach(function (type) {\n            if (type.kind === 'UNION' || type.kind === 'INTERFACE') {\n                typeMap[type.name] = type.possibleTypes.map(function (implementingType) { return implementingType.name; });\n            }\n        });\n        return typeMap;\n    };\n    return IntrospectionFragmentMatcher;\n}());\nexport { IntrospectionFragmentMatcher };\n//# sourceMappingURL=fragmentMatcher.js.map"]},"metadata":{},"sourceType":"module"}