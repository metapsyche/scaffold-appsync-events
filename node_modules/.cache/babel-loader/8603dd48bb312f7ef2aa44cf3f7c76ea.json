{"ast":null,"code":"import { GraphQLError } from '../../error';\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nimport suggestionList from '../../jsutils/suggestionList';\nimport quotedOrList from '../../jsutils/quotedOrList';\nimport { isObjectType, isInterfaceType, isAbstractType } from '../../type/definition';\nexport function undefinedFieldMessage(fieldName, type, suggestedTypeNames, suggestedFieldNames) {\n  var message = 'Cannot query field \"' + fieldName + '\" on type \"' + type + '\".';\n\n  if (suggestedTypeNames.length !== 0) {\n    var suggestions = quotedOrList(suggestedTypeNames);\n    message += ' Did you mean to use an inline fragment on ' + suggestions + '?';\n  } else if (suggestedFieldNames.length !== 0) {\n    message += ' Did you mean ' + quotedOrList(suggestedFieldNames) + '?';\n  }\n\n  return message;\n}\n/**\n * Fields on correct type\n *\n * A GraphQL document is only valid if all fields selected are defined by the\n * parent type, or are an allowed meta field such as __typename.\n */\n\nexport function FieldsOnCorrectType(context) {\n  return {\n    Field: function Field(node) {\n      var type = context.getParentType();\n\n      if (type) {\n        var fieldDef = context.getFieldDef();\n\n        if (!fieldDef) {\n          // This field doesn't exist, lets look for suggestions.\n          var schema = context.getSchema();\n          var fieldName = node.name.value; // First determine if there are any suggested types to condition on.\n\n          var suggestedTypeNames = getSuggestedTypeNames(schema, type, fieldName); // If there are no suggested types, then perhaps this was a typo?\n\n          var suggestedFieldNames = suggestedTypeNames.length !== 0 ? [] : getSuggestedFieldNames(schema, type, fieldName); // Report an error, including helpful suggestions.\n\n          context.reportError(new GraphQLError(undefinedFieldMessage(fieldName, type.name, suggestedTypeNames, suggestedFieldNames), [node]));\n        }\n      }\n    }\n  };\n}\n/**\n * Go through all of the implementations of type, as well as the interfaces\n * that they implement. If any of those types include the provided field,\n * suggest them, sorted by how often the type is referenced,  starting\n * with Interfaces.\n */\n\nfunction getSuggestedTypeNames(schema, type, fieldName) {\n  if (isAbstractType(type)) {\n    var suggestedObjectTypes = [];\n    var interfaceUsageCount = Object.create(null);\n    schema.getPossibleTypes(type).forEach(function (possibleType) {\n      if (!possibleType.getFields()[fieldName]) {\n        return;\n      } // This object type defines this field.\n\n\n      suggestedObjectTypes.push(possibleType.name);\n      possibleType.getInterfaces().forEach(function (possibleInterface) {\n        if (!possibleInterface.getFields()[fieldName]) {\n          return;\n        } // This interface type defines this field.\n\n\n        interfaceUsageCount[possibleInterface.name] = (interfaceUsageCount[possibleInterface.name] || 0) + 1;\n      });\n    }); // Suggest interface types based on how common they are.\n\n    var suggestedInterfaceTypes = Object.keys(interfaceUsageCount).sort(function (a, b) {\n      return interfaceUsageCount[b] - interfaceUsageCount[a];\n    }); // Suggest both interface and object types.\n\n    return suggestedInterfaceTypes.concat(suggestedObjectTypes);\n  } // Otherwise, must be an Object type, which does not have possible fields.\n\n\n  return [];\n}\n/**\n * For the field name provided, determine if there are any similar field names\n * that may be the result of a typo.\n */\n\n\nfunction getSuggestedFieldNames(schema, type, fieldName) {\n  if (isObjectType(type) || isInterfaceType(type)) {\n    var possibleFieldNames = Object.keys(type.getFields());\n    return suggestionList(fieldName, possibleFieldNames);\n  } // Otherwise, must be a Union type, which does not define fields.\n\n\n  return [];\n}","map":{"version":3,"names":["GraphQLError","suggestionList","quotedOrList","isObjectType","isInterfaceType","isAbstractType","undefinedFieldMessage","fieldName","type","suggestedTypeNames","suggestedFieldNames","message","length","suggestions","FieldsOnCorrectType","context","Field","node","getParentType","fieldDef","getFieldDef","schema","getSchema","name","value","getSuggestedTypeNames","getSuggestedFieldNames","reportError","suggestedObjectTypes","interfaceUsageCount","Object","create","getPossibleTypes","forEach","possibleType","getFields","push","getInterfaces","possibleInterface","suggestedInterfaceTypes","keys","sort","a","b","concat","possibleFieldNames"],"sources":["/Users/roaldmaravillas/ro/sandbox/aws-mobile-appsync-events-starter-react/node_modules/aws-appsync/node_modules/graphql/module/validation/rules/FieldsOnCorrectType.js"],"sourcesContent":["\nimport { GraphQLError } from '../../error'; /**\n                                             * Copyright (c) 2015-present, Facebook, Inc.\n                                             *\n                                             * This source code is licensed under the MIT license found in the\n                                             * LICENSE file in the root directory of this source tree.\n                                             *\n                                             * \n                                             */\n\nimport suggestionList from '../../jsutils/suggestionList';\nimport quotedOrList from '../../jsutils/quotedOrList';\n\nimport { isObjectType, isInterfaceType, isAbstractType } from '../../type/definition';\n\nexport function undefinedFieldMessage(fieldName, type, suggestedTypeNames, suggestedFieldNames) {\n  var message = 'Cannot query field \"' + fieldName + '\" on type \"' + type + '\".';\n  if (suggestedTypeNames.length !== 0) {\n    var suggestions = quotedOrList(suggestedTypeNames);\n    message += ' Did you mean to use an inline fragment on ' + suggestions + '?';\n  } else if (suggestedFieldNames.length !== 0) {\n    message += ' Did you mean ' + quotedOrList(suggestedFieldNames) + '?';\n  }\n  return message;\n}\n\n/**\n * Fields on correct type\n *\n * A GraphQL document is only valid if all fields selected are defined by the\n * parent type, or are an allowed meta field such as __typename.\n */\nexport function FieldsOnCorrectType(context) {\n  return {\n    Field: function Field(node) {\n      var type = context.getParentType();\n      if (type) {\n        var fieldDef = context.getFieldDef();\n        if (!fieldDef) {\n          // This field doesn't exist, lets look for suggestions.\n          var schema = context.getSchema();\n          var fieldName = node.name.value;\n          // First determine if there are any suggested types to condition on.\n          var suggestedTypeNames = getSuggestedTypeNames(schema, type, fieldName);\n          // If there are no suggested types, then perhaps this was a typo?\n          var suggestedFieldNames = suggestedTypeNames.length !== 0 ? [] : getSuggestedFieldNames(schema, type, fieldName);\n\n          // Report an error, including helpful suggestions.\n          context.reportError(new GraphQLError(undefinedFieldMessage(fieldName, type.name, suggestedTypeNames, suggestedFieldNames), [node]));\n        }\n      }\n    }\n  };\n}\n\n/**\n * Go through all of the implementations of type, as well as the interfaces\n * that they implement. If any of those types include the provided field,\n * suggest them, sorted by how often the type is referenced,  starting\n * with Interfaces.\n */\nfunction getSuggestedTypeNames(schema, type, fieldName) {\n  if (isAbstractType(type)) {\n    var suggestedObjectTypes = [];\n    var interfaceUsageCount = Object.create(null);\n    schema.getPossibleTypes(type).forEach(function (possibleType) {\n      if (!possibleType.getFields()[fieldName]) {\n        return;\n      }\n      // This object type defines this field.\n      suggestedObjectTypes.push(possibleType.name);\n      possibleType.getInterfaces().forEach(function (possibleInterface) {\n        if (!possibleInterface.getFields()[fieldName]) {\n          return;\n        }\n        // This interface type defines this field.\n        interfaceUsageCount[possibleInterface.name] = (interfaceUsageCount[possibleInterface.name] || 0) + 1;\n      });\n    });\n\n    // Suggest interface types based on how common they are.\n    var suggestedInterfaceTypes = Object.keys(interfaceUsageCount).sort(function (a, b) {\n      return interfaceUsageCount[b] - interfaceUsageCount[a];\n    });\n\n    // Suggest both interface and object types.\n    return suggestedInterfaceTypes.concat(suggestedObjectTypes);\n  }\n\n  // Otherwise, must be an Object type, which does not have possible fields.\n  return [];\n}\n\n/**\n * For the field name provided, determine if there are any similar field names\n * that may be the result of a typo.\n */\nfunction getSuggestedFieldNames(schema, type, fieldName) {\n  if (isObjectType(type) || isInterfaceType(type)) {\n    var possibleFieldNames = Object.keys(type.getFields());\n    return suggestionList(fieldName, possibleFieldNames);\n  }\n  // Otherwise, must be a Union type, which does not define fields.\n  return [];\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}