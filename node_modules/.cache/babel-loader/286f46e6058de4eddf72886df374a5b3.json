{"ast":null,"code":"/**\n * Copyright (c) 2016-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { isScalarType, isObjectType, isInterfaceType, isUnionType, isEnumType, isInputObjectType, isNonNullType, isListType, isNamedType } from '../type/definition';\nimport { GraphQLDirective } from '../type/directives';\nimport { GraphQLSchema } from '../type/schema';\nimport keyMap from '../jsutils/keyMap';\nexport var BreakingChangeType = {\n  FIELD_CHANGED_KIND: 'FIELD_CHANGED_KIND',\n  FIELD_REMOVED: 'FIELD_REMOVED',\n  TYPE_CHANGED_KIND: 'TYPE_CHANGED_KIND',\n  TYPE_REMOVED: 'TYPE_REMOVED',\n  TYPE_REMOVED_FROM_UNION: 'TYPE_REMOVED_FROM_UNION',\n  VALUE_REMOVED_FROM_ENUM: 'VALUE_REMOVED_FROM_ENUM',\n  ARG_REMOVED: 'ARG_REMOVED',\n  ARG_CHANGED_KIND: 'ARG_CHANGED_KIND',\n  NON_NULL_ARG_ADDED: 'NON_NULL_ARG_ADDED',\n  NON_NULL_INPUT_FIELD_ADDED: 'NON_NULL_INPUT_FIELD_ADDED',\n  INTERFACE_REMOVED_FROM_OBJECT: 'INTERFACE_REMOVED_FROM_OBJECT',\n  DIRECTIVE_REMOVED: 'DIRECTIVE_REMOVED',\n  DIRECTIVE_ARG_REMOVED: 'DIRECTIVE_ARG_REMOVED',\n  DIRECTIVE_LOCATION_REMOVED: 'DIRECTIVE_LOCATION_REMOVED',\n  NON_NULL_DIRECTIVE_ARG_ADDED: 'NON_NULL_DIRECTIVE_ARG_ADDED'\n};\nexport var DangerousChangeType = {\n  ARG_DEFAULT_VALUE_CHANGE: 'ARG_DEFAULT_VALUE_CHANGE',\n  VALUE_ADDED_TO_ENUM: 'VALUE_ADDED_TO_ENUM',\n  INTERFACE_ADDED_TO_OBJECT: 'INTERFACE_ADDED_TO_OBJECT',\n  TYPE_ADDED_TO_UNION: 'TYPE_ADDED_TO_UNION',\n  NULLABLE_INPUT_FIELD_ADDED: 'NULLABLE_INPUT_FIELD_ADDED',\n  NULLABLE_ARG_ADDED: 'NULLABLE_ARG_ADDED'\n};\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of breaking changes covered by the other functions down below.\n */\n\nexport function findBreakingChanges(oldSchema, newSchema) {\n  return [].concat(findRemovedTypes(oldSchema, newSchema), findTypesThatChangedKind(oldSchema, newSchema), findFieldsThatChangedTypeOnObjectOrInterfaceTypes(oldSchema, newSchema), findFieldsThatChangedTypeOnInputObjectTypes(oldSchema, newSchema).breakingChanges, findTypesRemovedFromUnions(oldSchema, newSchema), findValuesRemovedFromEnums(oldSchema, newSchema), findArgChanges(oldSchema, newSchema).breakingChanges, findInterfacesRemovedFromObjectTypes(oldSchema, newSchema), findRemovedDirectives(oldSchema, newSchema), findRemovedDirectiveArgs(oldSchema, newSchema), findAddedNonNullDirectiveArgs(oldSchema, newSchema), findRemovedDirectiveLocations(oldSchema, newSchema));\n}\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of potentially dangerous changes covered by the other functions down below.\n */\n\nexport function findDangerousChanges(oldSchema, newSchema) {\n  return [].concat(findArgChanges(oldSchema, newSchema).dangerousChanges, findValuesAddedToEnums(oldSchema, newSchema), findInterfacesAddedToObjectTypes(oldSchema, newSchema), findTypesAddedToUnions(oldSchema, newSchema), findFieldsThatChangedTypeOnInputObjectTypes(oldSchema, newSchema).dangerousChanges);\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any breaking\n * changes in the newSchema related to removing an entire type.\n */\n\nexport function findRemovedTypes(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var breakingChanges = [];\n  Object.keys(oldTypeMap).forEach(function (typeName) {\n    if (!newTypeMap[typeName]) {\n      breakingChanges.push({\n        type: BreakingChangeType.TYPE_REMOVED,\n        description: typeName + ' was removed.'\n      });\n    }\n  });\n  return breakingChanges;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any breaking\n * changes in the newSchema related to changing the type of a type.\n */\n\nexport function findTypesThatChangedKind(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var breakingChanges = [];\n  Object.keys(oldTypeMap).forEach(function (typeName) {\n    if (!newTypeMap[typeName]) {\n      return;\n    }\n\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (oldType.constructor !== newType.constructor) {\n      breakingChanges.push({\n        type: BreakingChangeType.TYPE_CHANGED_KIND,\n        description: typeName + ' changed from ' + (typeKindName(oldType) + ' to ' + typeKindName(newType) + '.')\n      });\n    }\n  });\n  return breakingChanges;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any\n * breaking or dangerous changes in the newSchema related to arguments\n * (such as removal or change of type of an argument, or a change in an\n * argument's default value).\n */\n\nexport function findArgChanges(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var breakingChanges = [];\n  var dangerousChanges = [];\n  Object.keys(oldTypeMap).forEach(function (typeName) {\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!(isObjectType(oldType) || isInterfaceType(oldType)) || !(isObjectType(newType) || isInterfaceType(newType)) || newType.constructor !== oldType.constructor) {\n      return;\n    }\n\n    var oldTypeFields = oldType.getFields();\n    var newTypeFields = newType.getFields();\n    Object.keys(oldTypeFields).forEach(function (fieldName) {\n      if (!newTypeFields[fieldName]) {\n        return;\n      }\n\n      oldTypeFields[fieldName].args.forEach(function (oldArgDef) {\n        var newArgs = newTypeFields[fieldName].args;\n        var newArgDef = newArgs.find(function (arg) {\n          return arg.name === oldArgDef.name;\n        }); // Arg not present\n\n        if (!newArgDef) {\n          breakingChanges.push({\n            type: BreakingChangeType.ARG_REMOVED,\n            description: oldType.name + '.' + fieldName + ' arg ' + (oldArgDef.name + ' was removed')\n          });\n        } else {\n          var isSafe = isChangeSafeForInputObjectFieldOrFieldArg(oldArgDef.type, newArgDef.type);\n\n          if (!isSafe) {\n            breakingChanges.push({\n              type: BreakingChangeType.ARG_CHANGED_KIND,\n              description: oldType.name + '.' + fieldName + ' arg ' + (oldArgDef.name + ' has changed type from ') + (oldArgDef.type.toString() + ' to ' + newArgDef.type.toString())\n            });\n          } else if (oldArgDef.defaultValue !== undefined && oldArgDef.defaultValue !== newArgDef.defaultValue) {\n            dangerousChanges.push({\n              type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,\n              description: oldType.name + '.' + fieldName + ' arg ' + (oldArgDef.name + ' has changed defaultValue')\n            });\n          }\n        }\n      }); // Check if a non-null arg was added to the field\n\n      newTypeFields[fieldName].args.forEach(function (newArgDef) {\n        var oldArgs = oldTypeFields[fieldName].args;\n        var oldArgDef = oldArgs.find(function (arg) {\n          return arg.name === newArgDef.name;\n        });\n\n        if (!oldArgDef) {\n          if (isNonNullType(newArgDef.type)) {\n            breakingChanges.push({\n              type: BreakingChangeType.NON_NULL_ARG_ADDED,\n              description: 'A non-null arg ' + newArgDef.name + ' on ' + (newType.name + '.' + fieldName + ' was added')\n            });\n          } else {\n            dangerousChanges.push({\n              type: DangerousChangeType.NULLABLE_ARG_ADDED,\n              description: 'A nullable arg ' + newArgDef.name + ' on ' + (newType.name + '.' + fieldName + ' was added')\n            });\n          }\n        }\n      });\n    });\n  });\n  return {\n    breakingChanges: breakingChanges,\n    dangerousChanges: dangerousChanges\n  };\n}\n\nfunction typeKindName(type) {\n  if (isScalarType(type)) {\n    return 'a Scalar type';\n  }\n\n  if (isObjectType(type)) {\n    return 'an Object type';\n  }\n\n  if (isInterfaceType(type)) {\n    return 'an Interface type';\n  }\n\n  if (isUnionType(type)) {\n    return 'a Union type';\n  }\n\n  if (isEnumType(type)) {\n    return 'an Enum type';\n  }\n\n  if (isInputObjectType(type)) {\n    return 'an Input type';\n  }\n\n  throw new TypeError('Unknown type ' + type.constructor.name);\n}\n\nexport function findFieldsThatChangedTypeOnObjectOrInterfaceTypes(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var breakingChanges = [];\n  Object.keys(oldTypeMap).forEach(function (typeName) {\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!(isObjectType(oldType) || isInterfaceType(oldType)) || !(isObjectType(newType) || isInterfaceType(newType)) || newType.constructor !== oldType.constructor) {\n      return;\n    }\n\n    var oldTypeFieldsDef = oldType.getFields();\n    var newTypeFieldsDef = newType.getFields();\n    Object.keys(oldTypeFieldsDef).forEach(function (fieldName) {\n      // Check if the field is missing on the type in the new schema.\n      if (!(fieldName in newTypeFieldsDef)) {\n        breakingChanges.push({\n          type: BreakingChangeType.FIELD_REMOVED,\n          description: typeName + '.' + fieldName + ' was removed.'\n        });\n      } else {\n        var oldFieldType = oldTypeFieldsDef[fieldName].type;\n        var newFieldType = newTypeFieldsDef[fieldName].type;\n        var isSafe = isChangeSafeForObjectOrInterfaceField(oldFieldType, newFieldType);\n\n        if (!isSafe) {\n          var oldFieldTypeString = isNamedType(oldFieldType) ? oldFieldType.name : oldFieldType.toString();\n          var newFieldTypeString = isNamedType(newFieldType) ? newFieldType.name : newFieldType.toString();\n          breakingChanges.push({\n            type: BreakingChangeType.FIELD_CHANGED_KIND,\n            description: typeName + '.' + fieldName + ' changed type from ' + (oldFieldTypeString + ' to ' + newFieldTypeString + '.')\n          });\n        }\n      }\n    });\n  });\n  return breakingChanges;\n}\nexport function findFieldsThatChangedTypeOnInputObjectTypes(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var breakingChanges = [];\n  var dangerousChanges = [];\n  Object.keys(oldTypeMap).forEach(function (typeName) {\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!isInputObjectType(oldType) || !isInputObjectType(newType)) {\n      return;\n    }\n\n    var oldTypeFieldsDef = oldType.getFields();\n    var newTypeFieldsDef = newType.getFields();\n    Object.keys(oldTypeFieldsDef).forEach(function (fieldName) {\n      // Check if the field is missing on the type in the new schema.\n      if (!(fieldName in newTypeFieldsDef)) {\n        breakingChanges.push({\n          type: BreakingChangeType.FIELD_REMOVED,\n          description: typeName + '.' + fieldName + ' was removed.'\n        });\n      } else {\n        var oldFieldType = oldTypeFieldsDef[fieldName].type;\n        var newFieldType = newTypeFieldsDef[fieldName].type;\n        var isSafe = isChangeSafeForInputObjectFieldOrFieldArg(oldFieldType, newFieldType);\n\n        if (!isSafe) {\n          var oldFieldTypeString = isNamedType(oldFieldType) ? oldFieldType.name : oldFieldType.toString();\n          var newFieldTypeString = isNamedType(newFieldType) ? newFieldType.name : newFieldType.toString();\n          breakingChanges.push({\n            type: BreakingChangeType.FIELD_CHANGED_KIND,\n            description: typeName + '.' + fieldName + ' changed type from ' + (oldFieldTypeString + ' to ' + newFieldTypeString + '.')\n          });\n        }\n      }\n    }); // Check if a field was added to the input object type\n\n    Object.keys(newTypeFieldsDef).forEach(function (fieldName) {\n      if (!(fieldName in oldTypeFieldsDef)) {\n        if (isNonNullType(newTypeFieldsDef[fieldName].type)) {\n          breakingChanges.push({\n            type: BreakingChangeType.NON_NULL_INPUT_FIELD_ADDED,\n            description: 'A non-null field ' + fieldName + ' on ' + ('input type ' + newType.name + ' was added.')\n          });\n        } else {\n          dangerousChanges.push({\n            type: DangerousChangeType.NULLABLE_INPUT_FIELD_ADDED,\n            description: 'A nullable field ' + fieldName + ' on ' + ('input type ' + newType.name + ' was added.')\n          });\n        }\n      }\n    });\n  });\n  return {\n    breakingChanges: breakingChanges,\n    dangerousChanges: dangerousChanges\n  };\n}\n\nfunction isChangeSafeForObjectOrInterfaceField(oldType, newType) {\n  if (isNamedType(oldType)) {\n    return (// if they're both named types, see if their names are equivalent\n      isNamedType(newType) && oldType.name === newType.name || // moving from nullable to non-null of the same underlying type is safe\n      isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)\n    );\n  } else if (isListType(oldType)) {\n    return (// if they're both lists, make sure the underlying types are compatible\n      isListType(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType) || // moving from nullable to non-null of the same underlying type is safe\n      isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)\n    );\n  } else if (isNonNullType(oldType)) {\n    // if they're both non-null, make sure the underlying types are compatible\n    return isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType);\n  }\n\n  return false;\n}\n\nfunction isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {\n  if (isNamedType(oldType)) {\n    // if they're both named types, see if their names are equivalent\n    return isNamedType(newType) && oldType.name === newType.name;\n  } else if (isListType(oldType)) {\n    // if they're both lists, make sure the underlying types are compatible\n    return isListType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType);\n  } else if (isNonNullType(oldType)) {\n    return (// if they're both non-null, make sure the underlying types are\n      // compatible\n      isNonNullType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType) || // moving from non-null to nullable of the same underlying type is safe\n      !isNonNullType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType)\n    );\n  }\n\n  return false;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any breaking\n * changes in the newSchema related to removing types from a union type.\n */\n\n\nexport function findTypesRemovedFromUnions(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var typesRemovedFromUnion = [];\n  Object.keys(oldTypeMap).forEach(function (typeName) {\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!isUnionType(oldType) || !isUnionType(newType)) {\n      return;\n    }\n\n    var typeNamesInNewUnion = Object.create(null);\n    newType.getTypes().forEach(function (type) {\n      typeNamesInNewUnion[type.name] = true;\n    });\n    oldType.getTypes().forEach(function (type) {\n      if (!typeNamesInNewUnion[type.name]) {\n        typesRemovedFromUnion.push({\n          type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,\n          description: type.name + ' was removed from union type ' + typeName + '.'\n        });\n      }\n    });\n  });\n  return typesRemovedFromUnion;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any dangerous\n * changes in the newSchema related to adding types to a union type.\n */\n\nexport function findTypesAddedToUnions(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var typesAddedToUnion = [];\n  Object.keys(newTypeMap).forEach(function (typeName) {\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!isUnionType(oldType) || !isUnionType(newType)) {\n      return;\n    }\n\n    var typeNamesInOldUnion = Object.create(null);\n    oldType.getTypes().forEach(function (type) {\n      typeNamesInOldUnion[type.name] = true;\n    });\n    newType.getTypes().forEach(function (type) {\n      if (!typeNamesInOldUnion[type.name]) {\n        typesAddedToUnion.push({\n          type: DangerousChangeType.TYPE_ADDED_TO_UNION,\n          description: type.name + ' was added to union type ' + typeName + '.'\n        });\n      }\n    });\n  });\n  return typesAddedToUnion;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any breaking\n * changes in the newSchema related to removing values from an enum type.\n */\n\nexport function findValuesRemovedFromEnums(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var valuesRemovedFromEnums = [];\n  Object.keys(oldTypeMap).forEach(function (typeName) {\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!isEnumType(oldType) || !isEnumType(newType)) {\n      return;\n    }\n\n    var valuesInNewEnum = Object.create(null);\n    newType.getValues().forEach(function (value) {\n      valuesInNewEnum[value.name] = true;\n    });\n    oldType.getValues().forEach(function (value) {\n      if (!valuesInNewEnum[value.name]) {\n        valuesRemovedFromEnums.push({\n          type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,\n          description: value.name + ' was removed from enum type ' + typeName + '.'\n        });\n      }\n    });\n  });\n  return valuesRemovedFromEnums;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any dangerous\n * changes in the newSchema related to adding values to an enum type.\n */\n\nexport function findValuesAddedToEnums(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var valuesAddedToEnums = [];\n  Object.keys(oldTypeMap).forEach(function (typeName) {\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!isEnumType(oldType) || !isEnumType(newType)) {\n      return;\n    }\n\n    var valuesInOldEnum = Object.create(null);\n    oldType.getValues().forEach(function (value) {\n      valuesInOldEnum[value.name] = true;\n    });\n    newType.getValues().forEach(function (value) {\n      if (!valuesInOldEnum[value.name]) {\n        valuesAddedToEnums.push({\n          type: DangerousChangeType.VALUE_ADDED_TO_ENUM,\n          description: value.name + ' was added to enum type ' + typeName + '.'\n        });\n      }\n    });\n  });\n  return valuesAddedToEnums;\n}\nexport function findInterfacesRemovedFromObjectTypes(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var breakingChanges = [];\n  Object.keys(oldTypeMap).forEach(function (typeName) {\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!isObjectType(oldType) || !isObjectType(newType)) {\n      return;\n    }\n\n    var oldInterfaces = oldType.getInterfaces();\n    var newInterfaces = newType.getInterfaces();\n    oldInterfaces.forEach(function (oldInterface) {\n      if (!newInterfaces.some(function (int) {\n        return int.name === oldInterface.name;\n      })) {\n        breakingChanges.push({\n          type: BreakingChangeType.INTERFACE_REMOVED_FROM_OBJECT,\n          description: typeName + ' no longer implements interface ' + (oldInterface.name + '.')\n        });\n      }\n    });\n  });\n  return breakingChanges;\n}\nexport function findInterfacesAddedToObjectTypes(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var interfacesAddedToObjectTypes = [];\n  Object.keys(newTypeMap).forEach(function (typeName) {\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!isObjectType(oldType) || !isObjectType(newType)) {\n      return;\n    }\n\n    var oldInterfaces = oldType.getInterfaces();\n    var newInterfaces = newType.getInterfaces();\n    newInterfaces.forEach(function (newInterface) {\n      if (!oldInterfaces.some(function (int) {\n        return int.name === newInterface.name;\n      })) {\n        interfacesAddedToObjectTypes.push({\n          type: DangerousChangeType.INTERFACE_ADDED_TO_OBJECT,\n          description: newInterface.name + ' added to interfaces implemented ' + ('by ' + typeName + '.')\n        });\n      }\n    });\n  });\n  return interfacesAddedToObjectTypes;\n}\nexport function findRemovedDirectives(oldSchema, newSchema) {\n  var removedDirectives = [];\n  var newSchemaDirectiveMap = getDirectiveMapForSchema(newSchema);\n  oldSchema.getDirectives().forEach(function (directive) {\n    if (!newSchemaDirectiveMap[directive.name]) {\n      removedDirectives.push({\n        type: BreakingChangeType.DIRECTIVE_REMOVED,\n        description: directive.name + ' was removed'\n      });\n    }\n  });\n  return removedDirectives;\n}\n\nfunction findRemovedArgsForDirective(oldDirective, newDirective) {\n  var removedArgs = [];\n  var newArgMap = getArgumentMapForDirective(newDirective);\n  oldDirective.args.forEach(function (arg) {\n    if (!newArgMap[arg.name]) {\n      removedArgs.push(arg);\n    }\n  });\n  return removedArgs;\n}\n\nexport function findRemovedDirectiveArgs(oldSchema, newSchema) {\n  var removedDirectiveArgs = [];\n  var oldSchemaDirectiveMap = getDirectiveMapForSchema(oldSchema);\n  newSchema.getDirectives().forEach(function (newDirective) {\n    var oldDirective = oldSchemaDirectiveMap[newDirective.name];\n\n    if (!oldDirective) {\n      return;\n    }\n\n    findRemovedArgsForDirective(oldDirective, newDirective).forEach(function (arg) {\n      removedDirectiveArgs.push({\n        type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,\n        description: arg.name + ' was removed from ' + newDirective.name\n      });\n    });\n  });\n  return removedDirectiveArgs;\n}\n\nfunction findAddedArgsForDirective(oldDirective, newDirective) {\n  var addedArgs = [];\n  var oldArgMap = getArgumentMapForDirective(oldDirective);\n  newDirective.args.forEach(function (arg) {\n    if (!oldArgMap[arg.name]) {\n      addedArgs.push(arg);\n    }\n  });\n  return addedArgs;\n}\n\nexport function findAddedNonNullDirectiveArgs(oldSchema, newSchema) {\n  var addedNonNullableArgs = [];\n  var oldSchemaDirectiveMap = getDirectiveMapForSchema(oldSchema);\n  newSchema.getDirectives().forEach(function (newDirective) {\n    var oldDirective = oldSchemaDirectiveMap[newDirective.name];\n\n    if (!oldDirective) {\n      return;\n    }\n\n    findAddedArgsForDirective(oldDirective, newDirective).forEach(function (arg) {\n      if (!isNonNullType(arg.type)) {\n        return;\n      }\n\n      addedNonNullableArgs.push({\n        type: BreakingChangeType.NON_NULL_DIRECTIVE_ARG_ADDED,\n        description: 'A non-null arg ' + arg.name + ' on directive ' + (newDirective.name + ' was added')\n      });\n    });\n  });\n  return addedNonNullableArgs;\n}\nexport function findRemovedLocationsForDirective(oldDirective, newDirective) {\n  var removedLocations = [];\n  var newLocationSet = new Set(newDirective.locations);\n  oldDirective.locations.forEach(function (oldLocation) {\n    if (!newLocationSet.has(oldLocation)) {\n      removedLocations.push(oldLocation);\n    }\n  });\n  return removedLocations;\n}\nexport function findRemovedDirectiveLocations(oldSchema, newSchema) {\n  var removedLocations = [];\n  var oldSchemaDirectiveMap = getDirectiveMapForSchema(oldSchema);\n  newSchema.getDirectives().forEach(function (newDirective) {\n    var oldDirective = oldSchemaDirectiveMap[newDirective.name];\n\n    if (!oldDirective) {\n      return;\n    }\n\n    findRemovedLocationsForDirective(oldDirective, newDirective).forEach(function (location) {\n      removedLocations.push({\n        type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,\n        description: location + ' was removed from ' + newDirective.name\n      });\n    });\n  });\n  return removedLocations;\n}\n\nfunction getDirectiveMapForSchema(schema) {\n  return keyMap(schema.getDirectives(), function (dir) {\n    return dir.name;\n  });\n}\n\nfunction getArgumentMapForDirective(directive) {\n  return keyMap(directive.args, function (arg) {\n    return arg.name;\n  });\n}","map":{"version":3,"names":["isScalarType","isObjectType","isInterfaceType","isUnionType","isEnumType","isInputObjectType","isNonNullType","isListType","isNamedType","GraphQLDirective","GraphQLSchema","keyMap","BreakingChangeType","FIELD_CHANGED_KIND","FIELD_REMOVED","TYPE_CHANGED_KIND","TYPE_REMOVED","TYPE_REMOVED_FROM_UNION","VALUE_REMOVED_FROM_ENUM","ARG_REMOVED","ARG_CHANGED_KIND","NON_NULL_ARG_ADDED","NON_NULL_INPUT_FIELD_ADDED","INTERFACE_REMOVED_FROM_OBJECT","DIRECTIVE_REMOVED","DIRECTIVE_ARG_REMOVED","DIRECTIVE_LOCATION_REMOVED","NON_NULL_DIRECTIVE_ARG_ADDED","DangerousChangeType","ARG_DEFAULT_VALUE_CHANGE","VALUE_ADDED_TO_ENUM","INTERFACE_ADDED_TO_OBJECT","TYPE_ADDED_TO_UNION","NULLABLE_INPUT_FIELD_ADDED","NULLABLE_ARG_ADDED","findBreakingChanges","oldSchema","newSchema","concat","findRemovedTypes","findTypesThatChangedKind","findFieldsThatChangedTypeOnObjectOrInterfaceTypes","findFieldsThatChangedTypeOnInputObjectTypes","breakingChanges","findTypesRemovedFromUnions","findValuesRemovedFromEnums","findArgChanges","findInterfacesRemovedFromObjectTypes","findRemovedDirectives","findRemovedDirectiveArgs","findAddedNonNullDirectiveArgs","findRemovedDirectiveLocations","findDangerousChanges","dangerousChanges","findValuesAddedToEnums","findInterfacesAddedToObjectTypes","findTypesAddedToUnions","oldTypeMap","getTypeMap","newTypeMap","Object","keys","forEach","typeName","push","type","description","oldType","newType","constructor","typeKindName","oldTypeFields","getFields","newTypeFields","fieldName","args","oldArgDef","newArgs","newArgDef","find","arg","name","isSafe","isChangeSafeForInputObjectFieldOrFieldArg","toString","defaultValue","undefined","oldArgs","TypeError","oldTypeFieldsDef","newTypeFieldsDef","oldFieldType","newFieldType","isChangeSafeForObjectOrInterfaceField","oldFieldTypeString","newFieldTypeString","ofType","typesRemovedFromUnion","typeNamesInNewUnion","create","getTypes","typesAddedToUnion","typeNamesInOldUnion","valuesRemovedFromEnums","valuesInNewEnum","getValues","value","valuesAddedToEnums","valuesInOldEnum","oldInterfaces","getInterfaces","newInterfaces","oldInterface","some","int","interfacesAddedToObjectTypes","newInterface","removedDirectives","newSchemaDirectiveMap","getDirectiveMapForSchema","getDirectives","directive","findRemovedArgsForDirective","oldDirective","newDirective","removedArgs","newArgMap","getArgumentMapForDirective","removedDirectiveArgs","oldSchemaDirectiveMap","findAddedArgsForDirective","addedArgs","oldArgMap","addedNonNullableArgs","findRemovedLocationsForDirective","removedLocations","newLocationSet","Set","locations","oldLocation","has","location","schema","dir"],"sources":["/Users/roaldmaravillas/ro/sandbox/aws-mobile-appsync-events-starter-react/node_modules/aws-appsync/node_modules/graphql/module/utilities/findBreakingChanges.js"],"sourcesContent":["/**\n * Copyright (c) 2016-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nimport { isScalarType, isObjectType, isInterfaceType, isUnionType, isEnumType, isInputObjectType, isNonNullType, isListType, isNamedType } from '../type/definition';\n\nimport { GraphQLDirective } from '../type/directives';\nimport { GraphQLSchema } from '../type/schema';\nimport keyMap from '../jsutils/keyMap';\n\nexport var BreakingChangeType = {\n  FIELD_CHANGED_KIND: 'FIELD_CHANGED_KIND',\n  FIELD_REMOVED: 'FIELD_REMOVED',\n  TYPE_CHANGED_KIND: 'TYPE_CHANGED_KIND',\n  TYPE_REMOVED: 'TYPE_REMOVED',\n  TYPE_REMOVED_FROM_UNION: 'TYPE_REMOVED_FROM_UNION',\n  VALUE_REMOVED_FROM_ENUM: 'VALUE_REMOVED_FROM_ENUM',\n  ARG_REMOVED: 'ARG_REMOVED',\n  ARG_CHANGED_KIND: 'ARG_CHANGED_KIND',\n  NON_NULL_ARG_ADDED: 'NON_NULL_ARG_ADDED',\n  NON_NULL_INPUT_FIELD_ADDED: 'NON_NULL_INPUT_FIELD_ADDED',\n  INTERFACE_REMOVED_FROM_OBJECT: 'INTERFACE_REMOVED_FROM_OBJECT',\n  DIRECTIVE_REMOVED: 'DIRECTIVE_REMOVED',\n  DIRECTIVE_ARG_REMOVED: 'DIRECTIVE_ARG_REMOVED',\n  DIRECTIVE_LOCATION_REMOVED: 'DIRECTIVE_LOCATION_REMOVED',\n  NON_NULL_DIRECTIVE_ARG_ADDED: 'NON_NULL_DIRECTIVE_ARG_ADDED'\n};\n\nexport var DangerousChangeType = {\n  ARG_DEFAULT_VALUE_CHANGE: 'ARG_DEFAULT_VALUE_CHANGE',\n  VALUE_ADDED_TO_ENUM: 'VALUE_ADDED_TO_ENUM',\n  INTERFACE_ADDED_TO_OBJECT: 'INTERFACE_ADDED_TO_OBJECT',\n  TYPE_ADDED_TO_UNION: 'TYPE_ADDED_TO_UNION',\n  NULLABLE_INPUT_FIELD_ADDED: 'NULLABLE_INPUT_FIELD_ADDED',\n  NULLABLE_ARG_ADDED: 'NULLABLE_ARG_ADDED'\n};\n\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of breaking changes covered by the other functions down below.\n */\nexport function findBreakingChanges(oldSchema, newSchema) {\n  return [].concat(findRemovedTypes(oldSchema, newSchema), findTypesThatChangedKind(oldSchema, newSchema), findFieldsThatChangedTypeOnObjectOrInterfaceTypes(oldSchema, newSchema), findFieldsThatChangedTypeOnInputObjectTypes(oldSchema, newSchema).breakingChanges, findTypesRemovedFromUnions(oldSchema, newSchema), findValuesRemovedFromEnums(oldSchema, newSchema), findArgChanges(oldSchema, newSchema).breakingChanges, findInterfacesRemovedFromObjectTypes(oldSchema, newSchema), findRemovedDirectives(oldSchema, newSchema), findRemovedDirectiveArgs(oldSchema, newSchema), findAddedNonNullDirectiveArgs(oldSchema, newSchema), findRemovedDirectiveLocations(oldSchema, newSchema));\n}\n\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of potentially dangerous changes covered by the other functions down below.\n */\nexport function findDangerousChanges(oldSchema, newSchema) {\n  return [].concat(findArgChanges(oldSchema, newSchema).dangerousChanges, findValuesAddedToEnums(oldSchema, newSchema), findInterfacesAddedToObjectTypes(oldSchema, newSchema), findTypesAddedToUnions(oldSchema, newSchema), findFieldsThatChangedTypeOnInputObjectTypes(oldSchema, newSchema).dangerousChanges);\n}\n\n/**\n * Given two schemas, returns an Array containing descriptions of any breaking\n * changes in the newSchema related to removing an entire type.\n */\nexport function findRemovedTypes(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n\n  var breakingChanges = [];\n  Object.keys(oldTypeMap).forEach(function (typeName) {\n    if (!newTypeMap[typeName]) {\n      breakingChanges.push({\n        type: BreakingChangeType.TYPE_REMOVED,\n        description: typeName + ' was removed.'\n      });\n    }\n  });\n  return breakingChanges;\n}\n\n/**\n * Given two schemas, returns an Array containing descriptions of any breaking\n * changes in the newSchema related to changing the type of a type.\n */\nexport function findTypesThatChangedKind(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n\n  var breakingChanges = [];\n  Object.keys(oldTypeMap).forEach(function (typeName) {\n    if (!newTypeMap[typeName]) {\n      return;\n    }\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n    if (oldType.constructor !== newType.constructor) {\n      breakingChanges.push({\n        type: BreakingChangeType.TYPE_CHANGED_KIND,\n        description: typeName + ' changed from ' + (typeKindName(oldType) + ' to ' + typeKindName(newType) + '.')\n      });\n    }\n  });\n  return breakingChanges;\n}\n\n/**\n * Given two schemas, returns an Array containing descriptions of any\n * breaking or dangerous changes in the newSchema related to arguments\n * (such as removal or change of type of an argument, or a change in an\n * argument's default value).\n */\nexport function findArgChanges(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n\n  var breakingChanges = [];\n  var dangerousChanges = [];\n\n  Object.keys(oldTypeMap).forEach(function (typeName) {\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n    if (!(isObjectType(oldType) || isInterfaceType(oldType)) || !(isObjectType(newType) || isInterfaceType(newType)) || newType.constructor !== oldType.constructor) {\n      return;\n    }\n\n    var oldTypeFields = oldType.getFields();\n    var newTypeFields = newType.getFields();\n\n    Object.keys(oldTypeFields).forEach(function (fieldName) {\n      if (!newTypeFields[fieldName]) {\n        return;\n      }\n\n      oldTypeFields[fieldName].args.forEach(function (oldArgDef) {\n        var newArgs = newTypeFields[fieldName].args;\n        var newArgDef = newArgs.find(function (arg) {\n          return arg.name === oldArgDef.name;\n        });\n\n        // Arg not present\n        if (!newArgDef) {\n          breakingChanges.push({\n            type: BreakingChangeType.ARG_REMOVED,\n            description: oldType.name + '.' + fieldName + ' arg ' + (oldArgDef.name + ' was removed')\n          });\n        } else {\n          var isSafe = isChangeSafeForInputObjectFieldOrFieldArg(oldArgDef.type, newArgDef.type);\n          if (!isSafe) {\n            breakingChanges.push({\n              type: BreakingChangeType.ARG_CHANGED_KIND,\n              description: oldType.name + '.' + fieldName + ' arg ' + (oldArgDef.name + ' has changed type from ') + (oldArgDef.type.toString() + ' to ' + newArgDef.type.toString())\n            });\n          } else if (oldArgDef.defaultValue !== undefined && oldArgDef.defaultValue !== newArgDef.defaultValue) {\n            dangerousChanges.push({\n              type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,\n              description: oldType.name + '.' + fieldName + ' arg ' + (oldArgDef.name + ' has changed defaultValue')\n            });\n          }\n        }\n      });\n      // Check if a non-null arg was added to the field\n      newTypeFields[fieldName].args.forEach(function (newArgDef) {\n        var oldArgs = oldTypeFields[fieldName].args;\n        var oldArgDef = oldArgs.find(function (arg) {\n          return arg.name === newArgDef.name;\n        });\n        if (!oldArgDef) {\n          if (isNonNullType(newArgDef.type)) {\n            breakingChanges.push({\n              type: BreakingChangeType.NON_NULL_ARG_ADDED,\n              description: 'A non-null arg ' + newArgDef.name + ' on ' + (newType.name + '.' + fieldName + ' was added')\n            });\n          } else {\n            dangerousChanges.push({\n              type: DangerousChangeType.NULLABLE_ARG_ADDED,\n              description: 'A nullable arg ' + newArgDef.name + ' on ' + (newType.name + '.' + fieldName + ' was added')\n            });\n          }\n        }\n      });\n    });\n  });\n\n  return {\n    breakingChanges: breakingChanges,\n    dangerousChanges: dangerousChanges\n  };\n}\n\nfunction typeKindName(type) {\n  if (isScalarType(type)) {\n    return 'a Scalar type';\n  }\n  if (isObjectType(type)) {\n    return 'an Object type';\n  }\n  if (isInterfaceType(type)) {\n    return 'an Interface type';\n  }\n  if (isUnionType(type)) {\n    return 'a Union type';\n  }\n  if (isEnumType(type)) {\n    return 'an Enum type';\n  }\n  if (isInputObjectType(type)) {\n    return 'an Input type';\n  }\n  throw new TypeError('Unknown type ' + type.constructor.name);\n}\n\nexport function findFieldsThatChangedTypeOnObjectOrInterfaceTypes(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n\n  var breakingChanges = [];\n  Object.keys(oldTypeMap).forEach(function (typeName) {\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n    if (!(isObjectType(oldType) || isInterfaceType(oldType)) || !(isObjectType(newType) || isInterfaceType(newType)) || newType.constructor !== oldType.constructor) {\n      return;\n    }\n\n    var oldTypeFieldsDef = oldType.getFields();\n    var newTypeFieldsDef = newType.getFields();\n    Object.keys(oldTypeFieldsDef).forEach(function (fieldName) {\n      // Check if the field is missing on the type in the new schema.\n      if (!(fieldName in newTypeFieldsDef)) {\n        breakingChanges.push({\n          type: BreakingChangeType.FIELD_REMOVED,\n          description: typeName + '.' + fieldName + ' was removed.'\n        });\n      } else {\n        var oldFieldType = oldTypeFieldsDef[fieldName].type;\n        var newFieldType = newTypeFieldsDef[fieldName].type;\n        var isSafe = isChangeSafeForObjectOrInterfaceField(oldFieldType, newFieldType);\n        if (!isSafe) {\n          var oldFieldTypeString = isNamedType(oldFieldType) ? oldFieldType.name : oldFieldType.toString();\n          var newFieldTypeString = isNamedType(newFieldType) ? newFieldType.name : newFieldType.toString();\n          breakingChanges.push({\n            type: BreakingChangeType.FIELD_CHANGED_KIND,\n            description: typeName + '.' + fieldName + ' changed type from ' + (oldFieldTypeString + ' to ' + newFieldTypeString + '.')\n          });\n        }\n      }\n    });\n  });\n  return breakingChanges;\n}\n\nexport function findFieldsThatChangedTypeOnInputObjectTypes(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n\n  var breakingChanges = [];\n  var dangerousChanges = [];\n  Object.keys(oldTypeMap).forEach(function (typeName) {\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n    if (!isInputObjectType(oldType) || !isInputObjectType(newType)) {\n      return;\n    }\n\n    var oldTypeFieldsDef = oldType.getFields();\n    var newTypeFieldsDef = newType.getFields();\n    Object.keys(oldTypeFieldsDef).forEach(function (fieldName) {\n      // Check if the field is missing on the type in the new schema.\n      if (!(fieldName in newTypeFieldsDef)) {\n        breakingChanges.push({\n          type: BreakingChangeType.FIELD_REMOVED,\n          description: typeName + '.' + fieldName + ' was removed.'\n        });\n      } else {\n        var oldFieldType = oldTypeFieldsDef[fieldName].type;\n        var newFieldType = newTypeFieldsDef[fieldName].type;\n\n        var isSafe = isChangeSafeForInputObjectFieldOrFieldArg(oldFieldType, newFieldType);\n        if (!isSafe) {\n          var oldFieldTypeString = isNamedType(oldFieldType) ? oldFieldType.name : oldFieldType.toString();\n          var newFieldTypeString = isNamedType(newFieldType) ? newFieldType.name : newFieldType.toString();\n          breakingChanges.push({\n            type: BreakingChangeType.FIELD_CHANGED_KIND,\n            description: typeName + '.' + fieldName + ' changed type from ' + (oldFieldTypeString + ' to ' + newFieldTypeString + '.')\n          });\n        }\n      }\n    });\n    // Check if a field was added to the input object type\n    Object.keys(newTypeFieldsDef).forEach(function (fieldName) {\n      if (!(fieldName in oldTypeFieldsDef)) {\n        if (isNonNullType(newTypeFieldsDef[fieldName].type)) {\n          breakingChanges.push({\n            type: BreakingChangeType.NON_NULL_INPUT_FIELD_ADDED,\n            description: 'A non-null field ' + fieldName + ' on ' + ('input type ' + newType.name + ' was added.')\n          });\n        } else {\n          dangerousChanges.push({\n            type: DangerousChangeType.NULLABLE_INPUT_FIELD_ADDED,\n            description: 'A nullable field ' + fieldName + ' on ' + ('input type ' + newType.name + ' was added.')\n          });\n        }\n      }\n    });\n  });\n  return {\n    breakingChanges: breakingChanges,\n    dangerousChanges: dangerousChanges\n  };\n}\n\nfunction isChangeSafeForObjectOrInterfaceField(oldType, newType) {\n  if (isNamedType(oldType)) {\n    return (\n      // if they're both named types, see if their names are equivalent\n      isNamedType(newType) && oldType.name === newType.name ||\n      // moving from nullable to non-null of the same underlying type is safe\n      isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)\n    );\n  } else if (isListType(oldType)) {\n    return (\n      // if they're both lists, make sure the underlying types are compatible\n      isListType(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType) ||\n      // moving from nullable to non-null of the same underlying type is safe\n      isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)\n    );\n  } else if (isNonNullType(oldType)) {\n    // if they're both non-null, make sure the underlying types are compatible\n    return isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType);\n  }\n  return false;\n}\n\nfunction isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {\n  if (isNamedType(oldType)) {\n    // if they're both named types, see if their names are equivalent\n    return isNamedType(newType) && oldType.name === newType.name;\n  } else if (isListType(oldType)) {\n    // if they're both lists, make sure the underlying types are compatible\n    return isListType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType);\n  } else if (isNonNullType(oldType)) {\n    return (\n      // if they're both non-null, make sure the underlying types are\n      // compatible\n      isNonNullType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType) ||\n      // moving from non-null to nullable of the same underlying type is safe\n      !isNonNullType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType)\n    );\n  }\n  return false;\n}\n\n/**\n * Given two schemas, returns an Array containing descriptions of any breaking\n * changes in the newSchema related to removing types from a union type.\n */\nexport function findTypesRemovedFromUnions(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n\n  var typesRemovedFromUnion = [];\n  Object.keys(oldTypeMap).forEach(function (typeName) {\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n    if (!isUnionType(oldType) || !isUnionType(newType)) {\n      return;\n    }\n    var typeNamesInNewUnion = Object.create(null);\n    newType.getTypes().forEach(function (type) {\n      typeNamesInNewUnion[type.name] = true;\n    });\n    oldType.getTypes().forEach(function (type) {\n      if (!typeNamesInNewUnion[type.name]) {\n        typesRemovedFromUnion.push({\n          type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,\n          description: type.name + ' was removed from union type ' + typeName + '.'\n        });\n      }\n    });\n  });\n  return typesRemovedFromUnion;\n}\n\n/**\n * Given two schemas, returns an Array containing descriptions of any dangerous\n * changes in the newSchema related to adding types to a union type.\n */\nexport function findTypesAddedToUnions(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n\n  var typesAddedToUnion = [];\n  Object.keys(newTypeMap).forEach(function (typeName) {\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n    if (!isUnionType(oldType) || !isUnionType(newType)) {\n      return;\n    }\n    var typeNamesInOldUnion = Object.create(null);\n    oldType.getTypes().forEach(function (type) {\n      typeNamesInOldUnion[type.name] = true;\n    });\n    newType.getTypes().forEach(function (type) {\n      if (!typeNamesInOldUnion[type.name]) {\n        typesAddedToUnion.push({\n          type: DangerousChangeType.TYPE_ADDED_TO_UNION,\n          description: type.name + ' was added to union type ' + typeName + '.'\n        });\n      }\n    });\n  });\n  return typesAddedToUnion;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any breaking\n * changes in the newSchema related to removing values from an enum type.\n */\nexport function findValuesRemovedFromEnums(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n\n  var valuesRemovedFromEnums = [];\n  Object.keys(oldTypeMap).forEach(function (typeName) {\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n    if (!isEnumType(oldType) || !isEnumType(newType)) {\n      return;\n    }\n    var valuesInNewEnum = Object.create(null);\n    newType.getValues().forEach(function (value) {\n      valuesInNewEnum[value.name] = true;\n    });\n    oldType.getValues().forEach(function (value) {\n      if (!valuesInNewEnum[value.name]) {\n        valuesRemovedFromEnums.push({\n          type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,\n          description: value.name + ' was removed from enum type ' + typeName + '.'\n        });\n      }\n    });\n  });\n  return valuesRemovedFromEnums;\n}\n\n/**\n * Given two schemas, returns an Array containing descriptions of any dangerous\n * changes in the newSchema related to adding values to an enum type.\n */\nexport function findValuesAddedToEnums(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n\n  var valuesAddedToEnums = [];\n  Object.keys(oldTypeMap).forEach(function (typeName) {\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n    if (!isEnumType(oldType) || !isEnumType(newType)) {\n      return;\n    }\n\n    var valuesInOldEnum = Object.create(null);\n    oldType.getValues().forEach(function (value) {\n      valuesInOldEnum[value.name] = true;\n    });\n    newType.getValues().forEach(function (value) {\n      if (!valuesInOldEnum[value.name]) {\n        valuesAddedToEnums.push({\n          type: DangerousChangeType.VALUE_ADDED_TO_ENUM,\n          description: value.name + ' was added to enum type ' + typeName + '.'\n        });\n      }\n    });\n  });\n  return valuesAddedToEnums;\n}\n\nexport function findInterfacesRemovedFromObjectTypes(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var breakingChanges = [];\n\n  Object.keys(oldTypeMap).forEach(function (typeName) {\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n    if (!isObjectType(oldType) || !isObjectType(newType)) {\n      return;\n    }\n\n    var oldInterfaces = oldType.getInterfaces();\n    var newInterfaces = newType.getInterfaces();\n    oldInterfaces.forEach(function (oldInterface) {\n      if (!newInterfaces.some(function (int) {\n        return int.name === oldInterface.name;\n      })) {\n        breakingChanges.push({\n          type: BreakingChangeType.INTERFACE_REMOVED_FROM_OBJECT,\n          description: typeName + ' no longer implements interface ' + (oldInterface.name + '.')\n        });\n      }\n    });\n  });\n  return breakingChanges;\n}\n\nexport function findInterfacesAddedToObjectTypes(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var interfacesAddedToObjectTypes = [];\n\n  Object.keys(newTypeMap).forEach(function (typeName) {\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n    if (!isObjectType(oldType) || !isObjectType(newType)) {\n      return;\n    }\n\n    var oldInterfaces = oldType.getInterfaces();\n    var newInterfaces = newType.getInterfaces();\n    newInterfaces.forEach(function (newInterface) {\n      if (!oldInterfaces.some(function (int) {\n        return int.name === newInterface.name;\n      })) {\n        interfacesAddedToObjectTypes.push({\n          type: DangerousChangeType.INTERFACE_ADDED_TO_OBJECT,\n          description: newInterface.name + ' added to interfaces implemented ' + ('by ' + typeName + '.')\n        });\n      }\n    });\n  });\n  return interfacesAddedToObjectTypes;\n}\n\nexport function findRemovedDirectives(oldSchema, newSchema) {\n  var removedDirectives = [];\n\n  var newSchemaDirectiveMap = getDirectiveMapForSchema(newSchema);\n  oldSchema.getDirectives().forEach(function (directive) {\n    if (!newSchemaDirectiveMap[directive.name]) {\n      removedDirectives.push({\n        type: BreakingChangeType.DIRECTIVE_REMOVED,\n        description: directive.name + ' was removed'\n      });\n    }\n  });\n\n  return removedDirectives;\n}\n\nfunction findRemovedArgsForDirective(oldDirective, newDirective) {\n  var removedArgs = [];\n  var newArgMap = getArgumentMapForDirective(newDirective);\n\n  oldDirective.args.forEach(function (arg) {\n    if (!newArgMap[arg.name]) {\n      removedArgs.push(arg);\n    }\n  });\n\n  return removedArgs;\n}\n\nexport function findRemovedDirectiveArgs(oldSchema, newSchema) {\n  var removedDirectiveArgs = [];\n  var oldSchemaDirectiveMap = getDirectiveMapForSchema(oldSchema);\n\n  newSchema.getDirectives().forEach(function (newDirective) {\n    var oldDirective = oldSchemaDirectiveMap[newDirective.name];\n    if (!oldDirective) {\n      return;\n    }\n\n    findRemovedArgsForDirective(oldDirective, newDirective).forEach(function (arg) {\n      removedDirectiveArgs.push({\n        type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,\n        description: arg.name + ' was removed from ' + newDirective.name\n      });\n    });\n  });\n\n  return removedDirectiveArgs;\n}\n\nfunction findAddedArgsForDirective(oldDirective, newDirective) {\n  var addedArgs = [];\n  var oldArgMap = getArgumentMapForDirective(oldDirective);\n\n  newDirective.args.forEach(function (arg) {\n    if (!oldArgMap[arg.name]) {\n      addedArgs.push(arg);\n    }\n  });\n\n  return addedArgs;\n}\n\nexport function findAddedNonNullDirectiveArgs(oldSchema, newSchema) {\n  var addedNonNullableArgs = [];\n  var oldSchemaDirectiveMap = getDirectiveMapForSchema(oldSchema);\n\n  newSchema.getDirectives().forEach(function (newDirective) {\n    var oldDirective = oldSchemaDirectiveMap[newDirective.name];\n    if (!oldDirective) {\n      return;\n    }\n\n    findAddedArgsForDirective(oldDirective, newDirective).forEach(function (arg) {\n      if (!isNonNullType(arg.type)) {\n        return;\n      }\n\n      addedNonNullableArgs.push({\n        type: BreakingChangeType.NON_NULL_DIRECTIVE_ARG_ADDED,\n        description: 'A non-null arg ' + arg.name + ' on directive ' + (newDirective.name + ' was added')\n      });\n    });\n  });\n\n  return addedNonNullableArgs;\n}\n\nexport function findRemovedLocationsForDirective(oldDirective, newDirective) {\n  var removedLocations = [];\n  var newLocationSet = new Set(newDirective.locations);\n\n  oldDirective.locations.forEach(function (oldLocation) {\n    if (!newLocationSet.has(oldLocation)) {\n      removedLocations.push(oldLocation);\n    }\n  });\n\n  return removedLocations;\n}\n\nexport function findRemovedDirectiveLocations(oldSchema, newSchema) {\n  var removedLocations = [];\n  var oldSchemaDirectiveMap = getDirectiveMapForSchema(oldSchema);\n\n  newSchema.getDirectives().forEach(function (newDirective) {\n    var oldDirective = oldSchemaDirectiveMap[newDirective.name];\n    if (!oldDirective) {\n      return;\n    }\n\n    findRemovedLocationsForDirective(oldDirective, newDirective).forEach(function (location) {\n      removedLocations.push({\n        type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,\n        description: location + ' was removed from ' + newDirective.name\n      });\n    });\n  });\n\n  return removedLocations;\n}\n\nfunction getDirectiveMapForSchema(schema) {\n  return keyMap(schema.getDirectives(), function (dir) {\n    return dir.name;\n  });\n}\n\nfunction getArgumentMapForDirective(directive) {\n  return keyMap(directive.args, function (arg) {\n    return arg.name;\n  });\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}