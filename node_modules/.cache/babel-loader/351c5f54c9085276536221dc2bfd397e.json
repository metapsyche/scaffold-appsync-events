{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport { print } from 'graphql/language/printer';\nimport { assign, createFragmentMap, getDefaultValues, getFragmentDefinitions, getOperationDefinition, isField, isIdValue, isInlineFragment, isProduction, resultKeyNameFromField, shouldInclude, storeKeyNameFromField, toIdValue, isEqual } from 'apollo-utilities';\nimport { ObjectCache } from './objectCache';\nimport { defaultNormalizedCacheFactory } from './depTrackingCache';\n\nvar WriteError = function (_super) {\n  __extends(WriteError, _super);\n\n  function WriteError() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = 'WriteError';\n    return _this;\n  }\n\n  return WriteError;\n}(Error);\n\nexport { WriteError };\nexport function enhanceErrorWithDocument(error, document) {\n  var enhancedError = new WriteError(\"Error writing result to store for query:\\n \" + print(document));\n  enhancedError.message += '\\n' + error.message;\n  enhancedError.stack = error.stack;\n  return enhancedError;\n}\n\nvar StoreWriter = function () {\n  function StoreWriter() {}\n\n  StoreWriter.prototype.writeQueryToStore = function (_a) {\n    var query = _a.query,\n        result = _a.result,\n        _b = _a.store,\n        store = _b === void 0 ? defaultNormalizedCacheFactory() : _b,\n        variables = _a.variables,\n        dataIdFromObject = _a.dataIdFromObject,\n        fragmentMatcherFunction = _a.fragmentMatcherFunction;\n    return this.writeResultToStore({\n      dataId: 'ROOT_QUERY',\n      result: result,\n      document: query,\n      store: store,\n      variables: variables,\n      dataIdFromObject: dataIdFromObject,\n      fragmentMatcherFunction: fragmentMatcherFunction\n    });\n  };\n\n  StoreWriter.prototype.writeResultToStore = function (_a) {\n    var dataId = _a.dataId,\n        result = _a.result,\n        document = _a.document,\n        _b = _a.store,\n        store = _b === void 0 ? defaultNormalizedCacheFactory() : _b,\n        variables = _a.variables,\n        dataIdFromObject = _a.dataIdFromObject,\n        fragmentMatcherFunction = _a.fragmentMatcherFunction;\n    var operationDefinition = getOperationDefinition(document);\n\n    try {\n      return this.writeSelectionSetToStore({\n        result: result,\n        dataId: dataId,\n        selectionSet: operationDefinition.selectionSet,\n        context: {\n          store: store,\n          processedData: {},\n          variables: assign({}, getDefaultValues(operationDefinition), variables),\n          dataIdFromObject: dataIdFromObject,\n          fragmentMap: createFragmentMap(getFragmentDefinitions(document)),\n          fragmentMatcherFunction: fragmentMatcherFunction\n        }\n      });\n    } catch (e) {\n      throw enhanceErrorWithDocument(e, document);\n    }\n  };\n\n  StoreWriter.prototype.writeSelectionSetToStore = function (_a) {\n    var _this = this;\n\n    var result = _a.result,\n        dataId = _a.dataId,\n        selectionSet = _a.selectionSet,\n        context = _a.context;\n    var variables = context.variables,\n        store = context.store,\n        fragmentMap = context.fragmentMap;\n    selectionSet.selections.forEach(function (selection) {\n      if (!shouldInclude(selection, variables)) {\n        return;\n      }\n\n      if (isField(selection)) {\n        var resultFieldKey = resultKeyNameFromField(selection);\n        var value = result[resultFieldKey];\n\n        if (typeof value !== 'undefined') {\n          _this.writeFieldToStore({\n            dataId: dataId,\n            value: value,\n            field: selection,\n            context: context\n          });\n        } else {\n          var isDefered = selection.directives && selection.directives.length && selection.directives.some(function (directive) {\n            return directive.name && directive.name.value === 'defer';\n          });\n\n          if (!isDefered && context.fragmentMatcherFunction) {\n            if (!isProduction()) {\n              console.warn(\"Missing field \" + resultFieldKey + \" in \" + JSON.stringify(result, null, 2).substring(0, 100));\n            }\n          }\n        }\n      } else {\n        var fragment = void 0;\n\n        if (isInlineFragment(selection)) {\n          fragment = selection;\n        } else {\n          fragment = (fragmentMap || {})[selection.name.value];\n\n          if (!fragment) {\n            throw new Error(\"No fragment named \" + selection.name.value + \".\");\n          }\n        }\n\n        var matches = true;\n\n        if (context.fragmentMatcherFunction && fragment.typeCondition) {\n          var idValue = toIdValue({\n            id: 'self',\n            typename: undefined\n          });\n          var fakeContext = {\n            store: new ObjectCache({\n              self: result\n            }),\n            cacheRedirects: {}\n          };\n          var match = context.fragmentMatcherFunction(idValue, fragment.typeCondition.name.value, fakeContext);\n\n          if (!isProduction() && match === 'heuristic') {\n            console.error('WARNING: heuristic fragment matching going on!');\n          }\n\n          matches = !!match;\n        }\n\n        if (matches) {\n          _this.writeSelectionSetToStore({\n            result: result,\n            selectionSet: fragment.selectionSet,\n            dataId: dataId,\n            context: context\n          });\n        }\n      }\n    });\n    return store;\n  };\n\n  StoreWriter.prototype.writeFieldToStore = function (_a) {\n    var field = _a.field,\n        value = _a.value,\n        dataId = _a.dataId,\n        context = _a.context;\n\n    var _b;\n\n    var variables = context.variables,\n        dataIdFromObject = context.dataIdFromObject,\n        store = context.store;\n    var storeValue;\n    var storeObject;\n    var storeFieldName = storeKeyNameFromField(field, variables);\n\n    if (!field.selectionSet || value === null) {\n      storeValue = value != null && typeof value === 'object' ? {\n        type: 'json',\n        json: value\n      } : value;\n    } else if (Array.isArray(value)) {\n      var generatedId = dataId + \".\" + storeFieldName;\n      storeValue = this.processArrayValue(value, generatedId, field.selectionSet, context);\n    } else {\n      var valueDataId = dataId + \".\" + storeFieldName;\n      var generated = true;\n\n      if (!isGeneratedId(valueDataId)) {\n        valueDataId = '$' + valueDataId;\n      }\n\n      if (dataIdFromObject) {\n        var semanticId = dataIdFromObject(value);\n\n        if (semanticId && isGeneratedId(semanticId)) {\n          throw new Error('IDs returned by dataIdFromObject cannot begin with the \"$\" character.');\n        }\n\n        if (semanticId || typeof semanticId === 'number' && semanticId === 0) {\n          valueDataId = semanticId;\n          generated = false;\n        }\n      }\n\n      if (!isDataProcessed(valueDataId, field, context.processedData)) {\n        this.writeSelectionSetToStore({\n          dataId: valueDataId,\n          result: value,\n          selectionSet: field.selectionSet,\n          context: context\n        });\n      }\n\n      var typename = value.__typename;\n      storeValue = toIdValue({\n        id: valueDataId,\n        typename: typename\n      }, generated);\n      storeObject = store.get(dataId);\n      var escapedId = storeObject && storeObject[storeFieldName];\n\n      if (escapedId !== storeValue && isIdValue(escapedId)) {\n        var hadTypename = escapedId.typename !== undefined;\n        var hasTypename = typename !== undefined;\n        var typenameChanged = hadTypename && hasTypename && escapedId.typename !== typename;\n\n        if (generated && !escapedId.generated && !typenameChanged) {\n          throw new Error(\"Store error: the application attempted to write an object with no provided id\" + (\" but the store already contains an id of \" + escapedId.id + \" for this object. The selectionSet\") + \" that was trying to be written is:\\n\" + print(field));\n        }\n\n        if (hadTypename && !hasTypename) {\n          throw new Error(\"Store error: the application attempted to write an object with no provided typename\" + (\" but the store already contains an object with typename of \" + escapedId.typename + \" for the object of id \" + escapedId.id + \". The selectionSet\") + \" that was trying to be written is:\\n\" + print(field));\n        }\n\n        if (escapedId.generated) {\n          if (typenameChanged) {\n            if (!generated) {\n              store.delete(escapedId.id);\n            }\n          } else {\n            mergeWithGenerated(escapedId.id, storeValue.id, store);\n          }\n        }\n      }\n    }\n\n    storeObject = store.get(dataId);\n\n    if (!storeObject || !isEqual(storeValue, storeObject[storeFieldName])) {\n      store.set(dataId, __assign({}, storeObject, (_b = {}, _b[storeFieldName] = storeValue, _b)));\n    }\n  };\n\n  StoreWriter.prototype.processArrayValue = function (value, generatedId, selectionSet, context) {\n    var _this = this;\n\n    return value.map(function (item, index) {\n      if (item === null) {\n        return null;\n      }\n\n      var itemDataId = generatedId + \".\" + index;\n\n      if (Array.isArray(item)) {\n        return _this.processArrayValue(item, itemDataId, selectionSet, context);\n      }\n\n      var generated = true;\n\n      if (context.dataIdFromObject) {\n        var semanticId = context.dataIdFromObject(item);\n\n        if (semanticId) {\n          itemDataId = semanticId;\n          generated = false;\n        }\n      }\n\n      if (!isDataProcessed(itemDataId, selectionSet, context.processedData)) {\n        _this.writeSelectionSetToStore({\n          dataId: itemDataId,\n          result: item,\n          selectionSet: selectionSet,\n          context: context\n        });\n      }\n\n      return toIdValue({\n        id: itemDataId,\n        typename: item.__typename\n      }, generated);\n    });\n  };\n\n  return StoreWriter;\n}();\n\nexport { StoreWriter };\n\nfunction isGeneratedId(id) {\n  return id[0] === '$';\n}\n\nfunction mergeWithGenerated(generatedKey, realKey, cache) {\n  if (generatedKey === realKey) {\n    return false;\n  }\n\n  var generated = cache.get(generatedKey);\n  var real = cache.get(realKey);\n  var madeChanges = false;\n  Object.keys(generated).forEach(function (key) {\n    var value = generated[key];\n    var realValue = real[key];\n\n    if (isIdValue(value) && isGeneratedId(value.id) && isIdValue(realValue) && !isEqual(value, realValue) && mergeWithGenerated(value.id, realValue.id, cache)) {\n      madeChanges = true;\n    }\n  });\n  cache.delete(generatedKey);\n\n  var newRealValue = __assign({}, generated, real);\n\n  if (isEqual(newRealValue, real)) {\n    return madeChanges;\n  }\n\n  cache.set(realKey, newRealValue);\n  return true;\n}\n\nfunction isDataProcessed(dataId, field, processedData) {\n  if (!processedData) {\n    return false;\n  }\n\n  if (processedData[dataId]) {\n    if (processedData[dataId].indexOf(field) >= 0) {\n      return true;\n    } else {\n      processedData[dataId].push(field);\n    }\n  } else {\n    processedData[dataId] = [field];\n  }\n\n  return false;\n}","map":{"version":3,"sources":["../src/writeToStore.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    }\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { print } from 'graphql/language/printer';\nimport { assign, createFragmentMap, getDefaultValues, getFragmentDefinitions, getOperationDefinition, isField, isIdValue, isInlineFragment, isProduction, resultKeyNameFromField, shouldInclude, storeKeyNameFromField, toIdValue, isEqual, } from 'apollo-utilities';\nimport { ObjectCache } from './objectCache';\nimport { defaultNormalizedCacheFactory } from './depTrackingCache';\nvar WriteError = (function (_super) {\n    __extends(WriteError, _super);\n    function WriteError() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.type = 'WriteError';\n        return _this;\n    }\n    return WriteError;\n}(Error));\nexport { WriteError };\nexport function enhanceErrorWithDocument(error, document) {\n    var enhancedError = new WriteError(\"Error writing result to store for query:\\n \" + print(document));\n    enhancedError.message += '\\n' + error.message;\n    enhancedError.stack = error.stack;\n    return enhancedError;\n}\nvar StoreWriter = (function () {\n    function StoreWriter() {\n    }\n    StoreWriter.prototype.writeQueryToStore = function (_a) {\n        var query = _a.query, result = _a.result, _b = _a.store, store = _b === void 0 ? defaultNormalizedCacheFactory() : _b, variables = _a.variables, dataIdFromObject = _a.dataIdFromObject, fragmentMatcherFunction = _a.fragmentMatcherFunction;\n        return this.writeResultToStore({\n            dataId: 'ROOT_QUERY',\n            result: result,\n            document: query,\n            store: store,\n            variables: variables,\n            dataIdFromObject: dataIdFromObject,\n            fragmentMatcherFunction: fragmentMatcherFunction,\n        });\n    };\n    StoreWriter.prototype.writeResultToStore = function (_a) {\n        var dataId = _a.dataId, result = _a.result, document = _a.document, _b = _a.store, store = _b === void 0 ? defaultNormalizedCacheFactory() : _b, variables = _a.variables, dataIdFromObject = _a.dataIdFromObject, fragmentMatcherFunction = _a.fragmentMatcherFunction;\n        var operationDefinition = getOperationDefinition(document);\n        try {\n            return this.writeSelectionSetToStore({\n                result: result,\n                dataId: dataId,\n                selectionSet: operationDefinition.selectionSet,\n                context: {\n                    store: store,\n                    processedData: {},\n                    variables: assign({}, getDefaultValues(operationDefinition), variables),\n                    dataIdFromObject: dataIdFromObject,\n                    fragmentMap: createFragmentMap(getFragmentDefinitions(document)),\n                    fragmentMatcherFunction: fragmentMatcherFunction,\n                },\n            });\n        }\n        catch (e) {\n            throw enhanceErrorWithDocument(e, document);\n        }\n    };\n    StoreWriter.prototype.writeSelectionSetToStore = function (_a) {\n        var _this = this;\n        var result = _a.result, dataId = _a.dataId, selectionSet = _a.selectionSet, context = _a.context;\n        var variables = context.variables, store = context.store, fragmentMap = context.fragmentMap;\n        selectionSet.selections.forEach(function (selection) {\n            if (!shouldInclude(selection, variables)) {\n                return;\n            }\n            if (isField(selection)) {\n                var resultFieldKey = resultKeyNameFromField(selection);\n                var value = result[resultFieldKey];\n                if (typeof value !== 'undefined') {\n                    _this.writeFieldToStore({\n                        dataId: dataId,\n                        value: value,\n                        field: selection,\n                        context: context,\n                    });\n                }\n                else {\n                    var isDefered = selection.directives &&\n                        selection.directives.length &&\n                        selection.directives.some(function (directive) { return directive.name && directive.name.value === 'defer'; });\n                    if (!isDefered && context.fragmentMatcherFunction) {\n                        if (!isProduction()) {\n                            console.warn(\"Missing field \" + resultFieldKey + \" in \" + JSON.stringify(result, null, 2).substring(0, 100));\n                        }\n                    }\n                }\n            }\n            else {\n                var fragment = void 0;\n                if (isInlineFragment(selection)) {\n                    fragment = selection;\n                }\n                else {\n                    fragment = (fragmentMap || {})[selection.name.value];\n                    if (!fragment) {\n                        throw new Error(\"No fragment named \" + selection.name.value + \".\");\n                    }\n                }\n                var matches = true;\n                if (context.fragmentMatcherFunction && fragment.typeCondition) {\n                    var idValue = toIdValue({ id: 'self', typename: undefined });\n                    var fakeContext = {\n                        store: new ObjectCache({ self: result }),\n                        cacheRedirects: {},\n                    };\n                    var match = context.fragmentMatcherFunction(idValue, fragment.typeCondition.name.value, fakeContext);\n                    if (!isProduction() && match === 'heuristic') {\n                        console.error('WARNING: heuristic fragment matching going on!');\n                    }\n                    matches = !!match;\n                }\n                if (matches) {\n                    _this.writeSelectionSetToStore({\n                        result: result,\n                        selectionSet: fragment.selectionSet,\n                        dataId: dataId,\n                        context: context,\n                    });\n                }\n            }\n        });\n        return store;\n    };\n    StoreWriter.prototype.writeFieldToStore = function (_a) {\n        var field = _a.field, value = _a.value, dataId = _a.dataId, context = _a.context;\n        var _b;\n        var variables = context.variables, dataIdFromObject = context.dataIdFromObject, store = context.store;\n        var storeValue;\n        var storeObject;\n        var storeFieldName = storeKeyNameFromField(field, variables);\n        if (!field.selectionSet || value === null) {\n            storeValue =\n                value != null && typeof value === 'object'\n                    ?\n                        { type: 'json', json: value }\n                    :\n                        value;\n        }\n        else if (Array.isArray(value)) {\n            var generatedId = dataId + \".\" + storeFieldName;\n            storeValue = this.processArrayValue(value, generatedId, field.selectionSet, context);\n        }\n        else {\n            var valueDataId = dataId + \".\" + storeFieldName;\n            var generated = true;\n            if (!isGeneratedId(valueDataId)) {\n                valueDataId = '$' + valueDataId;\n            }\n            if (dataIdFromObject) {\n                var semanticId = dataIdFromObject(value);\n                if (semanticId && isGeneratedId(semanticId)) {\n                    throw new Error('IDs returned by dataIdFromObject cannot begin with the \"$\" character.');\n                }\n                if (semanticId ||\n                    (typeof semanticId === 'number' && semanticId === 0)) {\n                    valueDataId = semanticId;\n                    generated = false;\n                }\n            }\n            if (!isDataProcessed(valueDataId, field, context.processedData)) {\n                this.writeSelectionSetToStore({\n                    dataId: valueDataId,\n                    result: value,\n                    selectionSet: field.selectionSet,\n                    context: context,\n                });\n            }\n            var typename = value.__typename;\n            storeValue = toIdValue({ id: valueDataId, typename: typename }, generated);\n            storeObject = store.get(dataId);\n            var escapedId = storeObject && storeObject[storeFieldName];\n            if (escapedId !== storeValue && isIdValue(escapedId)) {\n                var hadTypename = escapedId.typename !== undefined;\n                var hasTypename = typename !== undefined;\n                var typenameChanged = hadTypename && hasTypename && escapedId.typename !== typename;\n                if (generated && !escapedId.generated && !typenameChanged) {\n                    throw new Error(\"Store error: the application attempted to write an object with no provided id\" +\n                        (\" but the store already contains an id of \" + escapedId.id + \" for this object. The selectionSet\") +\n                        \" that was trying to be written is:\\n\" +\n                        print(field));\n                }\n                if (hadTypename && !hasTypename) {\n                    throw new Error(\"Store error: the application attempted to write an object with no provided typename\" +\n                        (\" but the store already contains an object with typename of \" + escapedId.typename + \" for the object of id \" + escapedId.id + \". The selectionSet\") +\n                        \" that was trying to be written is:\\n\" +\n                        print(field));\n                }\n                if (escapedId.generated) {\n                    if (typenameChanged) {\n                        if (!generated) {\n                            store.delete(escapedId.id);\n                        }\n                    }\n                    else {\n                        mergeWithGenerated(escapedId.id, storeValue.id, store);\n                    }\n                }\n            }\n        }\n        storeObject = store.get(dataId);\n        if (!storeObject || !isEqual(storeValue, storeObject[storeFieldName])) {\n            store.set(dataId, __assign({}, storeObject, (_b = {}, _b[storeFieldName] = storeValue, _b)));\n        }\n    };\n    StoreWriter.prototype.processArrayValue = function (value, generatedId, selectionSet, context) {\n        var _this = this;\n        return value.map(function (item, index) {\n            if (item === null) {\n                return null;\n            }\n            var itemDataId = generatedId + \".\" + index;\n            if (Array.isArray(item)) {\n                return _this.processArrayValue(item, itemDataId, selectionSet, context);\n            }\n            var generated = true;\n            if (context.dataIdFromObject) {\n                var semanticId = context.dataIdFromObject(item);\n                if (semanticId) {\n                    itemDataId = semanticId;\n                    generated = false;\n                }\n            }\n            if (!isDataProcessed(itemDataId, selectionSet, context.processedData)) {\n                _this.writeSelectionSetToStore({\n                    dataId: itemDataId,\n                    result: item,\n                    selectionSet: selectionSet,\n                    context: context,\n                });\n            }\n            return toIdValue({ id: itemDataId, typename: item.__typename }, generated);\n        });\n    };\n    return StoreWriter;\n}());\nexport { StoreWriter };\nfunction isGeneratedId(id) {\n    return id[0] === '$';\n}\nfunction mergeWithGenerated(generatedKey, realKey, cache) {\n    if (generatedKey === realKey) {\n        return false;\n    }\n    var generated = cache.get(generatedKey);\n    var real = cache.get(realKey);\n    var madeChanges = false;\n    Object.keys(generated).forEach(function (key) {\n        var value = generated[key];\n        var realValue = real[key];\n        if (isIdValue(value) &&\n            isGeneratedId(value.id) &&\n            isIdValue(realValue) &&\n            !isEqual(value, realValue) &&\n            mergeWithGenerated(value.id, realValue.id, cache)) {\n            madeChanges = true;\n        }\n    });\n    cache.delete(generatedKey);\n    var newRealValue = __assign({}, generated, real);\n    if (isEqual(newRealValue, real)) {\n        return madeChanges;\n    }\n    cache.set(realKey, newRealValue);\n    return true;\n}\nfunction isDataProcessed(dataId, field, processedData) {\n    if (!processedData) {\n        return false;\n    }\n    if (processedData[dataId]) {\n        if (processedData[dataId].indexOf(field) >= 0) {\n            return true;\n        }\n        else {\n            processedData[dataId].push(field);\n        }\n    }\n    else {\n        processedData[dataId] = [field];\n    }\n    return false;\n}\n//# sourceMappingURL=writeToStore.js.map"]},"metadata":{},"sourceType":"module"}