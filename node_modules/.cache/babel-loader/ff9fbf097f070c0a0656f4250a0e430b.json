{"ast":null,"code":"/**\n * A visitor is comprised of visit functions, which are called on each node\n * during the visitor's traversal.\n */\n\n/**\n * A visitor is provided to visit, it contains the collection of\n * relevant functions to be called during the visitor's traversal.\n */\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nexport var QueryDocumentKeys = {\n  Name: [],\n  Document: ['definitions'],\n  OperationDefinition: ['name', 'variableDefinitions', 'directives', 'selectionSet'],\n  VariableDefinition: ['variable', 'type', 'defaultValue'],\n  Variable: ['name'],\n  SelectionSet: ['selections'],\n  Field: ['alias', 'name', 'arguments', 'directives', 'selectionSet'],\n  Argument: ['name', 'value'],\n  FragmentSpread: ['name', 'directives'],\n  InlineFragment: ['typeCondition', 'directives', 'selectionSet'],\n  FragmentDefinition: ['name', // Note: fragment variable definitions are experimental and may be changed\n  // or removed in the future.\n  'variableDefinitions', 'typeCondition', 'directives', 'selectionSet'],\n  IntValue: [],\n  FloatValue: [],\n  StringValue: [],\n  BooleanValue: [],\n  NullValue: [],\n  EnumValue: [],\n  ListValue: ['values'],\n  ObjectValue: ['fields'],\n  ObjectField: ['name', 'value'],\n  Directive: ['name', 'arguments'],\n  NamedType: ['name'],\n  ListType: ['type'],\n  NonNullType: ['type'],\n  SchemaDefinition: ['directives', 'operationTypes'],\n  OperationTypeDefinition: ['type'],\n  ScalarTypeDefinition: ['description', 'name', 'directives'],\n  ObjectTypeDefinition: ['description', 'name', 'interfaces', 'directives', 'fields'],\n  FieldDefinition: ['description', 'name', 'arguments', 'type', 'directives'],\n  InputValueDefinition: ['description', 'name', 'type', 'defaultValue', 'directives'],\n  InterfaceTypeDefinition: ['description', 'name', 'directives', 'fields'],\n  UnionTypeDefinition: ['description', 'name', 'directives', 'types'],\n  EnumTypeDefinition: ['description', 'name', 'directives', 'values'],\n  EnumValueDefinition: ['description', 'name', 'directives'],\n  InputObjectTypeDefinition: ['description', 'name', 'directives', 'fields'],\n  ScalarTypeExtension: ['name', 'directives'],\n  ObjectTypeExtension: ['name', 'interfaces', 'directives', 'fields'],\n  InterfaceTypeExtension: ['name', 'directives', 'fields'],\n  UnionTypeExtension: ['name', 'directives', 'types'],\n  EnumTypeExtension: ['name', 'directives', 'values'],\n  InputObjectTypeExtension: ['name', 'directives', 'fields'],\n  DirectiveDefinition: ['description', 'name', 'arguments', 'locations']\n};\n/**\n * A KeyMap describes each the traversable properties of each kind of node.\n */\n\nexport var BREAK = {};\n/**\n * visit() will walk through an AST using a depth first traversal, calling\n * the visitor's enter function at each node in the traversal, and calling the\n * leave function after visiting that node and all of its child nodes.\n *\n * By returning different values from the enter and leave functions, the\n * behavior of the visitor can be altered, including skipping over a sub-tree of\n * the AST (by returning false), editing the AST by returning a value or null\n * to remove the value, or to stop the whole traversal by returning BREAK.\n *\n * When using visit() to edit an AST, the original AST will not be modified, and\n * a new version of the AST with the changes applied will be returned from the\n * visit function.\n *\n *     const editedAST = visit(ast, {\n *       enter(node, key, parent, path, ancestors) {\n *         // @return\n *         //   undefined: no action\n *         //   false: skip visiting this node\n *         //   visitor.BREAK: stop visiting altogether\n *         //   null: delete this node\n *         //   any value: replace this node with the returned value\n *       },\n *       leave(node, key, parent, path, ancestors) {\n *         // @return\n *         //   undefined: no action\n *         //   false: no action\n *         //   visitor.BREAK: stop visiting altogether\n *         //   null: delete this node\n *         //   any value: replace this node with the returned value\n *       }\n *     });\n *\n * Alternatively to providing enter() and leave() functions, a visitor can\n * instead provide functions named the same as the kinds of AST nodes, or\n * enter/leave visitors at a named key, leading to four permutations of\n * visitor API:\n *\n * 1) Named visitors triggered when entering a node a specific kind.\n *\n *     visit(ast, {\n *       Kind(node) {\n *         // enter the \"Kind\" node\n *       }\n *     })\n *\n * 2) Named visitors that trigger upon entering and leaving a node of\n *    a specific kind.\n *\n *     visit(ast, {\n *       Kind: {\n *         enter(node) {\n *           // enter the \"Kind\" node\n *         }\n *         leave(node) {\n *           // leave the \"Kind\" node\n *         }\n *       }\n *     })\n *\n * 3) Generic visitors that trigger upon entering and leaving any node.\n *\n *     visit(ast, {\n *       enter(node) {\n *         // enter any node\n *       },\n *       leave(node) {\n *         // leave any node\n *       }\n *     })\n *\n * 4) Parallel visitors for entering and leaving nodes of a specific kind.\n *\n *     visit(ast, {\n *       enter: {\n *         Kind(node) {\n *           // enter the \"Kind\" node\n *         }\n *       },\n *       leave: {\n *         Kind(node) {\n *           // leave the \"Kind\" node\n *         }\n *       }\n *     })\n */\n\nexport function visit(root, visitor) {\n  var visitorKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : QueryDocumentKeys;\n  /* eslint-disable no-undef-init */\n\n  var stack = undefined;\n  var inArray = Array.isArray(root);\n  var keys = [root];\n  var index = -1;\n  var edits = [];\n  var node = undefined;\n  var key = undefined;\n  var parent = undefined;\n  var path = [];\n  var ancestors = [];\n  var newRoot = root;\n  /* eslint-enable no-undef-init */\n\n  do {\n    index++;\n    var isLeaving = index === keys.length;\n    var isEdited = isLeaving && edits.length !== 0;\n\n    if (isLeaving) {\n      key = ancestors.length === 0 ? undefined : path[path.length - 1];\n      node = parent;\n      parent = ancestors.pop();\n\n      if (isEdited) {\n        if (inArray) {\n          node = node.slice();\n        } else {\n          var clone = {};\n\n          for (var k in node) {\n            if (node.hasOwnProperty(k)) {\n              clone[k] = node[k];\n            }\n          }\n\n          node = clone;\n        }\n\n        var editOffset = 0;\n\n        for (var ii = 0; ii < edits.length; ii++) {\n          var editKey = edits[ii][0];\n          var editValue = edits[ii][1];\n\n          if (inArray) {\n            editKey -= editOffset;\n          }\n\n          if (inArray && editValue === null) {\n            node.splice(editKey, 1);\n            editOffset++;\n          } else {\n            node[editKey] = editValue;\n          }\n        }\n      }\n\n      index = stack.index;\n      keys = stack.keys;\n      edits = stack.edits;\n      inArray = stack.inArray;\n      stack = stack.prev;\n    } else {\n      key = parent ? inArray ? index : keys[index] : undefined;\n      node = parent ? parent[key] : newRoot;\n\n      if (node === null || node === undefined) {\n        continue;\n      }\n\n      if (parent) {\n        path.push(key);\n      }\n    }\n\n    var result = void 0;\n\n    if (!Array.isArray(node)) {\n      if (!isNode(node)) {\n        throw new Error('Invalid AST Node: ' + JSON.stringify(node));\n      }\n\n      var visitFn = getVisitFn(visitor, node.kind, isLeaving);\n\n      if (visitFn) {\n        result = visitFn.call(visitor, node, key, parent, path, ancestors);\n\n        if (result === BREAK) {\n          break;\n        }\n\n        if (result === false) {\n          if (!isLeaving) {\n            path.pop();\n            continue;\n          }\n        } else if (result !== undefined) {\n          edits.push([key, result]);\n\n          if (!isLeaving) {\n            if (isNode(result)) {\n              node = result;\n            } else {\n              path.pop();\n              continue;\n            }\n          }\n        }\n      }\n    }\n\n    if (result === undefined && isEdited) {\n      edits.push([key, node]);\n    }\n\n    if (isLeaving) {\n      path.pop();\n    } else {\n      stack = {\n        inArray: inArray,\n        index: index,\n        keys: keys,\n        edits: edits,\n        prev: stack\n      };\n      inArray = Array.isArray(node);\n      keys = inArray ? node : visitorKeys[node.kind] || [];\n      index = -1;\n      edits = [];\n\n      if (parent) {\n        ancestors.push(parent);\n      }\n\n      parent = node;\n    }\n  } while (stack !== undefined);\n\n  if (edits.length !== 0) {\n    newRoot = edits[edits.length - 1][1];\n  }\n\n  return newRoot;\n}\n\nfunction isNode(maybeNode) {\n  return Boolean(maybeNode && typeof maybeNode.kind === 'string');\n}\n/**\n * Creates a new visitor instance which delegates to many visitors to run in\n * parallel. Each visitor will be visited for each node before moving on.\n *\n * If a prior visitor edits a node, no following visitors will see that node.\n */\n\n\nexport function visitInParallel(visitors) {\n  var skipping = new Array(visitors.length);\n  return {\n    enter: function enter(node) {\n      for (var i = 0; i < visitors.length; i++) {\n        if (!skipping[i]) {\n          var fn = getVisitFn(visitors[i], node.kind,\n          /* isLeaving */\n          false);\n\n          if (fn) {\n            var result = fn.apply(visitors[i], arguments);\n\n            if (result === false) {\n              skipping[i] = node;\n            } else if (result === BREAK) {\n              skipping[i] = BREAK;\n            } else if (result !== undefined) {\n              return result;\n            }\n          }\n        }\n      }\n    },\n    leave: function leave(node) {\n      for (var i = 0; i < visitors.length; i++) {\n        if (!skipping[i]) {\n          var fn = getVisitFn(visitors[i], node.kind,\n          /* isLeaving */\n          true);\n\n          if (fn) {\n            var result = fn.apply(visitors[i], arguments);\n\n            if (result === BREAK) {\n              skipping[i] = BREAK;\n            } else if (result !== undefined && result !== false) {\n              return result;\n            }\n          }\n        } else if (skipping[i] === node) {\n          skipping[i] = null;\n        }\n      }\n    }\n  };\n}\n/**\n * Creates a new visitor instance which maintains a provided TypeInfo instance\n * along with visiting visitor.\n */\n\nexport function visitWithTypeInfo(typeInfo, visitor) {\n  return {\n    enter: function enter(node) {\n      typeInfo.enter(node);\n      var fn = getVisitFn(visitor, node.kind,\n      /* isLeaving */\n      false);\n\n      if (fn) {\n        var result = fn.apply(visitor, arguments);\n\n        if (result !== undefined) {\n          typeInfo.leave(node);\n\n          if (isNode(result)) {\n            typeInfo.enter(result);\n          }\n        }\n\n        return result;\n      }\n    },\n    leave: function leave(node) {\n      var fn = getVisitFn(visitor, node.kind,\n      /* isLeaving */\n      true);\n      var result = void 0;\n\n      if (fn) {\n        result = fn.apply(visitor, arguments);\n      }\n\n      typeInfo.leave(node);\n      return result;\n    }\n  };\n}\n/**\n * Given a visitor instance, if it is leaving or not, and a node kind, return\n * the function the visitor runtime should call.\n */\n\nexport function getVisitFn(visitor, kind, isLeaving) {\n  var kindVisitor = visitor[kind];\n\n  if (kindVisitor) {\n    if (!isLeaving && typeof kindVisitor === 'function') {\n      // { Kind() {} }\n      return kindVisitor;\n    }\n\n    var kindSpecificVisitor = isLeaving ? kindVisitor.leave : kindVisitor.enter;\n\n    if (typeof kindSpecificVisitor === 'function') {\n      // { Kind: { enter() {}, leave() {} } }\n      return kindSpecificVisitor;\n    }\n  } else {\n    var specificVisitor = isLeaving ? visitor.leave : visitor.enter;\n\n    if (specificVisitor) {\n      if (typeof specificVisitor === 'function') {\n        // { enter() {}, leave() {} }\n        return specificVisitor;\n      }\n\n      var specificKindVisitor = specificVisitor[kind];\n\n      if (typeof specificKindVisitor === 'function') {\n        // { enter: { Kind() {} }, leave: { Kind() {} } }\n        return specificKindVisitor;\n      }\n    }\n  }\n}","map":{"version":3,"names":["QueryDocumentKeys","Name","Document","OperationDefinition","VariableDefinition","Variable","SelectionSet","Field","Argument","FragmentSpread","InlineFragment","FragmentDefinition","IntValue","FloatValue","StringValue","BooleanValue","NullValue","EnumValue","ListValue","ObjectValue","ObjectField","Directive","NamedType","ListType","NonNullType","SchemaDefinition","OperationTypeDefinition","ScalarTypeDefinition","ObjectTypeDefinition","FieldDefinition","InputValueDefinition","InterfaceTypeDefinition","UnionTypeDefinition","EnumTypeDefinition","EnumValueDefinition","InputObjectTypeDefinition","ScalarTypeExtension","ObjectTypeExtension","InterfaceTypeExtension","UnionTypeExtension","EnumTypeExtension","InputObjectTypeExtension","DirectiveDefinition","BREAK","visit","root","visitor","visitorKeys","arguments","length","undefined","stack","inArray","Array","isArray","keys","index","edits","node","key","parent","path","ancestors","newRoot","isLeaving","isEdited","pop","slice","clone","k","hasOwnProperty","editOffset","ii","editKey","editValue","splice","prev","push","result","isNode","Error","JSON","stringify","visitFn","getVisitFn","kind","call","maybeNode","Boolean","visitInParallel","visitors","skipping","enter","i","fn","apply","leave","visitWithTypeInfo","typeInfo","kindVisitor","kindSpecificVisitor","specificVisitor","specificKindVisitor"],"sources":["/Users/roaldmaravillas/ro/github/scaffold-appsync-events/node_modules/aws-appsync/node_modules/graphql/module/language/visitor.js"],"sourcesContent":["\n\n/**\n * A visitor is comprised of visit functions, which are called on each node\n * during the visitor's traversal.\n */\n\n\n/**\n * A visitor is provided to visit, it contains the collection of\n * relevant functions to be called during the visitor's traversal.\n */\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nexport var QueryDocumentKeys = {\n  Name: [],\n\n  Document: ['definitions'],\n  OperationDefinition: ['name', 'variableDefinitions', 'directives', 'selectionSet'],\n  VariableDefinition: ['variable', 'type', 'defaultValue'],\n  Variable: ['name'],\n  SelectionSet: ['selections'],\n  Field: ['alias', 'name', 'arguments', 'directives', 'selectionSet'],\n  Argument: ['name', 'value'],\n\n  FragmentSpread: ['name', 'directives'],\n  InlineFragment: ['typeCondition', 'directives', 'selectionSet'],\n  FragmentDefinition: ['name',\n  // Note: fragment variable definitions are experimental and may be changed\n  // or removed in the future.\n  'variableDefinitions', 'typeCondition', 'directives', 'selectionSet'],\n\n  IntValue: [],\n  FloatValue: [],\n  StringValue: [],\n  BooleanValue: [],\n  NullValue: [],\n  EnumValue: [],\n  ListValue: ['values'],\n  ObjectValue: ['fields'],\n  ObjectField: ['name', 'value'],\n\n  Directive: ['name', 'arguments'],\n\n  NamedType: ['name'],\n  ListType: ['type'],\n  NonNullType: ['type'],\n\n  SchemaDefinition: ['directives', 'operationTypes'],\n  OperationTypeDefinition: ['type'],\n\n  ScalarTypeDefinition: ['description', 'name', 'directives'],\n  ObjectTypeDefinition: ['description', 'name', 'interfaces', 'directives', 'fields'],\n  FieldDefinition: ['description', 'name', 'arguments', 'type', 'directives'],\n  InputValueDefinition: ['description', 'name', 'type', 'defaultValue', 'directives'],\n  InterfaceTypeDefinition: ['description', 'name', 'directives', 'fields'],\n  UnionTypeDefinition: ['description', 'name', 'directives', 'types'],\n  EnumTypeDefinition: ['description', 'name', 'directives', 'values'],\n  EnumValueDefinition: ['description', 'name', 'directives'],\n  InputObjectTypeDefinition: ['description', 'name', 'directives', 'fields'],\n\n  ScalarTypeExtension: ['name', 'directives'],\n  ObjectTypeExtension: ['name', 'interfaces', 'directives', 'fields'],\n  InterfaceTypeExtension: ['name', 'directives', 'fields'],\n  UnionTypeExtension: ['name', 'directives', 'types'],\n  EnumTypeExtension: ['name', 'directives', 'values'],\n  InputObjectTypeExtension: ['name', 'directives', 'fields'],\n\n  DirectiveDefinition: ['description', 'name', 'arguments', 'locations']\n};\n\n/**\n * A KeyMap describes each the traversable properties of each kind of node.\n */\n\n\nexport var BREAK = {};\n\n/**\n * visit() will walk through an AST using a depth first traversal, calling\n * the visitor's enter function at each node in the traversal, and calling the\n * leave function after visiting that node and all of its child nodes.\n *\n * By returning different values from the enter and leave functions, the\n * behavior of the visitor can be altered, including skipping over a sub-tree of\n * the AST (by returning false), editing the AST by returning a value or null\n * to remove the value, or to stop the whole traversal by returning BREAK.\n *\n * When using visit() to edit an AST, the original AST will not be modified, and\n * a new version of the AST with the changes applied will be returned from the\n * visit function.\n *\n *     const editedAST = visit(ast, {\n *       enter(node, key, parent, path, ancestors) {\n *         // @return\n *         //   undefined: no action\n *         //   false: skip visiting this node\n *         //   visitor.BREAK: stop visiting altogether\n *         //   null: delete this node\n *         //   any value: replace this node with the returned value\n *       },\n *       leave(node, key, parent, path, ancestors) {\n *         // @return\n *         //   undefined: no action\n *         //   false: no action\n *         //   visitor.BREAK: stop visiting altogether\n *         //   null: delete this node\n *         //   any value: replace this node with the returned value\n *       }\n *     });\n *\n * Alternatively to providing enter() and leave() functions, a visitor can\n * instead provide functions named the same as the kinds of AST nodes, or\n * enter/leave visitors at a named key, leading to four permutations of\n * visitor API:\n *\n * 1) Named visitors triggered when entering a node a specific kind.\n *\n *     visit(ast, {\n *       Kind(node) {\n *         // enter the \"Kind\" node\n *       }\n *     })\n *\n * 2) Named visitors that trigger upon entering and leaving a node of\n *    a specific kind.\n *\n *     visit(ast, {\n *       Kind: {\n *         enter(node) {\n *           // enter the \"Kind\" node\n *         }\n *         leave(node) {\n *           // leave the \"Kind\" node\n *         }\n *       }\n *     })\n *\n * 3) Generic visitors that trigger upon entering and leaving any node.\n *\n *     visit(ast, {\n *       enter(node) {\n *         // enter any node\n *       },\n *       leave(node) {\n *         // leave any node\n *       }\n *     })\n *\n * 4) Parallel visitors for entering and leaving nodes of a specific kind.\n *\n *     visit(ast, {\n *       enter: {\n *         Kind(node) {\n *           // enter the \"Kind\" node\n *         }\n *       },\n *       leave: {\n *         Kind(node) {\n *           // leave the \"Kind\" node\n *         }\n *       }\n *     })\n */\nexport function visit(root, visitor) {\n  var visitorKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : QueryDocumentKeys;\n\n  /* eslint-disable no-undef-init */\n  var stack = undefined;\n  var inArray = Array.isArray(root);\n  var keys = [root];\n  var index = -1;\n  var edits = [];\n  var node = undefined;\n  var key = undefined;\n  var parent = undefined;\n  var path = [];\n  var ancestors = [];\n  var newRoot = root;\n  /* eslint-enable no-undef-init */\n\n  do {\n    index++;\n    var isLeaving = index === keys.length;\n    var isEdited = isLeaving && edits.length !== 0;\n    if (isLeaving) {\n      key = ancestors.length === 0 ? undefined : path[path.length - 1];\n      node = parent;\n      parent = ancestors.pop();\n      if (isEdited) {\n        if (inArray) {\n          node = node.slice();\n        } else {\n          var clone = {};\n          for (var k in node) {\n            if (node.hasOwnProperty(k)) {\n              clone[k] = node[k];\n            }\n          }\n          node = clone;\n        }\n        var editOffset = 0;\n        for (var ii = 0; ii < edits.length; ii++) {\n          var editKey = edits[ii][0];\n          var editValue = edits[ii][1];\n          if (inArray) {\n            editKey -= editOffset;\n          }\n          if (inArray && editValue === null) {\n            node.splice(editKey, 1);\n            editOffset++;\n          } else {\n            node[editKey] = editValue;\n          }\n        }\n      }\n      index = stack.index;\n      keys = stack.keys;\n      edits = stack.edits;\n      inArray = stack.inArray;\n      stack = stack.prev;\n    } else {\n      key = parent ? inArray ? index : keys[index] : undefined;\n      node = parent ? parent[key] : newRoot;\n      if (node === null || node === undefined) {\n        continue;\n      }\n      if (parent) {\n        path.push(key);\n      }\n    }\n\n    var result = void 0;\n    if (!Array.isArray(node)) {\n      if (!isNode(node)) {\n        throw new Error('Invalid AST Node: ' + JSON.stringify(node));\n      }\n      var visitFn = getVisitFn(visitor, node.kind, isLeaving);\n      if (visitFn) {\n        result = visitFn.call(visitor, node, key, parent, path, ancestors);\n\n        if (result === BREAK) {\n          break;\n        }\n\n        if (result === false) {\n          if (!isLeaving) {\n            path.pop();\n            continue;\n          }\n        } else if (result !== undefined) {\n          edits.push([key, result]);\n          if (!isLeaving) {\n            if (isNode(result)) {\n              node = result;\n            } else {\n              path.pop();\n              continue;\n            }\n          }\n        }\n      }\n    }\n\n    if (result === undefined && isEdited) {\n      edits.push([key, node]);\n    }\n\n    if (isLeaving) {\n      path.pop();\n    } else {\n      stack = { inArray: inArray, index: index, keys: keys, edits: edits, prev: stack };\n      inArray = Array.isArray(node);\n      keys = inArray ? node : visitorKeys[node.kind] || [];\n      index = -1;\n      edits = [];\n      if (parent) {\n        ancestors.push(parent);\n      }\n      parent = node;\n    }\n  } while (stack !== undefined);\n\n  if (edits.length !== 0) {\n    newRoot = edits[edits.length - 1][1];\n  }\n\n  return newRoot;\n}\n\nfunction isNode(maybeNode) {\n  return Boolean(maybeNode && typeof maybeNode.kind === 'string');\n}\n\n/**\n * Creates a new visitor instance which delegates to many visitors to run in\n * parallel. Each visitor will be visited for each node before moving on.\n *\n * If a prior visitor edits a node, no following visitors will see that node.\n */\nexport function visitInParallel(visitors) {\n  var skipping = new Array(visitors.length);\n\n  return {\n    enter: function enter(node) {\n      for (var i = 0; i < visitors.length; i++) {\n        if (!skipping[i]) {\n          var fn = getVisitFn(visitors[i], node.kind, /* isLeaving */false);\n          if (fn) {\n            var result = fn.apply(visitors[i], arguments);\n            if (result === false) {\n              skipping[i] = node;\n            } else if (result === BREAK) {\n              skipping[i] = BREAK;\n            } else if (result !== undefined) {\n              return result;\n            }\n          }\n        }\n      }\n    },\n    leave: function leave(node) {\n      for (var i = 0; i < visitors.length; i++) {\n        if (!skipping[i]) {\n          var fn = getVisitFn(visitors[i], node.kind, /* isLeaving */true);\n          if (fn) {\n            var result = fn.apply(visitors[i], arguments);\n            if (result === BREAK) {\n              skipping[i] = BREAK;\n            } else if (result !== undefined && result !== false) {\n              return result;\n            }\n          }\n        } else if (skipping[i] === node) {\n          skipping[i] = null;\n        }\n      }\n    }\n  };\n}\n\n/**\n * Creates a new visitor instance which maintains a provided TypeInfo instance\n * along with visiting visitor.\n */\nexport function visitWithTypeInfo(typeInfo, visitor) {\n  return {\n    enter: function enter(node) {\n      typeInfo.enter(node);\n      var fn = getVisitFn(visitor, node.kind, /* isLeaving */false);\n      if (fn) {\n        var result = fn.apply(visitor, arguments);\n        if (result !== undefined) {\n          typeInfo.leave(node);\n          if (isNode(result)) {\n            typeInfo.enter(result);\n          }\n        }\n        return result;\n      }\n    },\n    leave: function leave(node) {\n      var fn = getVisitFn(visitor, node.kind, /* isLeaving */true);\n      var result = void 0;\n      if (fn) {\n        result = fn.apply(visitor, arguments);\n      }\n      typeInfo.leave(node);\n      return result;\n    }\n  };\n}\n\n/**\n * Given a visitor instance, if it is leaving or not, and a node kind, return\n * the function the visitor runtime should call.\n */\nexport function getVisitFn(visitor, kind, isLeaving) {\n  var kindVisitor = visitor[kind];\n  if (kindVisitor) {\n    if (!isLeaving && typeof kindVisitor === 'function') {\n      // { Kind() {} }\n      return kindVisitor;\n    }\n    var kindSpecificVisitor = isLeaving ? kindVisitor.leave : kindVisitor.enter;\n    if (typeof kindSpecificVisitor === 'function') {\n      // { Kind: { enter() {}, leave() {} } }\n      return kindSpecificVisitor;\n    }\n  } else {\n    var specificVisitor = isLeaving ? visitor.leave : visitor.enter;\n    if (specificVisitor) {\n      if (typeof specificVisitor === 'function') {\n        // { enter() {}, leave() {} }\n        return specificVisitor;\n      }\n      var specificKindVisitor = specificVisitor[kind];\n      if (typeof specificKindVisitor === 'function') {\n        // { enter: { Kind() {} }, leave: { Kind() {} } }\n        return specificKindVisitor;\n      }\n    }\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}