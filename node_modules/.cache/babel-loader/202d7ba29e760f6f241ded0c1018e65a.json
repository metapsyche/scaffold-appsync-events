{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildASTSchema = buildASTSchema;\nexports.getDeprecationReason = getDeprecationReason;\nexports.getDescription = getDescription;\nexports.buildSchema = buildSchema;\n\nvar _invariant = require('../jsutils/invariant');\n\nvar _invariant2 = _interopRequireDefault(_invariant);\n\nvar _keyValMap = require('../jsutils/keyValMap');\n\nvar _keyValMap2 = _interopRequireDefault(_keyValMap);\n\nvar _valueFromAST = require('./valueFromAST');\n\nvar _lexer = require('../language/lexer');\n\nvar _parser = require('../language/parser');\n\nvar _values = require('../execution/values');\n\nvar _kinds = require('../language/kinds');\n\nvar Kind = _interopRequireWildcard(_kinds);\n\nvar _schema = require('../type/schema');\n\nvar _scalars = require('../type/scalars');\n\nvar _definition = require('../type/definition');\n\nvar _directives = require('../type/directives');\n\nvar _introspection = require('../type/introspection');\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\nfunction buildWrappedType(innerType, inputTypeNode) {\n  if (inputTypeNode.kind === Kind.LIST_TYPE) {\n    return new _definition.GraphQLList(buildWrappedType(innerType, inputTypeNode.type));\n  }\n\n  if (inputTypeNode.kind === Kind.NON_NULL_TYPE) {\n    var wrappedType = buildWrappedType(innerType, inputTypeNode.type);\n    !!(wrappedType instanceof _definition.GraphQLNonNull) ? (0, _invariant2.default)(0, 'No nesting nonnull.') : void 0;\n    return new _definition.GraphQLNonNull(wrappedType);\n  }\n\n  return innerType;\n}\n\nfunction getNamedTypeNode(typeNode) {\n  var namedType = typeNode;\n\n  while (namedType.kind === Kind.LIST_TYPE || namedType.kind === Kind.NON_NULL_TYPE) {\n    namedType = namedType.type;\n  }\n\n  return namedType;\n}\n/**\n * This takes the ast of a schema document produced by the parse function in\n * src/language/parser.js.\n *\n * If no schema definition is provided, then it will look for types named Query\n * and Mutation.\n *\n * Given that AST it constructs a GraphQLSchema. The resulting schema\n * has no resolve methods, so execution will use default resolvers.\n */\n\n\nfunction buildASTSchema(ast) {\n  if (!ast || ast.kind !== Kind.DOCUMENT) {\n    throw new Error('Must provide a document ast.');\n  }\n\n  var schemaDef = void 0;\n  var typeDefs = [];\n  var nodeMap = Object.create(null);\n  var directiveDefs = [];\n\n  for (var i = 0; i < ast.definitions.length; i++) {\n    var d = ast.definitions[i];\n\n    switch (d.kind) {\n      case Kind.SCHEMA_DEFINITION:\n        if (schemaDef) {\n          throw new Error('Must provide only one schema definition.');\n        }\n\n        schemaDef = d;\n        break;\n\n      case Kind.SCALAR_TYPE_DEFINITION:\n      case Kind.OBJECT_TYPE_DEFINITION:\n      case Kind.INTERFACE_TYPE_DEFINITION:\n      case Kind.ENUM_TYPE_DEFINITION:\n      case Kind.UNION_TYPE_DEFINITION:\n      case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n        var typeName = d.name.value;\n\n        if (nodeMap[typeName]) {\n          throw new Error('Type \"' + typeName + '\" was defined more than once.');\n        }\n\n        typeDefs.push(d);\n        nodeMap[typeName] = d;\n        break;\n\n      case Kind.DIRECTIVE_DEFINITION:\n        directiveDefs.push(d);\n        break;\n    }\n  }\n\n  var queryTypeName = void 0;\n  var mutationTypeName = void 0;\n  var subscriptionTypeName = void 0;\n\n  if (schemaDef) {\n    schemaDef.operationTypes.forEach(function (operationType) {\n      var typeName = operationType.type.name.value;\n\n      if (operationType.operation === 'query') {\n        if (queryTypeName) {\n          throw new Error('Must provide only one query type in schema.');\n        }\n\n        if (!nodeMap[typeName]) {\n          throw new Error('Specified query type \"' + typeName + '\" not found in document.');\n        }\n\n        queryTypeName = typeName;\n      } else if (operationType.operation === 'mutation') {\n        if (mutationTypeName) {\n          throw new Error('Must provide only one mutation type in schema.');\n        }\n\n        if (!nodeMap[typeName]) {\n          throw new Error('Specified mutation type \"' + typeName + '\" not found in document.');\n        }\n\n        mutationTypeName = typeName;\n      } else if (operationType.operation === 'subscription') {\n        if (subscriptionTypeName) {\n          throw new Error('Must provide only one subscription type in schema.');\n        }\n\n        if (!nodeMap[typeName]) {\n          throw new Error('Specified subscription type \"' + typeName + '\" not found in document.');\n        }\n\n        subscriptionTypeName = typeName;\n      }\n    });\n  } else {\n    if (nodeMap.Query) {\n      queryTypeName = 'Query';\n    }\n\n    if (nodeMap.Mutation) {\n      mutationTypeName = 'Mutation';\n    }\n\n    if (nodeMap.Subscription) {\n      subscriptionTypeName = 'Subscription';\n    }\n  }\n\n  if (!queryTypeName) {\n    throw new Error('Must provide schema definition with query type or a type named Query.');\n  }\n\n  var innerTypeMap = {\n    String: _scalars.GraphQLString,\n    Int: _scalars.GraphQLInt,\n    Float: _scalars.GraphQLFloat,\n    Boolean: _scalars.GraphQLBoolean,\n    ID: _scalars.GraphQLID,\n    __Schema: _introspection.__Schema,\n    __Directive: _introspection.__Directive,\n    __DirectiveLocation: _introspection.__DirectiveLocation,\n    __Type: _introspection.__Type,\n    __Field: _introspection.__Field,\n    __InputValue: _introspection.__InputValue,\n    __EnumValue: _introspection.__EnumValue,\n    __TypeKind: _introspection.__TypeKind\n  };\n  var types = typeDefs.map(function (def) {\n    return typeDefNamed(def.name.value);\n  });\n  var directives = directiveDefs.map(getDirective); // If specified directives were not explicitly declared, add them.\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'skip';\n  })) {\n    directives.push(_directives.GraphQLSkipDirective);\n  }\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'include';\n  })) {\n    directives.push(_directives.GraphQLIncludeDirective);\n  }\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'deprecated';\n  })) {\n    directives.push(_directives.GraphQLDeprecatedDirective);\n  }\n\n  return new _schema.GraphQLSchema({\n    query: getObjectType(nodeMap[queryTypeName]),\n    mutation: mutationTypeName ? getObjectType(nodeMap[mutationTypeName]) : null,\n    subscription: subscriptionTypeName ? getObjectType(nodeMap[subscriptionTypeName]) : null,\n    types: types,\n    directives: directives,\n    astNode: schemaDef\n  });\n\n  function getDirective(directiveNode) {\n    return new _directives.GraphQLDirective({\n      name: directiveNode.name.value,\n      description: getDescription(directiveNode),\n      locations: directiveNode.locations.map(function (node) {\n        return node.value;\n      }),\n      args: directiveNode.arguments && makeInputValues(directiveNode.arguments),\n      astNode: directiveNode\n    });\n  }\n\n  function getObjectType(typeNode) {\n    var type = typeDefNamed(typeNode.name.value);\n    !(type instanceof _definition.GraphQLObjectType) ? (0, _invariant2.default)(0, 'AST must provide object type.') : void 0;\n    return type;\n  }\n\n  function produceType(typeNode) {\n    var typeName = getNamedTypeNode(typeNode).name.value;\n    var typeDef = typeDefNamed(typeName);\n    return buildWrappedType(typeDef, typeNode);\n  }\n\n  function produceInputType(typeNode) {\n    return (0, _definition.assertInputType)(produceType(typeNode));\n  }\n\n  function produceOutputType(typeNode) {\n    return (0, _definition.assertOutputType)(produceType(typeNode));\n  }\n\n  function produceObjectType(typeNode) {\n    var type = produceType(typeNode);\n    !(type instanceof _definition.GraphQLObjectType) ? (0, _invariant2.default)(0, 'Expected Object type.') : void 0;\n    return type;\n  }\n\n  function produceInterfaceType(typeNode) {\n    var type = produceType(typeNode);\n    !(type instanceof _definition.GraphQLInterfaceType) ? (0, _invariant2.default)(0, 'Expected Interface type.') : void 0;\n    return type;\n  }\n\n  function typeDefNamed(typeName) {\n    if (!innerTypeMap[typeName]) {\n      if (!nodeMap[typeName]) {\n        throw new Error('Type \"' + typeName + '\" not found in document.');\n      }\n\n      innerTypeMap[typeName] = makeSchemaDef(nodeMap[typeName]);\n    }\n\n    return innerTypeMap[typeName];\n  }\n\n  function makeSchemaDef(def) {\n    switch (def.kind) {\n      case Kind.OBJECT_TYPE_DEFINITION:\n        return makeTypeDef(def);\n\n      case Kind.INTERFACE_TYPE_DEFINITION:\n        return makeInterfaceDef(def);\n\n      case Kind.ENUM_TYPE_DEFINITION:\n        return makeEnumDef(def);\n\n      case Kind.UNION_TYPE_DEFINITION:\n        return makeUnionDef(def);\n\n      case Kind.SCALAR_TYPE_DEFINITION:\n        return makeScalarDef(def);\n\n      case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n        return makeInputObjectDef(def);\n\n      default:\n        throw new Error('Type kind \"' + def.kind + '\" not supported.');\n    }\n  }\n\n  function makeTypeDef(def) {\n    var typeName = def.name.value;\n    return new _definition.GraphQLObjectType({\n      name: typeName,\n      description: getDescription(def),\n      fields: function fields() {\n        return makeFieldDefMap(def);\n      },\n      interfaces: function interfaces() {\n        return makeImplementedInterfaces(def);\n      },\n      astNode: def\n    });\n  }\n\n  function makeFieldDefMap(def) {\n    return (0, _keyValMap2.default)(def.fields, function (field) {\n      return field.name.value;\n    }, function (field) {\n      return {\n        type: produceOutputType(field.type),\n        description: getDescription(field),\n        args: makeInputValues(field.arguments),\n        deprecationReason: getDeprecationReason(field),\n        astNode: field\n      };\n    });\n  }\n\n  function makeImplementedInterfaces(def) {\n    return def.interfaces && def.interfaces.map(function (iface) {\n      return produceInterfaceType(iface);\n    });\n  }\n\n  function makeInputValues(values) {\n    return (0, _keyValMap2.default)(values, function (value) {\n      return value.name.value;\n    }, function (value) {\n      var type = produceInputType(value.type);\n      return {\n        type: type,\n        description: getDescription(value),\n        defaultValue: (0, _valueFromAST.valueFromAST)(value.defaultValue, type),\n        astNode: value\n      };\n    });\n  }\n\n  function makeInterfaceDef(def) {\n    return new _definition.GraphQLInterfaceType({\n      name: def.name.value,\n      description: getDescription(def),\n      fields: function fields() {\n        return makeFieldDefMap(def);\n      },\n      astNode: def,\n      resolveType: cannotExecuteSchema\n    });\n  }\n\n  function makeEnumDef(def) {\n    return new _definition.GraphQLEnumType({\n      name: def.name.value,\n      description: getDescription(def),\n      values: (0, _keyValMap2.default)(def.values, function (enumValue) {\n        return enumValue.name.value;\n      }, function (enumValue) {\n        return {\n          description: getDescription(enumValue),\n          deprecationReason: getDeprecationReason(enumValue),\n          astNode: enumValue\n        };\n      }),\n      astNode: def\n    });\n  }\n\n  function makeUnionDef(def) {\n    return new _definition.GraphQLUnionType({\n      name: def.name.value,\n      description: getDescription(def),\n      types: def.types.map(function (t) {\n        return produceObjectType(t);\n      }),\n      resolveType: cannotExecuteSchema,\n      astNode: def\n    });\n  }\n\n  function makeScalarDef(def) {\n    return new _definition.GraphQLScalarType({\n      name: def.name.value,\n      description: getDescription(def),\n      astNode: def,\n      serialize: function serialize() {\n        return null;\n      },\n      // Note: validation calls the parse functions to determine if a\n      // literal value is correct. Returning null would cause use of custom\n      // scalars to always fail validation. Returning false causes them to\n      // always pass validation.\n      parseValue: function parseValue() {\n        return false;\n      },\n      parseLiteral: function parseLiteral() {\n        return false;\n      }\n    });\n  }\n\n  function makeInputObjectDef(def) {\n    return new _definition.GraphQLInputObjectType({\n      name: def.name.value,\n      description: getDescription(def),\n      fields: function fields() {\n        return makeInputValues(def.fields);\n      },\n      astNode: def\n    });\n  }\n}\n/**\n * Given a field or enum value node, returns the string value for the\n * deprecation reason.\n */\n\n\nfunction getDeprecationReason(node) {\n  var deprecated = (0, _values.getDirectiveValues)(_directives.GraphQLDeprecatedDirective, node);\n  return deprecated && deprecated.reason;\n}\n/**\n * Given an ast node, returns its string description based on a contiguous\n * block full-line of comments preceding it.\n */\n\n\nfunction getDescription(node) {\n  var loc = node.loc;\n\n  if (!loc) {\n    return;\n  }\n\n  var comments = [];\n  var minSpaces = void 0;\n  var token = loc.startToken.prev;\n\n  while (token && token.kind === _lexer.TokenKind.COMMENT && token.next && token.prev && token.line + 1 === token.next.line && token.line !== token.prev.line) {\n    var value = String(token.value);\n    var spaces = leadingSpaces(value);\n\n    if (minSpaces === undefined || spaces < minSpaces) {\n      minSpaces = spaces;\n    }\n\n    comments.push(value);\n    token = token.prev;\n  }\n\n  return comments.reverse().map(function (comment) {\n    return comment.slice(minSpaces);\n  }).join('\\n');\n}\n/**\n * A helper function to build a GraphQLSchema directly from a source\n * document.\n */\n\n\nfunction buildSchema(source) {\n  return buildASTSchema((0, _parser.parse)(source));\n} // Count the number of spaces on the starting side of a string.\n\n\nfunction leadingSpaces(str) {\n  var i = 0;\n\n  for (; i < str.length; i++) {\n    if (str[i] !== ' ') {\n      break;\n    }\n  }\n\n  return i;\n}\n\nfunction cannotExecuteSchema() {\n  throw new Error('Generated Schema cannot use Interface or Union types for execution.');\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","buildASTSchema","getDeprecationReason","getDescription","buildSchema","_invariant","require","_invariant2","_interopRequireDefault","_keyValMap","_keyValMap2","_valueFromAST","_lexer","_parser","_values","_kinds","Kind","_interopRequireWildcard","_schema","_scalars","_definition","_directives","_introspection","obj","__esModule","newObj","key","prototype","hasOwnProperty","call","default","buildWrappedType","innerType","inputTypeNode","kind","LIST_TYPE","GraphQLList","type","NON_NULL_TYPE","wrappedType","GraphQLNonNull","getNamedTypeNode","typeNode","namedType","ast","DOCUMENT","Error","schemaDef","typeDefs","nodeMap","create","directiveDefs","i","definitions","length","d","SCHEMA_DEFINITION","SCALAR_TYPE_DEFINITION","OBJECT_TYPE_DEFINITION","INTERFACE_TYPE_DEFINITION","ENUM_TYPE_DEFINITION","UNION_TYPE_DEFINITION","INPUT_OBJECT_TYPE_DEFINITION","typeName","name","push","DIRECTIVE_DEFINITION","queryTypeName","mutationTypeName","subscriptionTypeName","operationTypes","forEach","operationType","operation","Query","Mutation","Subscription","innerTypeMap","String","GraphQLString","Int","GraphQLInt","Float","GraphQLFloat","Boolean","GraphQLBoolean","ID","GraphQLID","__Schema","__Directive","__DirectiveLocation","__Type","__Field","__InputValue","__EnumValue","__TypeKind","types","map","def","typeDefNamed","directives","getDirective","some","directive","GraphQLSkipDirective","GraphQLIncludeDirective","GraphQLDeprecatedDirective","GraphQLSchema","query","getObjectType","mutation","subscription","astNode","directiveNode","GraphQLDirective","description","locations","node","args","arguments","makeInputValues","GraphQLObjectType","produceType","typeDef","produceInputType","assertInputType","produceOutputType","assertOutputType","produceObjectType","produceInterfaceType","GraphQLInterfaceType","makeSchemaDef","makeTypeDef","makeInterfaceDef","makeEnumDef","makeUnionDef","makeScalarDef","makeInputObjectDef","fields","makeFieldDefMap","interfaces","makeImplementedInterfaces","field","deprecationReason","iface","values","defaultValue","valueFromAST","resolveType","cannotExecuteSchema","GraphQLEnumType","enumValue","GraphQLUnionType","t","GraphQLScalarType","serialize","parseValue","parseLiteral","GraphQLInputObjectType","deprecated","getDirectiveValues","reason","loc","comments","minSpaces","token","startToken","prev","TokenKind","COMMENT","next","line","spaces","leadingSpaces","undefined","reverse","comment","slice","join","source","parse","str"],"sources":["/Users/roaldmaravillas/ro/sandbox/aws-mobile-appsync-events-starter-react/node_modules/graphql/utilities/buildASTSchema.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildASTSchema = buildASTSchema;\nexports.getDeprecationReason = getDeprecationReason;\nexports.getDescription = getDescription;\nexports.buildSchema = buildSchema;\n\nvar _invariant = require('../jsutils/invariant');\n\nvar _invariant2 = _interopRequireDefault(_invariant);\n\nvar _keyValMap = require('../jsutils/keyValMap');\n\nvar _keyValMap2 = _interopRequireDefault(_keyValMap);\n\nvar _valueFromAST = require('./valueFromAST');\n\nvar _lexer = require('../language/lexer');\n\nvar _parser = require('../language/parser');\n\nvar _values = require('../execution/values');\n\nvar _kinds = require('../language/kinds');\n\nvar Kind = _interopRequireWildcard(_kinds);\n\nvar _schema = require('../type/schema');\n\nvar _scalars = require('../type/scalars');\n\nvar _definition = require('../type/definition');\n\nvar _directives = require('../type/directives');\n\nvar _introspection = require('../type/introspection');\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nfunction buildWrappedType(innerType, inputTypeNode) {\n  if (inputTypeNode.kind === Kind.LIST_TYPE) {\n    return new _definition.GraphQLList(buildWrappedType(innerType, inputTypeNode.type));\n  }\n  if (inputTypeNode.kind === Kind.NON_NULL_TYPE) {\n    var wrappedType = buildWrappedType(innerType, inputTypeNode.type);\n    !!(wrappedType instanceof _definition.GraphQLNonNull) ? (0, _invariant2.default)(0, 'No nesting nonnull.') : void 0;\n    return new _definition.GraphQLNonNull(wrappedType);\n  }\n  return innerType;\n}\n\nfunction getNamedTypeNode(typeNode) {\n  var namedType = typeNode;\n  while (namedType.kind === Kind.LIST_TYPE || namedType.kind === Kind.NON_NULL_TYPE) {\n    namedType = namedType.type;\n  }\n  return namedType;\n}\n\n/**\n * This takes the ast of a schema document produced by the parse function in\n * src/language/parser.js.\n *\n * If no schema definition is provided, then it will look for types named Query\n * and Mutation.\n *\n * Given that AST it constructs a GraphQLSchema. The resulting schema\n * has no resolve methods, so execution will use default resolvers.\n */\nfunction buildASTSchema(ast) {\n  if (!ast || ast.kind !== Kind.DOCUMENT) {\n    throw new Error('Must provide a document ast.');\n  }\n\n  var schemaDef = void 0;\n\n  var typeDefs = [];\n  var nodeMap = Object.create(null);\n  var directiveDefs = [];\n  for (var i = 0; i < ast.definitions.length; i++) {\n    var d = ast.definitions[i];\n    switch (d.kind) {\n      case Kind.SCHEMA_DEFINITION:\n        if (schemaDef) {\n          throw new Error('Must provide only one schema definition.');\n        }\n        schemaDef = d;\n        break;\n      case Kind.SCALAR_TYPE_DEFINITION:\n      case Kind.OBJECT_TYPE_DEFINITION:\n      case Kind.INTERFACE_TYPE_DEFINITION:\n      case Kind.ENUM_TYPE_DEFINITION:\n      case Kind.UNION_TYPE_DEFINITION:\n      case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n        var typeName = d.name.value;\n        if (nodeMap[typeName]) {\n          throw new Error('Type \"' + typeName + '\" was defined more than once.');\n        }\n        typeDefs.push(d);\n        nodeMap[typeName] = d;\n        break;\n      case Kind.DIRECTIVE_DEFINITION:\n        directiveDefs.push(d);\n        break;\n    }\n  }\n\n  var queryTypeName = void 0;\n  var mutationTypeName = void 0;\n  var subscriptionTypeName = void 0;\n  if (schemaDef) {\n    schemaDef.operationTypes.forEach(function (operationType) {\n      var typeName = operationType.type.name.value;\n      if (operationType.operation === 'query') {\n        if (queryTypeName) {\n          throw new Error('Must provide only one query type in schema.');\n        }\n        if (!nodeMap[typeName]) {\n          throw new Error('Specified query type \"' + typeName + '\" not found in document.');\n        }\n        queryTypeName = typeName;\n      } else if (operationType.operation === 'mutation') {\n        if (mutationTypeName) {\n          throw new Error('Must provide only one mutation type in schema.');\n        }\n        if (!nodeMap[typeName]) {\n          throw new Error('Specified mutation type \"' + typeName + '\" not found in document.');\n        }\n        mutationTypeName = typeName;\n      } else if (operationType.operation === 'subscription') {\n        if (subscriptionTypeName) {\n          throw new Error('Must provide only one subscription type in schema.');\n        }\n        if (!nodeMap[typeName]) {\n          throw new Error('Specified subscription type \"' + typeName + '\" not found in document.');\n        }\n        subscriptionTypeName = typeName;\n      }\n    });\n  } else {\n    if (nodeMap.Query) {\n      queryTypeName = 'Query';\n    }\n    if (nodeMap.Mutation) {\n      mutationTypeName = 'Mutation';\n    }\n    if (nodeMap.Subscription) {\n      subscriptionTypeName = 'Subscription';\n    }\n  }\n\n  if (!queryTypeName) {\n    throw new Error('Must provide schema definition with query type or a type named Query.');\n  }\n\n  var innerTypeMap = {\n    String: _scalars.GraphQLString,\n    Int: _scalars.GraphQLInt,\n    Float: _scalars.GraphQLFloat,\n    Boolean: _scalars.GraphQLBoolean,\n    ID: _scalars.GraphQLID,\n    __Schema: _introspection.__Schema,\n    __Directive: _introspection.__Directive,\n    __DirectiveLocation: _introspection.__DirectiveLocation,\n    __Type: _introspection.__Type,\n    __Field: _introspection.__Field,\n    __InputValue: _introspection.__InputValue,\n    __EnumValue: _introspection.__EnumValue,\n    __TypeKind: _introspection.__TypeKind\n  };\n\n  var types = typeDefs.map(function (def) {\n    return typeDefNamed(def.name.value);\n  });\n\n  var directives = directiveDefs.map(getDirective);\n\n  // If specified directives were not explicitly declared, add them.\n  if (!directives.some(function (directive) {\n    return directive.name === 'skip';\n  })) {\n    directives.push(_directives.GraphQLSkipDirective);\n  }\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'include';\n  })) {\n    directives.push(_directives.GraphQLIncludeDirective);\n  }\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'deprecated';\n  })) {\n    directives.push(_directives.GraphQLDeprecatedDirective);\n  }\n\n  return new _schema.GraphQLSchema({\n    query: getObjectType(nodeMap[queryTypeName]),\n    mutation: mutationTypeName ? getObjectType(nodeMap[mutationTypeName]) : null,\n    subscription: subscriptionTypeName ? getObjectType(nodeMap[subscriptionTypeName]) : null,\n    types: types,\n    directives: directives,\n    astNode: schemaDef\n  });\n\n  function getDirective(directiveNode) {\n    return new _directives.GraphQLDirective({\n      name: directiveNode.name.value,\n      description: getDescription(directiveNode),\n      locations: directiveNode.locations.map(function (node) {\n        return node.value;\n      }),\n      args: directiveNode.arguments && makeInputValues(directiveNode.arguments),\n      astNode: directiveNode\n    });\n  }\n\n  function getObjectType(typeNode) {\n    var type = typeDefNamed(typeNode.name.value);\n    !(type instanceof _definition.GraphQLObjectType) ? (0, _invariant2.default)(0, 'AST must provide object type.') : void 0;\n    return type;\n  }\n\n  function produceType(typeNode) {\n    var typeName = getNamedTypeNode(typeNode).name.value;\n    var typeDef = typeDefNamed(typeName);\n    return buildWrappedType(typeDef, typeNode);\n  }\n\n  function produceInputType(typeNode) {\n    return (0, _definition.assertInputType)(produceType(typeNode));\n  }\n\n  function produceOutputType(typeNode) {\n    return (0, _definition.assertOutputType)(produceType(typeNode));\n  }\n\n  function produceObjectType(typeNode) {\n    var type = produceType(typeNode);\n    !(type instanceof _definition.GraphQLObjectType) ? (0, _invariant2.default)(0, 'Expected Object type.') : void 0;\n    return type;\n  }\n\n  function produceInterfaceType(typeNode) {\n    var type = produceType(typeNode);\n    !(type instanceof _definition.GraphQLInterfaceType) ? (0, _invariant2.default)(0, 'Expected Interface type.') : void 0;\n    return type;\n  }\n\n  function typeDefNamed(typeName) {\n    if (!innerTypeMap[typeName]) {\n      if (!nodeMap[typeName]) {\n        throw new Error('Type \"' + typeName + '\" not found in document.');\n      }\n      innerTypeMap[typeName] = makeSchemaDef(nodeMap[typeName]);\n    }\n    return innerTypeMap[typeName];\n  }\n\n  function makeSchemaDef(def) {\n    switch (def.kind) {\n      case Kind.OBJECT_TYPE_DEFINITION:\n        return makeTypeDef(def);\n      case Kind.INTERFACE_TYPE_DEFINITION:\n        return makeInterfaceDef(def);\n      case Kind.ENUM_TYPE_DEFINITION:\n        return makeEnumDef(def);\n      case Kind.UNION_TYPE_DEFINITION:\n        return makeUnionDef(def);\n      case Kind.SCALAR_TYPE_DEFINITION:\n        return makeScalarDef(def);\n      case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n        return makeInputObjectDef(def);\n      default:\n        throw new Error('Type kind \"' + def.kind + '\" not supported.');\n    }\n  }\n\n  function makeTypeDef(def) {\n    var typeName = def.name.value;\n    return new _definition.GraphQLObjectType({\n      name: typeName,\n      description: getDescription(def),\n      fields: function fields() {\n        return makeFieldDefMap(def);\n      },\n      interfaces: function interfaces() {\n        return makeImplementedInterfaces(def);\n      },\n      astNode: def\n    });\n  }\n\n  function makeFieldDefMap(def) {\n    return (0, _keyValMap2.default)(def.fields, function (field) {\n      return field.name.value;\n    }, function (field) {\n      return {\n        type: produceOutputType(field.type),\n        description: getDescription(field),\n        args: makeInputValues(field.arguments),\n        deprecationReason: getDeprecationReason(field),\n        astNode: field\n      };\n    });\n  }\n\n  function makeImplementedInterfaces(def) {\n    return def.interfaces && def.interfaces.map(function (iface) {\n      return produceInterfaceType(iface);\n    });\n  }\n\n  function makeInputValues(values) {\n    return (0, _keyValMap2.default)(values, function (value) {\n      return value.name.value;\n    }, function (value) {\n      var type = produceInputType(value.type);\n      return {\n        type: type,\n        description: getDescription(value),\n        defaultValue: (0, _valueFromAST.valueFromAST)(value.defaultValue, type),\n        astNode: value\n      };\n    });\n  }\n\n  function makeInterfaceDef(def) {\n    return new _definition.GraphQLInterfaceType({\n      name: def.name.value,\n      description: getDescription(def),\n      fields: function fields() {\n        return makeFieldDefMap(def);\n      },\n      astNode: def,\n      resolveType: cannotExecuteSchema\n    });\n  }\n\n  function makeEnumDef(def) {\n    return new _definition.GraphQLEnumType({\n      name: def.name.value,\n      description: getDescription(def),\n      values: (0, _keyValMap2.default)(def.values, function (enumValue) {\n        return enumValue.name.value;\n      }, function (enumValue) {\n        return {\n          description: getDescription(enumValue),\n          deprecationReason: getDeprecationReason(enumValue),\n          astNode: enumValue\n        };\n      }),\n      astNode: def\n    });\n  }\n\n  function makeUnionDef(def) {\n    return new _definition.GraphQLUnionType({\n      name: def.name.value,\n      description: getDescription(def),\n      types: def.types.map(function (t) {\n        return produceObjectType(t);\n      }),\n      resolveType: cannotExecuteSchema,\n      astNode: def\n    });\n  }\n\n  function makeScalarDef(def) {\n    return new _definition.GraphQLScalarType({\n      name: def.name.value,\n      description: getDescription(def),\n      astNode: def,\n      serialize: function serialize() {\n        return null;\n      },\n      // Note: validation calls the parse functions to determine if a\n      // literal value is correct. Returning null would cause use of custom\n      // scalars to always fail validation. Returning false causes them to\n      // always pass validation.\n      parseValue: function parseValue() {\n        return false;\n      },\n      parseLiteral: function parseLiteral() {\n        return false;\n      }\n    });\n  }\n\n  function makeInputObjectDef(def) {\n    return new _definition.GraphQLInputObjectType({\n      name: def.name.value,\n      description: getDescription(def),\n      fields: function fields() {\n        return makeInputValues(def.fields);\n      },\n      astNode: def\n    });\n  }\n}\n\n/**\n * Given a field or enum value node, returns the string value for the\n * deprecation reason.\n */\nfunction getDeprecationReason(node) {\n  var deprecated = (0, _values.getDirectiveValues)(_directives.GraphQLDeprecatedDirective, node);\n  return deprecated && deprecated.reason;\n}\n\n/**\n * Given an ast node, returns its string description based on a contiguous\n * block full-line of comments preceding it.\n */\nfunction getDescription(node) {\n  var loc = node.loc;\n  if (!loc) {\n    return;\n  }\n  var comments = [];\n  var minSpaces = void 0;\n  var token = loc.startToken.prev;\n  while (token && token.kind === _lexer.TokenKind.COMMENT && token.next && token.prev && token.line + 1 === token.next.line && token.line !== token.prev.line) {\n    var value = String(token.value);\n    var spaces = leadingSpaces(value);\n    if (minSpaces === undefined || spaces < minSpaces) {\n      minSpaces = spaces;\n    }\n    comments.push(value);\n    token = token.prev;\n  }\n  return comments.reverse().map(function (comment) {\n    return comment.slice(minSpaces);\n  }).join('\\n');\n}\n\n/**\n * A helper function to build a GraphQLSchema directly from a source\n * document.\n */\nfunction buildSchema(source) {\n  return buildASTSchema((0, _parser.parse)(source));\n}\n\n// Count the number of spaces on the starting side of a string.\nfunction leadingSpaces(str) {\n  var i = 0;\n  for (; i < str.length; i++) {\n    if (str[i] !== ' ') {\n      break;\n    }\n  }\n  return i;\n}\n\nfunction cannotExecuteSchema() {\n  throw new Error('Generated Schema cannot use Interface or Union types for execution.');\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}