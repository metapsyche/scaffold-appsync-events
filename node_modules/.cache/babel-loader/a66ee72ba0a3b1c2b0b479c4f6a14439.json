{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nimport { ApolloLink, Observable } from 'apollo-link';\nimport { buildDelayFunction } from './delayFunction';\nimport { buildRetryFunction } from './retryFunction';\n/**\n * Tracking and management of operations that may be (or currently are) retried.\n */\n\nvar RetryableOperation =\n/** @class */\nfunction () {\n  function RetryableOperation(operation, nextLink, delayFor, retryIf) {\n    var _this = this;\n\n    this.operation = operation;\n    this.nextLink = nextLink;\n    this.delayFor = delayFor;\n    this.retryIf = retryIf;\n    this.retryCount = 0;\n    this.values = [];\n    this.complete = false;\n    this.canceled = false;\n    this.observers = [];\n    this.currentSubscription = null;\n\n    this.onNext = function (value) {\n      _this.values.push(value);\n\n      for (var _i = 0, _a = _this.observers; _i < _a.length; _i++) {\n        var observer = _a[_i];\n        if (!observer) continue;\n        observer.next(value);\n      }\n    };\n\n    this.onComplete = function () {\n      _this.complete = true;\n\n      for (var _i = 0, _a = _this.observers; _i < _a.length; _i++) {\n        var observer = _a[_i];\n        if (!observer) continue;\n        observer.complete();\n      }\n    };\n\n    this.onError = function (error) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var shouldRetry, _i, _a, observer;\n\n        return __generator(this, function (_b) {\n          switch (_b.label) {\n            case 0:\n              this.retryCount += 1;\n              return [4\n              /*yield*/\n              , this.retryIf(this.retryCount, this.operation, error)];\n\n            case 1:\n              shouldRetry = _b.sent();\n\n              if (shouldRetry) {\n                this.scheduleRetry(this.delayFor(this.retryCount, this.operation, error));\n                return [2\n                /*return*/\n                ];\n              }\n\n              this.error = error;\n\n              for (_i = 0, _a = this.observers; _i < _a.length; _i++) {\n                observer = _a[_i];\n                if (!observer) continue;\n                observer.error(error);\n              }\n\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    };\n  }\n  /**\n   * Register a new observer for this operation.\n   *\n   * If the operation has previously emitted other events, they will be\n   * immediately triggered for the observer.\n   */\n\n\n  RetryableOperation.prototype.subscribe = function (observer) {\n    if (this.canceled) {\n      throw new Error(\"Subscribing to a retryable link that was canceled is not supported\");\n    }\n\n    this.observers.push(observer); // If we've already begun, catch this observer up.\n\n    for (var _i = 0, _a = this.values; _i < _a.length; _i++) {\n      var value = _a[_i];\n      observer.next(value);\n    }\n\n    if (this.complete) {\n      observer.complete();\n    } else if (this.error) {\n      observer.error(this.error);\n    }\n  };\n  /**\n   * Remove a previously registered observer from this operation.\n   *\n   * If no observers remain, the operation will stop retrying, and unsubscribe\n   * from its downstream link.\n   */\n\n\n  RetryableOperation.prototype.unsubscribe = function (observer) {\n    var index = this.observers.indexOf(observer);\n\n    if (index < 0) {\n      throw new Error(\"RetryLink BUG! Attempting to unsubscribe unknown observer!\");\n    } // Note that we are careful not to change the order of length of the array,\n    // as we are often mid-iteration when calling this method.\n\n\n    this.observers[index] = null; // If this is the last observer, we're done.\n\n    if (this.observers.every(function (o) {\n      return o === null;\n    })) {\n      this.cancel();\n    }\n  };\n  /**\n   * Start the initial request.\n   */\n\n\n  RetryableOperation.prototype.start = function () {\n    if (this.currentSubscription) return; // Already started.\n\n    this.try();\n  };\n  /**\n   * Stop retrying for the operation, and cancel any in-progress requests.\n   */\n\n\n  RetryableOperation.prototype.cancel = function () {\n    if (this.currentSubscription) {\n      this.currentSubscription.unsubscribe();\n    }\n\n    clearTimeout(this.timerId);\n    this.timerId = null;\n    this.currentSubscription = null;\n    this.canceled = true;\n  };\n\n  RetryableOperation.prototype.try = function () {\n    this.currentSubscription = this.nextLink(this.operation).subscribe({\n      next: this.onNext,\n      error: this.onError,\n      complete: this.onComplete\n    });\n  };\n\n  RetryableOperation.prototype.scheduleRetry = function (delay) {\n    var _this = this;\n\n    if (this.timerId) {\n      throw new Error(\"RetryLink BUG! Encountered overlapping retries\");\n    }\n\n    this.timerId = setTimeout(function () {\n      _this.timerId = null;\n\n      _this.try();\n    }, delay);\n  };\n\n  return RetryableOperation;\n}();\n\nvar RetryLink =\n/** @class */\nfunction (_super) {\n  __extends(RetryLink, _super);\n\n  function RetryLink(_a) {\n    var _b = _a === void 0 ? {} : _a,\n        delay = _b.delay,\n        attempts = _b.attempts;\n\n    var _this = _super.call(this) || this;\n\n    _this.delayFor = typeof delay === 'function' ? delay : buildDelayFunction(delay);\n    _this.retryIf = typeof attempts === 'function' ? attempts : buildRetryFunction(attempts);\n    return _this;\n  }\n\n  RetryLink.prototype.request = function (operation, nextLink) {\n    var retryable = new RetryableOperation(operation, nextLink, this.delayFor, this.retryIf);\n    retryable.start();\n    return new Observable(function (observer) {\n      retryable.subscribe(observer);\n      return function () {\n        retryable.unsubscribe(observer);\n      };\n    });\n  };\n\n  return RetryLink;\n}(ApolloLink);\n\nexport { RetryLink };","map":{"version":3,"sources":["../src/retryLink.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    }\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { ApolloLink, Observable, } from 'apollo-link';\nimport { buildDelayFunction, } from './delayFunction';\nimport { buildRetryFunction, } from './retryFunction';\n/**\n * Tracking and management of operations that may be (or currently are) retried.\n */\nvar RetryableOperation = /** @class */ (function () {\n    function RetryableOperation(operation, nextLink, delayFor, retryIf) {\n        var _this = this;\n        this.operation = operation;\n        this.nextLink = nextLink;\n        this.delayFor = delayFor;\n        this.retryIf = retryIf;\n        this.retryCount = 0;\n        this.values = [];\n        this.complete = false;\n        this.canceled = false;\n        this.observers = [];\n        this.currentSubscription = null;\n        this.onNext = function (value) {\n            _this.values.push(value);\n            for (var _i = 0, _a = _this.observers; _i < _a.length; _i++) {\n                var observer = _a[_i];\n                if (!observer)\n                    continue;\n                observer.next(value);\n            }\n        };\n        this.onComplete = function () {\n            _this.complete = true;\n            for (var _i = 0, _a = _this.observers; _i < _a.length; _i++) {\n                var observer = _a[_i];\n                if (!observer)\n                    continue;\n                observer.complete();\n            }\n        };\n        this.onError = function (error) { return __awaiter(_this, void 0, void 0, function () {\n            var shouldRetry, _i, _a, observer;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        this.retryCount += 1;\n                        return [4 /*yield*/, this.retryIf(this.retryCount, this.operation, error)];\n                    case 1:\n                        shouldRetry = _b.sent();\n                        if (shouldRetry) {\n                            this.scheduleRetry(this.delayFor(this.retryCount, this.operation, error));\n                            return [2 /*return*/];\n                        }\n                        this.error = error;\n                        for (_i = 0, _a = this.observers; _i < _a.length; _i++) {\n                            observer = _a[_i];\n                            if (!observer)\n                                continue;\n                            observer.error(error);\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        }); };\n    }\n    /**\n     * Register a new observer for this operation.\n     *\n     * If the operation has previously emitted other events, they will be\n     * immediately triggered for the observer.\n     */\n    RetryableOperation.prototype.subscribe = function (observer) {\n        if (this.canceled) {\n            throw new Error(\"Subscribing to a retryable link that was canceled is not supported\");\n        }\n        this.observers.push(observer);\n        // If we've already begun, catch this observer up.\n        for (var _i = 0, _a = this.values; _i < _a.length; _i++) {\n            var value = _a[_i];\n            observer.next(value);\n        }\n        if (this.complete) {\n            observer.complete();\n        }\n        else if (this.error) {\n            observer.error(this.error);\n        }\n    };\n    /**\n     * Remove a previously registered observer from this operation.\n     *\n     * If no observers remain, the operation will stop retrying, and unsubscribe\n     * from its downstream link.\n     */\n    RetryableOperation.prototype.unsubscribe = function (observer) {\n        var index = this.observers.indexOf(observer);\n        if (index < 0) {\n            throw new Error(\"RetryLink BUG! Attempting to unsubscribe unknown observer!\");\n        }\n        // Note that we are careful not to change the order of length of the array,\n        // as we are often mid-iteration when calling this method.\n        this.observers[index] = null;\n        // If this is the last observer, we're done.\n        if (this.observers.every(function (o) { return o === null; })) {\n            this.cancel();\n        }\n    };\n    /**\n     * Start the initial request.\n     */\n    RetryableOperation.prototype.start = function () {\n        if (this.currentSubscription)\n            return; // Already started.\n        this.try();\n    };\n    /**\n     * Stop retrying for the operation, and cancel any in-progress requests.\n     */\n    RetryableOperation.prototype.cancel = function () {\n        if (this.currentSubscription) {\n            this.currentSubscription.unsubscribe();\n        }\n        clearTimeout(this.timerId);\n        this.timerId = null;\n        this.currentSubscription = null;\n        this.canceled = true;\n    };\n    RetryableOperation.prototype.try = function () {\n        this.currentSubscription = this.nextLink(this.operation).subscribe({\n            next: this.onNext,\n            error: this.onError,\n            complete: this.onComplete,\n        });\n    };\n    RetryableOperation.prototype.scheduleRetry = function (delay) {\n        var _this = this;\n        if (this.timerId) {\n            throw new Error(\"RetryLink BUG! Encountered overlapping retries\");\n        }\n        this.timerId = setTimeout(function () {\n            _this.timerId = null;\n            _this.try();\n        }, delay);\n    };\n    return RetryableOperation;\n}());\nvar RetryLink = /** @class */ (function (_super) {\n    __extends(RetryLink, _super);\n    function RetryLink(_a) {\n        var _b = _a === void 0 ? {} : _a, delay = _b.delay, attempts = _b.attempts;\n        var _this = _super.call(this) || this;\n        _this.delayFor =\n            typeof delay === 'function' ? delay : buildDelayFunction(delay);\n        _this.retryIf =\n            typeof attempts === 'function' ? attempts : buildRetryFunction(attempts);\n        return _this;\n    }\n    RetryLink.prototype.request = function (operation, nextLink) {\n        var retryable = new RetryableOperation(operation, nextLink, this.delayFor, this.retryIf);\n        retryable.start();\n        return new Observable(function (observer) {\n            retryable.subscribe(observer);\n            return function () {\n                retryable.unsubscribe(observer);\n            };\n        });\n    };\n    return RetryLink;\n}(ApolloLink));\nexport { RetryLink };\n//# sourceMappingURL=retryLink.js.map"]},"metadata":{},"sourceType":"module"}