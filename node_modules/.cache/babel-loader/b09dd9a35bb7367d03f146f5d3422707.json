{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isEqualType = isEqualType;\nexports.isTypeSubTypeOf = isTypeSubTypeOf;\nexports.doTypesOverlap = doTypesOverlap;\n\nvar _definition = require('../type/definition');\n/**\n * Provided two types, return true if the types are equal (invariant).\n */\n\n\nfunction isEqualType(typeA, typeB) {\n  // Equivalent types are equal.\n  if (typeA === typeB) {\n    return true;\n  } // If either type is non-null, the other must also be non-null.\n\n\n  if (typeA instanceof _definition.GraphQLNonNull && typeB instanceof _definition.GraphQLNonNull) {\n    return isEqualType(typeA.ofType, typeB.ofType);\n  } // If either type is a list, the other must also be a list.\n\n\n  if (typeA instanceof _definition.GraphQLList && typeB instanceof _definition.GraphQLList) {\n    return isEqualType(typeA.ofType, typeB.ofType);\n  } // Otherwise the types are not equal.\n\n\n  return false;\n}\n/**\n * Provided a type and a super type, return true if the first type is either\n * equal or a subset of the second super type (covariant).\n */\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\nfunction isTypeSubTypeOf(schema, maybeSubType, superType) {\n  // Equivalent type is a valid subtype\n  if (maybeSubType === superType) {\n    return true;\n  } // If superType is non-null, maybeSubType must also be non-null.\n\n\n  if (superType instanceof _definition.GraphQLNonNull) {\n    if (maybeSubType instanceof _definition.GraphQLNonNull) {\n      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);\n    }\n\n    return false;\n  } else if (maybeSubType instanceof _definition.GraphQLNonNull) {\n    // If superType is nullable, maybeSubType may be non-null or nullable.\n    return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);\n  } // If superType type is a list, maybeSubType type must also be a list.\n\n\n  if (superType instanceof _definition.GraphQLList) {\n    if (maybeSubType instanceof _definition.GraphQLList) {\n      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);\n    }\n\n    return false;\n  } else if (maybeSubType instanceof _definition.GraphQLList) {\n    // If superType is not a list, maybeSubType must also be not a list.\n    return false;\n  } // If superType type is an abstract type, maybeSubType type may be a currently\n  // possible object type.\n\n\n  if ((0, _definition.isAbstractType)(superType) && maybeSubType instanceof _definition.GraphQLObjectType && schema.isPossibleType(superType, maybeSubType)) {\n    return true;\n  } // Otherwise, the child type is not a valid subtype of the parent type.\n\n\n  return false;\n}\n/**\n * Provided two composite types, determine if they \"overlap\". Two composite\n * types overlap when the Sets of possible concrete types for each intersect.\n *\n * This is often used to determine if a fragment of a given type could possibly\n * be visited in a context of another type.\n *\n * This function is commutative.\n */\n\n\nfunction doTypesOverlap(schema, typeA, typeB) {\n  // So flow is aware this is constant\n  var _typeB = typeB; // Equivalent types overlap\n\n  if (typeA === _typeB) {\n    return true;\n  }\n\n  if ((0, _definition.isAbstractType)(typeA)) {\n    if ((0, _definition.isAbstractType)(_typeB)) {\n      // If both types are abstract, then determine if there is any intersection\n      // between possible concrete types of each.\n      return schema.getPossibleTypes(typeA).some(function (type) {\n        return schema.isPossibleType(_typeB, type);\n      });\n    } // Determine if the latter type is a possible concrete type of the former.\n\n\n    return schema.isPossibleType(typeA, _typeB);\n  }\n\n  if ((0, _definition.isAbstractType)(_typeB)) {\n    // Determine if the former type is a possible concrete type of the latter.\n    return schema.isPossibleType(_typeB, typeA);\n  } // Otherwise the types do not overlap.\n\n\n  return false;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","isEqualType","isTypeSubTypeOf","doTypesOverlap","_definition","require","typeA","typeB","GraphQLNonNull","ofType","GraphQLList","schema","maybeSubType","superType","isAbstractType","GraphQLObjectType","isPossibleType","_typeB","getPossibleTypes","some","type"],"sources":["/Users/roaldmaravillas/ro/github/scaffold-appsync-events/node_modules/graphql/utilities/typeComparators.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isEqualType = isEqualType;\nexports.isTypeSubTypeOf = isTypeSubTypeOf;\nexports.doTypesOverlap = doTypesOverlap;\n\nvar _definition = require('../type/definition');\n\n/**\n * Provided two types, return true if the types are equal (invariant).\n */\nfunction isEqualType(typeA, typeB) {\n  // Equivalent types are equal.\n  if (typeA === typeB) {\n    return true;\n  }\n\n  // If either type is non-null, the other must also be non-null.\n  if (typeA instanceof _definition.GraphQLNonNull && typeB instanceof _definition.GraphQLNonNull) {\n    return isEqualType(typeA.ofType, typeB.ofType);\n  }\n\n  // If either type is a list, the other must also be a list.\n  if (typeA instanceof _definition.GraphQLList && typeB instanceof _definition.GraphQLList) {\n    return isEqualType(typeA.ofType, typeB.ofType);\n  }\n\n  // Otherwise the types are not equal.\n  return false;\n}\n\n/**\n * Provided a type and a super type, return true if the first type is either\n * equal or a subset of the second super type (covariant).\n */\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nfunction isTypeSubTypeOf(schema, maybeSubType, superType) {\n  // Equivalent type is a valid subtype\n  if (maybeSubType === superType) {\n    return true;\n  }\n\n  // If superType is non-null, maybeSubType must also be non-null.\n  if (superType instanceof _definition.GraphQLNonNull) {\n    if (maybeSubType instanceof _definition.GraphQLNonNull) {\n      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);\n    }\n    return false;\n  } else if (maybeSubType instanceof _definition.GraphQLNonNull) {\n    // If superType is nullable, maybeSubType may be non-null or nullable.\n    return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);\n  }\n\n  // If superType type is a list, maybeSubType type must also be a list.\n  if (superType instanceof _definition.GraphQLList) {\n    if (maybeSubType instanceof _definition.GraphQLList) {\n      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);\n    }\n    return false;\n  } else if (maybeSubType instanceof _definition.GraphQLList) {\n    // If superType is not a list, maybeSubType must also be not a list.\n    return false;\n  }\n\n  // If superType type is an abstract type, maybeSubType type may be a currently\n  // possible object type.\n  if ((0, _definition.isAbstractType)(superType) && maybeSubType instanceof _definition.GraphQLObjectType && schema.isPossibleType(superType, maybeSubType)) {\n    return true;\n  }\n\n  // Otherwise, the child type is not a valid subtype of the parent type.\n  return false;\n}\n\n/**\n * Provided two composite types, determine if they \"overlap\". Two composite\n * types overlap when the Sets of possible concrete types for each intersect.\n *\n * This is often used to determine if a fragment of a given type could possibly\n * be visited in a context of another type.\n *\n * This function is commutative.\n */\nfunction doTypesOverlap(schema, typeA, typeB) {\n  // So flow is aware this is constant\n  var _typeB = typeB;\n\n  // Equivalent types overlap\n  if (typeA === _typeB) {\n    return true;\n  }\n\n  if ((0, _definition.isAbstractType)(typeA)) {\n    if ((0, _definition.isAbstractType)(_typeB)) {\n      // If both types are abstract, then determine if there is any intersection\n      // between possible concrete types of each.\n      return schema.getPossibleTypes(typeA).some(function (type) {\n        return schema.isPossibleType(_typeB, type);\n      });\n    }\n    // Determine if the latter type is a possible concrete type of the former.\n    return schema.isPossibleType(typeA, _typeB);\n  }\n\n  if ((0, _definition.isAbstractType)(_typeB)) {\n    // Determine if the former type is a possible concrete type of the latter.\n    return schema.isPossibleType(_typeB, typeA);\n  }\n\n  // Otherwise the types do not overlap.\n  return false;\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}