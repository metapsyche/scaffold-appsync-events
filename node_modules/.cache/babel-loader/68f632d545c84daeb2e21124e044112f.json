{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\nimport { Kind } from '../language/kinds';\nimport { isObjectType, isInterfaceType, isEnumType, isInputObjectType, isListType, isCompositeType, isInputType, isOutputType, getNullableType, getNamedType } from '../type/definition';\nimport { SchemaMetaFieldDef, TypeMetaFieldDef, TypeNameMetaFieldDef } from '../type/introspection';\nimport { typeFromAST } from './typeFromAST';\nimport find from '../jsutils/find';\n/**\n * TypeInfo is a utility class which, given a GraphQL schema, can keep track\n * of the current field and type definitions at any point in a GraphQL document\n * AST during a recursive descent by calling `enter(node)` and `leave(node)`.\n */\n\nexport var TypeInfo = function () {\n  function TypeInfo(schema, // NOTE: this experimental optional second parameter is only needed in order\n  // to support non-spec-compliant codebases. You should never need to use it.\n  getFieldDefFn, // Initial type may be provided in rare cases to facilitate traversals\n  initialType) {\n    _classCallCheck(this, TypeInfo);\n\n    this._schema = schema;\n    this._typeStack = [];\n    this._parentTypeStack = [];\n    this._inputTypeStack = [];\n    this._fieldDefStack = [];\n    this._directive = null;\n    this._argument = null;\n    this._enumValue = null;\n    this._getFieldDef = getFieldDefFn || getFieldDef;\n\n    if (initialType) {\n      if (isInputType(initialType)) {\n        this._inputTypeStack.push(initialType);\n      }\n\n      if (isCompositeType(initialType)) {\n        this._parentTypeStack.push(initialType);\n      }\n\n      if (isOutputType(initialType)) {\n        this._typeStack.push(initialType);\n      }\n    }\n  }\n\n  TypeInfo.prototype.getType = function getType() {\n    if (this._typeStack.length > 0) {\n      return this._typeStack[this._typeStack.length - 1];\n    }\n  };\n\n  TypeInfo.prototype.getParentType = function getParentType() {\n    if (this._parentTypeStack.length > 0) {\n      return this._parentTypeStack[this._parentTypeStack.length - 1];\n    }\n  };\n\n  TypeInfo.prototype.getInputType = function getInputType() {\n    if (this._inputTypeStack.length > 0) {\n      return this._inputTypeStack[this._inputTypeStack.length - 1];\n    }\n  };\n\n  TypeInfo.prototype.getParentInputType = function getParentInputType() {\n    if (this._inputTypeStack.length > 1) {\n      return this._inputTypeStack[this._inputTypeStack.length - 2];\n    }\n  };\n\n  TypeInfo.prototype.getFieldDef = function getFieldDef() {\n    if (this._fieldDefStack.length > 0) {\n      return this._fieldDefStack[this._fieldDefStack.length - 1];\n    }\n  };\n\n  TypeInfo.prototype.getDirective = function getDirective() {\n    return this._directive;\n  };\n\n  TypeInfo.prototype.getArgument = function getArgument() {\n    return this._argument;\n  };\n\n  TypeInfo.prototype.getEnumValue = function getEnumValue() {\n    return this._enumValue;\n  }; // Flow does not yet handle this case.\n\n\n  TypeInfo.prototype.enter = function enter(node\n  /* ASTNode */\n  ) {\n    var schema = this._schema; // Note: many of the types below are explicitly typed as \"mixed\" to drop\n    // any assumptions of a valid schema to ensure runtime types are properly\n    // checked before continuing since TypeInfo is used as part of validation\n    // which occurs before guarantees of schema and document validity.\n\n    switch (node.kind) {\n      case Kind.SELECTION_SET:\n        var namedType = getNamedType(this.getType());\n\n        this._parentTypeStack.push(isCompositeType(namedType) ? namedType : undefined);\n\n        break;\n\n      case Kind.FIELD:\n        var parentType = this.getParentType();\n        var fieldDef = void 0;\n        var fieldType = void 0;\n\n        if (parentType) {\n          fieldDef = this._getFieldDef(schema, parentType, node);\n\n          if (fieldDef) {\n            fieldType = fieldDef.type;\n          }\n        }\n\n        this._fieldDefStack.push(fieldDef);\n\n        this._typeStack.push(isOutputType(fieldType) ? fieldType : undefined);\n\n        break;\n\n      case Kind.DIRECTIVE:\n        this._directive = schema.getDirective(node.name.value);\n        break;\n\n      case Kind.OPERATION_DEFINITION:\n        var type = void 0;\n\n        if (node.operation === 'query') {\n          type = schema.getQueryType();\n        } else if (node.operation === 'mutation') {\n          type = schema.getMutationType();\n        } else if (node.operation === 'subscription') {\n          type = schema.getSubscriptionType();\n        }\n\n        this._typeStack.push(isObjectType(type) ? type : undefined);\n\n        break;\n\n      case Kind.INLINE_FRAGMENT:\n      case Kind.FRAGMENT_DEFINITION:\n        var typeConditionAST = node.typeCondition;\n        var outputType = typeConditionAST ? typeFromAST(schema, typeConditionAST) : getNamedType(this.getType());\n\n        this._typeStack.push(isOutputType(outputType) ? outputType : undefined);\n\n        break;\n\n      case Kind.VARIABLE_DEFINITION:\n        var inputType = typeFromAST(schema, node.type);\n\n        this._inputTypeStack.push(isInputType(inputType) ? inputType : undefined);\n\n        break;\n\n      case Kind.ARGUMENT:\n        var argDef = void 0;\n        var argType = void 0;\n        var fieldOrDirective = this.getDirective() || this.getFieldDef();\n\n        if (fieldOrDirective) {\n          argDef = find(fieldOrDirective.args, function (arg) {\n            return arg.name === node.name.value;\n          });\n\n          if (argDef) {\n            argType = argDef.type;\n          }\n        }\n\n        this._argument = argDef;\n\n        this._inputTypeStack.push(isInputType(argType) ? argType : undefined);\n\n        break;\n\n      case Kind.LIST:\n        var listType = getNullableType(this.getInputType());\n        var itemType = isListType(listType) ? listType.ofType : listType;\n\n        this._inputTypeStack.push(isInputType(itemType) ? itemType : undefined);\n\n        break;\n\n      case Kind.OBJECT_FIELD:\n        var objectType = getNamedType(this.getInputType());\n        var inputFieldType = void 0;\n\n        if (isInputObjectType(objectType)) {\n          var inputField = objectType.getFields()[node.name.value];\n\n          if (inputField) {\n            inputFieldType = inputField.type;\n          }\n        }\n\n        this._inputTypeStack.push(isInputType(inputFieldType) ? inputFieldType : undefined);\n\n        break;\n\n      case Kind.ENUM:\n        var enumType = getNamedType(this.getInputType());\n        var enumValue = void 0;\n\n        if (isEnumType(enumType)) {\n          enumValue = enumType.getValue(node.value);\n        }\n\n        this._enumValue = enumValue;\n        break;\n    }\n  };\n\n  TypeInfo.prototype.leave = function leave(node) {\n    switch (node.kind) {\n      case Kind.SELECTION_SET:\n        this._parentTypeStack.pop();\n\n        break;\n\n      case Kind.FIELD:\n        this._fieldDefStack.pop();\n\n        this._typeStack.pop();\n\n        break;\n\n      case Kind.DIRECTIVE:\n        this._directive = null;\n        break;\n\n      case Kind.OPERATION_DEFINITION:\n      case Kind.INLINE_FRAGMENT:\n      case Kind.FRAGMENT_DEFINITION:\n        this._typeStack.pop();\n\n        break;\n\n      case Kind.VARIABLE_DEFINITION:\n        this._inputTypeStack.pop();\n\n        break;\n\n      case Kind.ARGUMENT:\n        this._argument = null;\n\n        this._inputTypeStack.pop();\n\n        break;\n\n      case Kind.LIST:\n      case Kind.OBJECT_FIELD:\n        this._inputTypeStack.pop();\n\n        break;\n\n      case Kind.ENUM:\n        this._enumValue = null;\n        break;\n    }\n  };\n\n  return TypeInfo;\n}();\n/**\n * Not exactly the same as the executor's definition of getFieldDef, in this\n * statically evaluated environment we do not always have an Object type,\n * and need to handle Interface and Union types.\n */\n\nfunction getFieldDef(schema, parentType, fieldNode) {\n  var name = fieldNode.name.value;\n\n  if (name === SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return SchemaMetaFieldDef;\n  }\n\n  if (name === TypeMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return TypeMetaFieldDef;\n  }\n\n  if (name === TypeNameMetaFieldDef.name && isCompositeType(parentType)) {\n    return TypeNameMetaFieldDef;\n  }\n\n  if (isObjectType(parentType) || isInterfaceType(parentType)) {\n    return parentType.getFields()[name];\n  }\n}","map":{"version":3,"names":["_classCallCheck","instance","Constructor","TypeError","Kind","isObjectType","isInterfaceType","isEnumType","isInputObjectType","isListType","isCompositeType","isInputType","isOutputType","getNullableType","getNamedType","SchemaMetaFieldDef","TypeMetaFieldDef","TypeNameMetaFieldDef","typeFromAST","find","TypeInfo","schema","getFieldDefFn","initialType","_schema","_typeStack","_parentTypeStack","_inputTypeStack","_fieldDefStack","_directive","_argument","_enumValue","_getFieldDef","getFieldDef","push","prototype","getType","length","getParentType","getInputType","getParentInputType","getDirective","getArgument","getEnumValue","enter","node","kind","SELECTION_SET","namedType","undefined","FIELD","parentType","fieldDef","fieldType","type","DIRECTIVE","name","value","OPERATION_DEFINITION","operation","getQueryType","getMutationType","getSubscriptionType","INLINE_FRAGMENT","FRAGMENT_DEFINITION","typeConditionAST","typeCondition","outputType","VARIABLE_DEFINITION","inputType","ARGUMENT","argDef","argType","fieldOrDirective","args","arg","LIST","listType","itemType","ofType","OBJECT_FIELD","objectType","inputFieldType","inputField","getFields","ENUM","enumType","enumValue","getValue","leave","pop","fieldNode"],"sources":["/Users/roaldmaravillas/ro/github/scaffold-appsync-events/node_modules/aws-appsync/node_modules/graphql/module/utilities/TypeInfo.js"],"sourcesContent":["function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nimport { Kind } from '../language/kinds';\nimport { isObjectType, isInterfaceType, isEnumType, isInputObjectType, isListType, isCompositeType, isInputType, isOutputType, getNullableType, getNamedType } from '../type/definition';\n\nimport { SchemaMetaFieldDef, TypeMetaFieldDef, TypeNameMetaFieldDef } from '../type/introspection';\n\nimport { typeFromAST } from './typeFromAST';\nimport find from '../jsutils/find';\n\n/**\n * TypeInfo is a utility class which, given a GraphQL schema, can keep track\n * of the current field and type definitions at any point in a GraphQL document\n * AST during a recursive descent by calling `enter(node)` and `leave(node)`.\n */\nexport var TypeInfo = function () {\n  function TypeInfo(schema,\n  // NOTE: this experimental optional second parameter is only needed in order\n  // to support non-spec-compliant codebases. You should never need to use it.\n  getFieldDefFn,\n  // Initial type may be provided in rare cases to facilitate traversals\n  initialType) {\n    _classCallCheck(this, TypeInfo);\n\n    this._schema = schema;\n    this._typeStack = [];\n    this._parentTypeStack = [];\n    this._inputTypeStack = [];\n    this._fieldDefStack = [];\n    this._directive = null;\n    this._argument = null;\n    this._enumValue = null;\n    this._getFieldDef = getFieldDefFn || getFieldDef;\n    if (initialType) {\n      if (isInputType(initialType)) {\n        this._inputTypeStack.push(initialType);\n      }\n      if (isCompositeType(initialType)) {\n        this._parentTypeStack.push(initialType);\n      }\n      if (isOutputType(initialType)) {\n        this._typeStack.push(initialType);\n      }\n    }\n  }\n\n  TypeInfo.prototype.getType = function getType() {\n    if (this._typeStack.length > 0) {\n      return this._typeStack[this._typeStack.length - 1];\n    }\n  };\n\n  TypeInfo.prototype.getParentType = function getParentType() {\n    if (this._parentTypeStack.length > 0) {\n      return this._parentTypeStack[this._parentTypeStack.length - 1];\n    }\n  };\n\n  TypeInfo.prototype.getInputType = function getInputType() {\n    if (this._inputTypeStack.length > 0) {\n      return this._inputTypeStack[this._inputTypeStack.length - 1];\n    }\n  };\n\n  TypeInfo.prototype.getParentInputType = function getParentInputType() {\n    if (this._inputTypeStack.length > 1) {\n      return this._inputTypeStack[this._inputTypeStack.length - 2];\n    }\n  };\n\n  TypeInfo.prototype.getFieldDef = function getFieldDef() {\n    if (this._fieldDefStack.length > 0) {\n      return this._fieldDefStack[this._fieldDefStack.length - 1];\n    }\n  };\n\n  TypeInfo.prototype.getDirective = function getDirective() {\n    return this._directive;\n  };\n\n  TypeInfo.prototype.getArgument = function getArgument() {\n    return this._argument;\n  };\n\n  TypeInfo.prototype.getEnumValue = function getEnumValue() {\n    return this._enumValue;\n  };\n\n  // Flow does not yet handle this case.\n\n\n  TypeInfo.prototype.enter = function enter(node /* ASTNode */) {\n    var schema = this._schema;\n    // Note: many of the types below are explicitly typed as \"mixed\" to drop\n    // any assumptions of a valid schema to ensure runtime types are properly\n    // checked before continuing since TypeInfo is used as part of validation\n    // which occurs before guarantees of schema and document validity.\n    switch (node.kind) {\n      case Kind.SELECTION_SET:\n        var namedType = getNamedType(this.getType());\n        this._parentTypeStack.push(isCompositeType(namedType) ? namedType : undefined);\n        break;\n      case Kind.FIELD:\n        var parentType = this.getParentType();\n        var fieldDef = void 0;\n        var fieldType = void 0;\n        if (parentType) {\n          fieldDef = this._getFieldDef(schema, parentType, node);\n          if (fieldDef) {\n            fieldType = fieldDef.type;\n          }\n        }\n        this._fieldDefStack.push(fieldDef);\n        this._typeStack.push(isOutputType(fieldType) ? fieldType : undefined);\n        break;\n      case Kind.DIRECTIVE:\n        this._directive = schema.getDirective(node.name.value);\n        break;\n      case Kind.OPERATION_DEFINITION:\n        var type = void 0;\n        if (node.operation === 'query') {\n          type = schema.getQueryType();\n        } else if (node.operation === 'mutation') {\n          type = schema.getMutationType();\n        } else if (node.operation === 'subscription') {\n          type = schema.getSubscriptionType();\n        }\n        this._typeStack.push(isObjectType(type) ? type : undefined);\n        break;\n      case Kind.INLINE_FRAGMENT:\n      case Kind.FRAGMENT_DEFINITION:\n        var typeConditionAST = node.typeCondition;\n        var outputType = typeConditionAST ? typeFromAST(schema, typeConditionAST) : getNamedType(this.getType());\n        this._typeStack.push(isOutputType(outputType) ? outputType : undefined);\n        break;\n      case Kind.VARIABLE_DEFINITION:\n        var inputType = typeFromAST(schema, node.type);\n        this._inputTypeStack.push(isInputType(inputType) ? inputType : undefined);\n        break;\n      case Kind.ARGUMENT:\n        var argDef = void 0;\n        var argType = void 0;\n        var fieldOrDirective = this.getDirective() || this.getFieldDef();\n        if (fieldOrDirective) {\n          argDef = find(fieldOrDirective.args, function (arg) {\n            return arg.name === node.name.value;\n          });\n          if (argDef) {\n            argType = argDef.type;\n          }\n        }\n        this._argument = argDef;\n        this._inputTypeStack.push(isInputType(argType) ? argType : undefined);\n        break;\n      case Kind.LIST:\n        var listType = getNullableType(this.getInputType());\n        var itemType = isListType(listType) ? listType.ofType : listType;\n        this._inputTypeStack.push(isInputType(itemType) ? itemType : undefined);\n        break;\n      case Kind.OBJECT_FIELD:\n        var objectType = getNamedType(this.getInputType());\n        var inputFieldType = void 0;\n        if (isInputObjectType(objectType)) {\n          var inputField = objectType.getFields()[node.name.value];\n          if (inputField) {\n            inputFieldType = inputField.type;\n          }\n        }\n        this._inputTypeStack.push(isInputType(inputFieldType) ? inputFieldType : undefined);\n        break;\n      case Kind.ENUM:\n        var enumType = getNamedType(this.getInputType());\n        var enumValue = void 0;\n        if (isEnumType(enumType)) {\n          enumValue = enumType.getValue(node.value);\n        }\n        this._enumValue = enumValue;\n        break;\n    }\n  };\n\n  TypeInfo.prototype.leave = function leave(node) {\n    switch (node.kind) {\n      case Kind.SELECTION_SET:\n        this._parentTypeStack.pop();\n        break;\n      case Kind.FIELD:\n        this._fieldDefStack.pop();\n        this._typeStack.pop();\n        break;\n      case Kind.DIRECTIVE:\n        this._directive = null;\n        break;\n      case Kind.OPERATION_DEFINITION:\n      case Kind.INLINE_FRAGMENT:\n      case Kind.FRAGMENT_DEFINITION:\n        this._typeStack.pop();\n        break;\n      case Kind.VARIABLE_DEFINITION:\n        this._inputTypeStack.pop();\n        break;\n      case Kind.ARGUMENT:\n        this._argument = null;\n        this._inputTypeStack.pop();\n        break;\n      case Kind.LIST:\n      case Kind.OBJECT_FIELD:\n        this._inputTypeStack.pop();\n        break;\n      case Kind.ENUM:\n        this._enumValue = null;\n        break;\n    }\n  };\n\n  return TypeInfo;\n}();\n\n/**\n * Not exactly the same as the executor's definition of getFieldDef, in this\n * statically evaluated environment we do not always have an Object type,\n * and need to handle Interface and Union types.\n */\nfunction getFieldDef(schema, parentType, fieldNode) {\n  var name = fieldNode.name.value;\n  if (name === SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return SchemaMetaFieldDef;\n  }\n  if (name === TypeMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return TypeMetaFieldDef;\n  }\n  if (name === TypeNameMetaFieldDef.name && isCompositeType(parentType)) {\n    return TypeNameMetaFieldDef;\n  }\n  if (isObjectType(parentType) || isInterfaceType(parentType)) {\n    return parentType.getFields()[name];\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}