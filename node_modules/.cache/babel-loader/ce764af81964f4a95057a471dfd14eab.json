{"ast":null,"code":"var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\nimport { isObjectType, isInterfaceType, isUnionType, isInputObjectType, isWrappingType } from './definition';\nimport { GraphQLDirective, isDirective, specifiedDirectives } from './directives';\nimport { __Schema } from './introspection';\nimport find from '../jsutils/find';\nimport instanceOf from '../jsutils/instanceOf';\nimport invariant from '../jsutils/invariant';\nimport objectValues from '../jsutils/objectValues';\n/**\n * Test if the given value is a GraphQL schema.\n */\n// eslint-disable-next-line no-redeclare\n\nexport function isSchema(schema) {\n  return instanceOf(schema, GraphQLSchema);\n}\n/**\n * Schema Definition\n *\n * A Schema is created by supplying the root types of each type of operation,\n * query and mutation (optional). A schema definition is then supplied to the\n * validator and executor.\n *\n * Example:\n *\n *     const MyAppSchema = new GraphQLSchema({\n *       query: MyAppQueryRootType,\n *       mutation: MyAppMutationRootType,\n *     })\n *\n * Note: If an array of `directives` are provided to GraphQLSchema, that will be\n * the exact list of directives represented and allowed. If `directives` is not\n * provided then a default set of the specified directives (e.g. @include and\n * @skip) will be used. If you wish to provide *additional* directives to these\n * specified directives, you must explicitly declare them. Example:\n *\n *     const MyAppSchema = new GraphQLSchema({\n *       ...\n *       directives: specifiedDirectives.concat([ myCustomDirective ]),\n *     })\n *\n */\n\nexport var GraphQLSchema = function () {\n  // Used as a cache for validateSchema().\n  function GraphQLSchema(config) {\n    var _this = this;\n\n    _classCallCheck(this, GraphQLSchema); // If this schema was built from a source known to be valid, then it may be\n    // marked with assumeValid to avoid an additional type system validation.\n\n\n    if (config && config.assumeValid) {\n      this.__validationErrors = [];\n    } else {\n      // Otherwise check for common mistakes during construction to produce\n      // clear and early error messages.\n      !((typeof config === 'undefined' ? 'undefined' : _typeof(config)) === 'object') ? invariant(0, 'Must provide configuration object.') : void 0;\n      !(!config.types || Array.isArray(config.types)) ? invariant(0, '\"types\" must be Array if provided but got: ' + String(config.types) + '.') : void 0;\n      !(!config.directives || Array.isArray(config.directives)) ? invariant(0, '\"directives\" must be Array if provided but got: ' + (String(config.directives) + '.')) : void 0;\n      !(!config.allowedLegacyNames || Array.isArray(config.allowedLegacyNames)) ? invariant(0, '\"allowedLegacyNames\" must be Array if provided but got: ' + (String(config.allowedLegacyNames) + '.')) : void 0;\n      this.__allowedLegacyNames = config.allowedLegacyNames;\n    }\n\n    this._queryType = config.query;\n    this._mutationType = config.mutation;\n    this._subscriptionType = config.subscription; // Provide specified directives (e.g. @include and @skip) by default.\n\n    this._directives = config.directives || specifiedDirectives;\n    this.astNode = config.astNode; // Build type map now to detect any errors within this schema.\n\n    var initialTypes = [this.getQueryType(), this.getMutationType(), this.getSubscriptionType(), __Schema];\n    var types = config.types;\n\n    if (types) {\n      initialTypes = initialTypes.concat(types);\n    } // Keep track of all types referenced within the schema.\n\n\n    var typeMap = Object.create(null); // First by deeply visiting all initial types.\n\n    typeMap = initialTypes.reduce(typeMapReducer, typeMap); // Then by deeply visiting all directive types.\n\n    typeMap = this._directives.reduce(typeMapDirectiveReducer, typeMap); // Storing the resulting map for reference by the schema.\n\n    this._typeMap = typeMap; // Keep track of all implementations by interface name.\n\n    this._implementations = Object.create(null);\n    Object.keys(this._typeMap).forEach(function (typeName) {\n      var type = _this._typeMap[typeName];\n\n      if (isObjectType(type)) {\n        type.getInterfaces().forEach(function (iface) {\n          var impls = _this._implementations[iface.name];\n\n          if (impls) {\n            impls.push(type);\n          } else {\n            _this._implementations[iface.name] = [type];\n          }\n        });\n      }\n    });\n  } // Referenced by validateSchema().\n\n\n  GraphQLSchema.prototype.getQueryType = function getQueryType() {\n    return this._queryType;\n  };\n\n  GraphQLSchema.prototype.getMutationType = function getMutationType() {\n    return this._mutationType;\n  };\n\n  GraphQLSchema.prototype.getSubscriptionType = function getSubscriptionType() {\n    return this._subscriptionType;\n  };\n\n  GraphQLSchema.prototype.getTypeMap = function getTypeMap() {\n    return this._typeMap;\n  };\n\n  GraphQLSchema.prototype.getType = function getType(name) {\n    return this.getTypeMap()[name];\n  };\n\n  GraphQLSchema.prototype.getPossibleTypes = function getPossibleTypes(abstractType) {\n    if (isUnionType(abstractType)) {\n      return abstractType.getTypes();\n    }\n\n    return this._implementations[abstractType.name];\n  };\n\n  GraphQLSchema.prototype.isPossibleType = function isPossibleType(abstractType, possibleType) {\n    var possibleTypeMap = this._possibleTypeMap;\n\n    if (!possibleTypeMap) {\n      this._possibleTypeMap = possibleTypeMap = Object.create(null);\n    }\n\n    if (!possibleTypeMap[abstractType.name]) {\n      var possibleTypes = this.getPossibleTypes(abstractType);\n      !Array.isArray(possibleTypes) ? invariant(0, 'Could not find possible implementing types for ' + abstractType.name + ' ' + 'in schema. Check that schema.types is defined and is an array of ' + 'all possible types in the schema.') : void 0;\n      possibleTypeMap[abstractType.name] = possibleTypes.reduce(function (map, type) {\n        return map[type.name] = true, map;\n      }, Object.create(null));\n    }\n\n    return Boolean(possibleTypeMap[abstractType.name][possibleType.name]);\n  };\n\n  GraphQLSchema.prototype.getDirectives = function getDirectives() {\n    return this._directives;\n  };\n\n  GraphQLSchema.prototype.getDirective = function getDirective(name) {\n    return find(this.getDirectives(), function (directive) {\n      return directive.name === name;\n    });\n  };\n\n  return GraphQLSchema;\n}();\n\nfunction typeMapReducer(map, type) {\n  if (!type) {\n    return map;\n  }\n\n  if (isWrappingType(type)) {\n    return typeMapReducer(map, type.ofType);\n  }\n\n  if (map[type.name]) {\n    !(map[type.name] === type) ? invariant(0, 'Schema must contain unique named types but contains multiple ' + ('types named \"' + type.name + '\".')) : void 0;\n    return map;\n  }\n\n  map[type.name] = type;\n  var reducedMap = map;\n\n  if (isUnionType(type)) {\n    reducedMap = type.getTypes().reduce(typeMapReducer, reducedMap);\n  }\n\n  if (isObjectType(type)) {\n    reducedMap = type.getInterfaces().reduce(typeMapReducer, reducedMap);\n  }\n\n  if (isObjectType(type) || isInterfaceType(type)) {\n    objectValues(type.getFields()).forEach(function (field) {\n      if (field.args) {\n        var fieldArgTypes = field.args.map(function (arg) {\n          return arg.type;\n        });\n        reducedMap = fieldArgTypes.reduce(typeMapReducer, reducedMap);\n      }\n\n      reducedMap = typeMapReducer(reducedMap, field.type);\n    });\n  }\n\n  if (isInputObjectType(type)) {\n    objectValues(type.getFields()).forEach(function (field) {\n      reducedMap = typeMapReducer(reducedMap, field.type);\n    });\n  }\n\n  return reducedMap;\n}\n\nfunction typeMapDirectiveReducer(map, directive) {\n  // Directives are not validated until validateSchema() is called.\n  if (!isDirective(directive)) {\n    return map;\n  }\n\n  return directive.args.reduce(function (_map, arg) {\n    return typeMapReducer(_map, arg.type);\n  }, map);\n}","map":{"version":3,"names":["_typeof","Symbol","iterator","obj","constructor","prototype","_classCallCheck","instance","Constructor","TypeError","isObjectType","isInterfaceType","isUnionType","isInputObjectType","isWrappingType","GraphQLDirective","isDirective","specifiedDirectives","__Schema","find","instanceOf","invariant","objectValues","isSchema","schema","GraphQLSchema","config","_this","assumeValid","__validationErrors","types","Array","isArray","String","directives","allowedLegacyNames","__allowedLegacyNames","_queryType","query","_mutationType","mutation","_subscriptionType","subscription","_directives","astNode","initialTypes","getQueryType","getMutationType","getSubscriptionType","concat","typeMap","Object","create","reduce","typeMapReducer","typeMapDirectiveReducer","_typeMap","_implementations","keys","forEach","typeName","type","getInterfaces","iface","impls","name","push","getTypeMap","getType","getPossibleTypes","abstractType","getTypes","isPossibleType","possibleType","possibleTypeMap","_possibleTypeMap","possibleTypes","map","Boolean","getDirectives","getDirective","directive","ofType","reducedMap","getFields","field","args","fieldArgTypes","arg","_map"],"sources":["/Users/roaldmaravillas/ro/sandbox/aws-mobile-appsync-events-starter-react/node_modules/aws-appsync/node_modules/graphql/module/type/schema.js"],"sourcesContent":["var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nimport { isObjectType, isInterfaceType, isUnionType, isInputObjectType, isWrappingType } from './definition';\n\nimport { GraphQLDirective, isDirective, specifiedDirectives } from './directives';\n\nimport { __Schema } from './introspection';\nimport find from '../jsutils/find';\nimport instanceOf from '../jsutils/instanceOf';\nimport invariant from '../jsutils/invariant';\nimport objectValues from '../jsutils/objectValues';\n\n/**\n * Test if the given value is a GraphQL schema.\n */\n\n// eslint-disable-next-line no-redeclare\nexport function isSchema(schema) {\n  return instanceOf(schema, GraphQLSchema);\n}\n\n/**\n * Schema Definition\n *\n * A Schema is created by supplying the root types of each type of operation,\n * query and mutation (optional). A schema definition is then supplied to the\n * validator and executor.\n *\n * Example:\n *\n *     const MyAppSchema = new GraphQLSchema({\n *       query: MyAppQueryRootType,\n *       mutation: MyAppMutationRootType,\n *     })\n *\n * Note: If an array of `directives` are provided to GraphQLSchema, that will be\n * the exact list of directives represented and allowed. If `directives` is not\n * provided then a default set of the specified directives (e.g. @include and\n * @skip) will be used. If you wish to provide *additional* directives to these\n * specified directives, you must explicitly declare them. Example:\n *\n *     const MyAppSchema = new GraphQLSchema({\n *       ...\n *       directives: specifiedDirectives.concat([ myCustomDirective ]),\n *     })\n *\n */\nexport var GraphQLSchema = function () {\n  // Used as a cache for validateSchema().\n  function GraphQLSchema(config) {\n    var _this = this;\n\n    _classCallCheck(this, GraphQLSchema);\n\n    // If this schema was built from a source known to be valid, then it may be\n    // marked with assumeValid to avoid an additional type system validation.\n    if (config && config.assumeValid) {\n      this.__validationErrors = [];\n    } else {\n      // Otherwise check for common mistakes during construction to produce\n      // clear and early error messages.\n      !((typeof config === 'undefined' ? 'undefined' : _typeof(config)) === 'object') ? invariant(0, 'Must provide configuration object.') : void 0;\n      !(!config.types || Array.isArray(config.types)) ? invariant(0, '\"types\" must be Array if provided but got: ' + String(config.types) + '.') : void 0;\n      !(!config.directives || Array.isArray(config.directives)) ? invariant(0, '\"directives\" must be Array if provided but got: ' + (String(config.directives) + '.')) : void 0;\n      !(!config.allowedLegacyNames || Array.isArray(config.allowedLegacyNames)) ? invariant(0, '\"allowedLegacyNames\" must be Array if provided but got: ' + (String(config.allowedLegacyNames) + '.')) : void 0;\n      this.__allowedLegacyNames = config.allowedLegacyNames;\n    }\n\n    this._queryType = config.query;\n    this._mutationType = config.mutation;\n    this._subscriptionType = config.subscription;\n    // Provide specified directives (e.g. @include and @skip) by default.\n    this._directives = config.directives || specifiedDirectives;\n    this.astNode = config.astNode;\n\n    // Build type map now to detect any errors within this schema.\n    var initialTypes = [this.getQueryType(), this.getMutationType(), this.getSubscriptionType(), __Schema];\n\n    var types = config.types;\n    if (types) {\n      initialTypes = initialTypes.concat(types);\n    }\n\n    // Keep track of all types referenced within the schema.\n    var typeMap = Object.create(null);\n\n    // First by deeply visiting all initial types.\n    typeMap = initialTypes.reduce(typeMapReducer, typeMap);\n\n    // Then by deeply visiting all directive types.\n    typeMap = this._directives.reduce(typeMapDirectiveReducer, typeMap);\n\n    // Storing the resulting map for reference by the schema.\n    this._typeMap = typeMap;\n\n    // Keep track of all implementations by interface name.\n    this._implementations = Object.create(null);\n    Object.keys(this._typeMap).forEach(function (typeName) {\n      var type = _this._typeMap[typeName];\n      if (isObjectType(type)) {\n        type.getInterfaces().forEach(function (iface) {\n          var impls = _this._implementations[iface.name];\n          if (impls) {\n            impls.push(type);\n          } else {\n            _this._implementations[iface.name] = [type];\n          }\n        });\n      }\n    });\n  }\n  // Referenced by validateSchema().\n\n\n  GraphQLSchema.prototype.getQueryType = function getQueryType() {\n    return this._queryType;\n  };\n\n  GraphQLSchema.prototype.getMutationType = function getMutationType() {\n    return this._mutationType;\n  };\n\n  GraphQLSchema.prototype.getSubscriptionType = function getSubscriptionType() {\n    return this._subscriptionType;\n  };\n\n  GraphQLSchema.prototype.getTypeMap = function getTypeMap() {\n    return this._typeMap;\n  };\n\n  GraphQLSchema.prototype.getType = function getType(name) {\n    return this.getTypeMap()[name];\n  };\n\n  GraphQLSchema.prototype.getPossibleTypes = function getPossibleTypes(abstractType) {\n    if (isUnionType(abstractType)) {\n      return abstractType.getTypes();\n    }\n    return this._implementations[abstractType.name];\n  };\n\n  GraphQLSchema.prototype.isPossibleType = function isPossibleType(abstractType, possibleType) {\n    var possibleTypeMap = this._possibleTypeMap;\n    if (!possibleTypeMap) {\n      this._possibleTypeMap = possibleTypeMap = Object.create(null);\n    }\n\n    if (!possibleTypeMap[abstractType.name]) {\n      var possibleTypes = this.getPossibleTypes(abstractType);\n      !Array.isArray(possibleTypes) ? invariant(0, 'Could not find possible implementing types for ' + abstractType.name + ' ' + 'in schema. Check that schema.types is defined and is an array of ' + 'all possible types in the schema.') : void 0;\n      possibleTypeMap[abstractType.name] = possibleTypes.reduce(function (map, type) {\n        return map[type.name] = true, map;\n      }, Object.create(null));\n    }\n\n    return Boolean(possibleTypeMap[abstractType.name][possibleType.name]);\n  };\n\n  GraphQLSchema.prototype.getDirectives = function getDirectives() {\n    return this._directives;\n  };\n\n  GraphQLSchema.prototype.getDirective = function getDirective(name) {\n    return find(this.getDirectives(), function (directive) {\n      return directive.name === name;\n    });\n  };\n\n  return GraphQLSchema;\n}();\n\nfunction typeMapReducer(map, type) {\n  if (!type) {\n    return map;\n  }\n  if (isWrappingType(type)) {\n    return typeMapReducer(map, type.ofType);\n  }\n  if (map[type.name]) {\n    !(map[type.name] === type) ? invariant(0, 'Schema must contain unique named types but contains multiple ' + ('types named \"' + type.name + '\".')) : void 0;\n    return map;\n  }\n  map[type.name] = type;\n\n  var reducedMap = map;\n\n  if (isUnionType(type)) {\n    reducedMap = type.getTypes().reduce(typeMapReducer, reducedMap);\n  }\n\n  if (isObjectType(type)) {\n    reducedMap = type.getInterfaces().reduce(typeMapReducer, reducedMap);\n  }\n\n  if (isObjectType(type) || isInterfaceType(type)) {\n    objectValues(type.getFields()).forEach(function (field) {\n      if (field.args) {\n        var fieldArgTypes = field.args.map(function (arg) {\n          return arg.type;\n        });\n        reducedMap = fieldArgTypes.reduce(typeMapReducer, reducedMap);\n      }\n      reducedMap = typeMapReducer(reducedMap, field.type);\n    });\n  }\n\n  if (isInputObjectType(type)) {\n    objectValues(type.getFields()).forEach(function (field) {\n      reducedMap = typeMapReducer(reducedMap, field.type);\n    });\n  }\n\n  return reducedMap;\n}\n\nfunction typeMapDirectiveReducer(map, directive) {\n  // Directives are not validated until validateSchema() is called.\n  if (!isDirective(directive)) {\n    return map;\n  }\n  return directive.args.reduce(function (_map, arg) {\n    return typeMapReducer(_map, arg.type);\n  }, map);\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}