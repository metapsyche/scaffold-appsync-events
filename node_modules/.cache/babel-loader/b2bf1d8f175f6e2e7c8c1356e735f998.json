{"ast":null,"code":"import { GraphQLError } from '../../error';\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nimport { doTypesOverlap } from '../../utilities/typeComparators';\nimport { typeFromAST } from '../../utilities/typeFromAST';\nimport { isCompositeType } from '../../type/definition';\nexport function typeIncompatibleSpreadMessage(fragName, parentType, fragType) {\n  return 'Fragment \"' + fragName + '\" cannot be spread here as objects of ' + ('type \"' + String(parentType) + '\" can never be of type \"' + String(fragType) + '\".');\n}\nexport function typeIncompatibleAnonSpreadMessage(parentType, fragType) {\n  return 'Fragment cannot be spread here as objects of ' + ('type \"' + String(parentType) + '\" can never be of type \"' + String(fragType) + '\".');\n}\n/**\n * Possible fragment spread\n *\n * A fragment spread is only valid if the type condition could ever possibly\n * be true: if there is a non-empty intersection of the possible parent types,\n * and possible types which pass the type condition.\n */\n\nexport function PossibleFragmentSpreads(context) {\n  return {\n    InlineFragment: function InlineFragment(node) {\n      var fragType = context.getType();\n      var parentType = context.getParentType();\n\n      if (isCompositeType(fragType) && isCompositeType(parentType) && !doTypesOverlap(context.getSchema(), fragType, parentType)) {\n        context.reportError(new GraphQLError(typeIncompatibleAnonSpreadMessage(parentType, fragType), [node]));\n      }\n    },\n    FragmentSpread: function FragmentSpread(node) {\n      var fragName = node.name.value;\n      var fragType = getFragmentType(context, fragName);\n      var parentType = context.getParentType();\n\n      if (fragType && parentType && !doTypesOverlap(context.getSchema(), fragType, parentType)) {\n        context.reportError(new GraphQLError(typeIncompatibleSpreadMessage(fragName, parentType, fragType), [node]));\n      }\n    }\n  };\n}\n\nfunction getFragmentType(context, name) {\n  var frag = context.getFragment(name);\n\n  if (frag) {\n    var type = typeFromAST(context.getSchema(), frag.typeCondition);\n\n    if (isCompositeType(type)) {\n      return type;\n    }\n  }\n}","map":{"version":3,"names":["GraphQLError","doTypesOverlap","typeFromAST","isCompositeType","typeIncompatibleSpreadMessage","fragName","parentType","fragType","String","typeIncompatibleAnonSpreadMessage","PossibleFragmentSpreads","context","InlineFragment","node","getType","getParentType","getSchema","reportError","FragmentSpread","name","value","getFragmentType","frag","getFragment","type","typeCondition"],"sources":["/Users/roaldmaravillas/ro/sandbox/aws-mobile-appsync-events-starter-react/node_modules/aws-appsync/node_modules/graphql/module/validation/rules/PossibleFragmentSpreads.js"],"sourcesContent":["\nimport { GraphQLError } from '../../error'; /**\n                                             * Copyright (c) 2015-present, Facebook, Inc.\n                                             *\n                                             * This source code is licensed under the MIT license found in the\n                                             * LICENSE file in the root directory of this source tree.\n                                             *\n                                             * \n                                             */\n\nimport { doTypesOverlap } from '../../utilities/typeComparators';\nimport { typeFromAST } from '../../utilities/typeFromAST';\nimport { isCompositeType } from '../../type/definition';\n\n\nexport function typeIncompatibleSpreadMessage(fragName, parentType, fragType) {\n  return 'Fragment \"' + fragName + '\" cannot be spread here as objects of ' + ('type \"' + String(parentType) + '\" can never be of type \"' + String(fragType) + '\".');\n}\n\nexport function typeIncompatibleAnonSpreadMessage(parentType, fragType) {\n  return 'Fragment cannot be spread here as objects of ' + ('type \"' + String(parentType) + '\" can never be of type \"' + String(fragType) + '\".');\n}\n\n/**\n * Possible fragment spread\n *\n * A fragment spread is only valid if the type condition could ever possibly\n * be true: if there is a non-empty intersection of the possible parent types,\n * and possible types which pass the type condition.\n */\nexport function PossibleFragmentSpreads(context) {\n  return {\n    InlineFragment: function InlineFragment(node) {\n      var fragType = context.getType();\n      var parentType = context.getParentType();\n      if (isCompositeType(fragType) && isCompositeType(parentType) && !doTypesOverlap(context.getSchema(), fragType, parentType)) {\n        context.reportError(new GraphQLError(typeIncompatibleAnonSpreadMessage(parentType, fragType), [node]));\n      }\n    },\n    FragmentSpread: function FragmentSpread(node) {\n      var fragName = node.name.value;\n      var fragType = getFragmentType(context, fragName);\n      var parentType = context.getParentType();\n      if (fragType && parentType && !doTypesOverlap(context.getSchema(), fragType, parentType)) {\n        context.reportError(new GraphQLError(typeIncompatibleSpreadMessage(fragName, parentType, fragType), [node]));\n      }\n    }\n  };\n}\n\nfunction getFragmentType(context, name) {\n  var frag = context.getFragment(name);\n  if (frag) {\n    var type = typeFromAST(context.getSchema(), frag.typeCondition);\n    if (isCompositeType(type)) {\n      return type;\n    }\n  }\n}"],"mappings":"AACA,SAASA,YAAT,QAA6B,aAA7B;AAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASC,cAAT,QAA+B,iCAA/B;AACA,SAASC,WAAT,QAA4B,6BAA5B;AACA,SAASC,eAAT,QAAgC,uBAAhC;AAGA,OAAO,SAASC,6BAAT,CAAuCC,QAAvC,EAAiDC,UAAjD,EAA6DC,QAA7D,EAAuE;EAC5E,OAAO,eAAeF,QAAf,GAA0B,wCAA1B,IAAsE,WAAWG,MAAM,CAACF,UAAD,CAAjB,GAAgC,0BAAhC,GAA6DE,MAAM,CAACD,QAAD,CAAnE,GAAgF,IAAtJ,CAAP;AACD;AAED,OAAO,SAASE,iCAAT,CAA2CH,UAA3C,EAAuDC,QAAvD,EAAiE;EACtE,OAAO,mDAAmD,WAAWC,MAAM,CAACF,UAAD,CAAjB,GAAgC,0BAAhC,GAA6DE,MAAM,CAACD,QAAD,CAAnE,GAAgF,IAAnI,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASG,uBAAT,CAAiCC,OAAjC,EAA0C;EAC/C,OAAO;IACLC,cAAc,EAAE,SAASA,cAAT,CAAwBC,IAAxB,EAA8B;MAC5C,IAAIN,QAAQ,GAAGI,OAAO,CAACG,OAAR,EAAf;MACA,IAAIR,UAAU,GAAGK,OAAO,CAACI,aAAR,EAAjB;;MACA,IAAIZ,eAAe,CAACI,QAAD,CAAf,IAA6BJ,eAAe,CAACG,UAAD,CAA5C,IAA4D,CAACL,cAAc,CAACU,OAAO,CAACK,SAAR,EAAD,EAAsBT,QAAtB,EAAgCD,UAAhC,CAA/E,EAA4H;QAC1HK,OAAO,CAACM,WAAR,CAAoB,IAAIjB,YAAJ,CAAiBS,iCAAiC,CAACH,UAAD,EAAaC,QAAb,CAAlD,EAA0E,CAACM,IAAD,CAA1E,CAApB;MACD;IACF,CAPI;IAQLK,cAAc,EAAE,SAASA,cAAT,CAAwBL,IAAxB,EAA8B;MAC5C,IAAIR,QAAQ,GAAGQ,IAAI,CAACM,IAAL,CAAUC,KAAzB;MACA,IAAIb,QAAQ,GAAGc,eAAe,CAACV,OAAD,EAAUN,QAAV,CAA9B;MACA,IAAIC,UAAU,GAAGK,OAAO,CAACI,aAAR,EAAjB;;MACA,IAAIR,QAAQ,IAAID,UAAZ,IAA0B,CAACL,cAAc,CAACU,OAAO,CAACK,SAAR,EAAD,EAAsBT,QAAtB,EAAgCD,UAAhC,CAA7C,EAA0F;QACxFK,OAAO,CAACM,WAAR,CAAoB,IAAIjB,YAAJ,CAAiBI,6BAA6B,CAACC,QAAD,EAAWC,UAAX,EAAuBC,QAAvB,CAA9C,EAAgF,CAACM,IAAD,CAAhF,CAApB;MACD;IACF;EAfI,CAAP;AAiBD;;AAED,SAASQ,eAAT,CAAyBV,OAAzB,EAAkCQ,IAAlC,EAAwC;EACtC,IAAIG,IAAI,GAAGX,OAAO,CAACY,WAAR,CAAoBJ,IAApB,CAAX;;EACA,IAAIG,IAAJ,EAAU;IACR,IAAIE,IAAI,GAAGtB,WAAW,CAACS,OAAO,CAACK,SAAR,EAAD,EAAsBM,IAAI,CAACG,aAA3B,CAAtB;;IACA,IAAItB,eAAe,CAACqB,IAAD,CAAnB,EAA2B;MACzB,OAAOA,IAAP;IACD;EACF;AACF"},"metadata":{},"sourceType":"module"}