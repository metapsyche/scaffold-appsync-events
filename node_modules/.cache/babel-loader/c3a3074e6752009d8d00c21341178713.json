{"ast":null,"code":"import { createContext, createElement, Component } from 'react';\nimport { object, func, node, string, bool, number, oneOfType, arrayOf, any } from 'prop-types';\nimport { InvariantError, invariant } from 'ts-invariant';\nimport { __extends, __assign, __rest } from 'tslib';\nimport { ApolloError, NetworkStatus } from 'apollo-client';\nimport isEqual from 'lodash.isequal';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\nvar ApolloContext = createContext && createContext(undefined);\n\nvar ApolloConsumer = function (props, legacyContext) {\n  function finish(context) {\n    if (!context || !context.client) {\n      throw process.env.NODE_ENV === \"production\" ? new InvariantError() : new InvariantError('Could not find \"client\" in the context of ApolloConsumer. ' + 'Wrap the root component in an <ApolloProvider>.');\n    }\n\n    return props.children(context.client);\n  }\n\n  return ApolloContext ? createElement(ApolloContext.Consumer, null, finish) : finish(legacyContext);\n};\n\nApolloConsumer.contextTypes = {\n  client: object.isRequired\n};\nApolloConsumer.propTypes = {\n  children: func.isRequired\n};\n\nvar ApolloProvider = function (_super) {\n  __extends(ApolloProvider, _super);\n\n  function ApolloProvider(props, context) {\n    var _this = _super.call(this, props, context) || this;\n\n    _this.operations = new Map();\n    process.env.NODE_ENV === \"production\" ? invariant(props.client) : invariant(props.client, 'ApolloProvider was not passed a client instance. Make ' + 'sure you pass in your client via the \"client\" prop.');\n\n    if (!props.client.__operations_cache__) {\n      props.client.__operations_cache__ = _this.operations;\n    }\n\n    return _this;\n  }\n\n  ApolloProvider.prototype.getChildContext = function () {\n    return {\n      client: this.props.client,\n      operations: this.props.client.__operations_cache__\n    };\n  };\n\n  ApolloProvider.prototype.render = function () {\n    return ApolloContext ? createElement(ApolloContext.Provider, {\n      value: this.getChildContext()\n    }, this.props.children) : this.props.children;\n  };\n\n  ApolloProvider.propTypes = {\n    client: object.isRequired,\n    children: node.isRequired\n  };\n  ApolloProvider.childContextTypes = {\n    client: object.isRequired,\n    operations: object\n  };\n  return ApolloProvider;\n}(Component);\n\nvar DocumentType;\n\n(function (DocumentType) {\n  DocumentType[DocumentType[\"Query\"] = 0] = \"Query\";\n  DocumentType[DocumentType[\"Mutation\"] = 1] = \"Mutation\";\n  DocumentType[DocumentType[\"Subscription\"] = 2] = \"Subscription\";\n})(DocumentType || (DocumentType = {}));\n\nvar cache = new Map();\n\nfunction parser(document) {\n  var cached = cache.get(document);\n  if (cached) return cached;\n  var variables, type, name;\n  process.env.NODE_ENV === \"production\" ? invariant(!!document && !!document.kind) : invariant(!!document && !!document.kind, \"Argument of \" + document + \" passed to parser was not a valid GraphQL \" + \"DocumentNode. You may need to use 'graphql-tag' or another method \" + \"to convert your operation into a document\");\n  var fragments = document.definitions.filter(function (x) {\n    return x.kind === 'FragmentDefinition';\n  });\n  var queries = document.definitions.filter(function (x) {\n    return x.kind === 'OperationDefinition' && x.operation === 'query';\n  });\n  var mutations = document.definitions.filter(function (x) {\n    return x.kind === 'OperationDefinition' && x.operation === 'mutation';\n  });\n  var subscriptions = document.definitions.filter(function (x) {\n    return x.kind === 'OperationDefinition' && x.operation === 'subscription';\n  });\n  process.env.NODE_ENV === \"production\" ? invariant(!fragments.length || queries.length || mutations.length || subscriptions.length) : invariant(!fragments.length || queries.length || mutations.length || subscriptions.length, \"Passing only a fragment to 'graphql' is not yet supported. \" + \"You must include a query, subscription or mutation as well\");\n  process.env.NODE_ENV === \"production\" ? invariant(queries.length + mutations.length + subscriptions.length <= 1) : invariant(queries.length + mutations.length + subscriptions.length <= 1, \"react-apollo only supports a query, subscription, or a mutation per HOC. \" + (document + \" had \" + queries.length + \" queries, \" + subscriptions.length + \" \") + (\"subscriptions and \" + mutations.length + \" mutations. \") + \"You can use 'compose' to join multiple operation types to a component\");\n  type = queries.length ? DocumentType.Query : DocumentType.Mutation;\n  if (!queries.length && !mutations.length) type = DocumentType.Subscription;\n  var definitions = queries.length ? queries : mutations.length ? mutations : subscriptions;\n  process.env.NODE_ENV === \"production\" ? invariant(definitions.length === 1) : invariant(definitions.length === 1, \"react-apollo only supports one definition per HOC. \" + document + \" had \" + (definitions.length + \" definitions. \") + \"You can use 'compose' to join multiple operation types to a component\");\n  var definition = definitions[0];\n  variables = definition.variableDefinitions || [];\n\n  if (definition.name && definition.name.kind === 'Name') {\n    name = definition.name.value;\n  } else {\n    name = 'data';\n  }\n\n  var payload = {\n    name: name,\n    type: type,\n    variables: variables\n  };\n  cache.set(document, payload);\n  return payload;\n}\n\nfunction getClient(props, context) {\n  var client = props.client || context.client;\n  process.env.NODE_ENV === \"production\" ? invariant(!!client) : invariant(!!client, 'Could not find \"client\" in the context or passed in as a prop. ' + 'Wrap the root component in an <ApolloProvider>, or pass an ' + 'ApolloClient instance in via props.');\n  return client;\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction is(x, y) {\n  if (x === y) {\n    return x !== 0 || y !== 0 || 1 / x === 1 / y;\n  }\n\n  return x !== x && y !== y;\n}\n\nfunction isObject(obj) {\n  return obj !== null && typeof obj === \"object\";\n}\n\nfunction shallowEqual(objA, objB) {\n  if (is(objA, objB)) {\n    return true;\n  }\n\n  if (!isObject(objA) || !isObject(objB)) {\n    return false;\n  }\n\n  var keys = Object.keys(objA);\n\n  if (keys.length !== Object.keys(objB).length) {\n    return false;\n  }\n\n  return keys.every(function (key) {\n    return hasOwnProperty.call(objB, key) && is(objA[key], objB[key]);\n  });\n}\n\nfunction observableQueryFields(observable) {\n  var fields = {\n    variables: observable.variables,\n    refetch: observable.refetch.bind(observable),\n    fetchMore: observable.fetchMore.bind(observable),\n    updateQuery: observable.updateQuery.bind(observable),\n    startPolling: observable.startPolling.bind(observable),\n    stopPolling: observable.stopPolling.bind(observable),\n    subscribeToMore: observable.subscribeToMore.bind(observable)\n  };\n  return fields;\n}\n\nvar Query = function (_super) {\n  __extends(Query, _super);\n\n  function Query(props, context) {\n    var _this = _super.call(this, props, context) || this;\n\n    _this.hasMounted = false;\n    _this.lastRenderedResult = null;\n\n    _this.startQuerySubscription = function () {\n      if (_this.querySubscription) return;\n      _this.querySubscription = _this.queryObservable.subscribe({\n        next: function (result) {\n          if (_this.lastRenderedResult && _this.lastRenderedResult.loading === result.loading && _this.lastRenderedResult.networkStatus === result.networkStatus && shallowEqual(_this.lastRenderedResult.data, result.data)) {\n            return;\n          }\n\n          _this.updateCurrentData();\n        },\n        error: function (error) {\n          _this.resubscribeToQuery();\n\n          if (!error.hasOwnProperty('graphQLErrors')) throw error;\n\n          _this.updateCurrentData();\n        }\n      });\n    };\n\n    _this.removeQuerySubscription = function () {\n      if (_this.querySubscription) {\n        _this.querySubscription.unsubscribe();\n\n        delete _this.lastRenderedResult;\n        delete _this.querySubscription;\n      }\n    };\n\n    _this.updateCurrentData = function () {\n      _this.handleErrorOrCompleted();\n\n      if (_this.hasMounted) _this.forceUpdate();\n    };\n\n    _this.handleErrorOrCompleted = function () {\n      var result = _this.queryObservable.currentResult();\n\n      var data = result.data,\n          loading = result.loading,\n          error = result.error;\n      var _a = _this.props,\n          onCompleted = _a.onCompleted,\n          onError = _a.onError;\n\n      if (onCompleted && !loading && !error) {\n        onCompleted(data);\n      } else if (onError && !loading && error) {\n        onError(error);\n      }\n    };\n\n    _this.getQueryResult = function () {\n      var result = {\n        data: Object.create(null)\n      };\n      Object.assign(result, observableQueryFields(_this.queryObservable));\n\n      if (_this.props.skip) {\n        result = __assign({}, result, {\n          data: undefined,\n          error: undefined,\n          loading: false\n        });\n      } else {\n        var currentResult = _this.queryObservable.currentResult();\n\n        var loading = currentResult.loading,\n            partial = currentResult.partial,\n            networkStatus = currentResult.networkStatus,\n            errors = currentResult.errors;\n        var error = currentResult.error;\n\n        if (errors && errors.length > 0) {\n          error = new ApolloError({\n            graphQLErrors: errors\n          });\n        }\n\n        var fetchPolicy = _this.queryObservable.options.fetchPolicy;\n        Object.assign(result, {\n          loading: loading,\n          networkStatus: networkStatus,\n          error: error\n        });\n        var previousData = _this.lastRenderedResult ? _this.lastRenderedResult.data : {};\n\n        if (loading) {\n          Object.assign(result.data, previousData, currentResult.data);\n        } else if (error) {\n          Object.assign(result, {\n            data: (_this.queryObservable.getLastResult() || {}).data\n          });\n        } else if (fetchPolicy === 'no-cache' && Object.keys(currentResult.data).length === 0) {\n          result.data = previousData;\n        } else {\n          var partialRefetch = _this.props.partialRefetch;\n\n          if (partialRefetch && currentResult.data !== null && typeof currentResult.data === 'object' && Object.keys(currentResult.data).length === 0 && partial && fetchPolicy !== 'cache-only') {\n            Object.assign(result, {\n              loading: true,\n              networkStatus: NetworkStatus.loading\n            });\n            result.refetch();\n            _this.lastRenderedResult = result;\n            return result;\n          }\n\n          Object.assign(result.data, currentResult.data);\n        }\n      }\n\n      if (!_this.querySubscription) {\n        var oldRefetch_1 = result.refetch;\n\n        result.refetch = function (args) {\n          if (_this.querySubscription) {\n            return oldRefetch_1(args);\n          } else {\n            return new Promise(function (r, f) {\n              _this.refetcherQueue = {\n                resolve: r,\n                reject: f,\n                args: args\n              };\n            });\n          }\n        };\n      }\n\n      setTimeout(function () {\n        if (_this.queryObservable.resetQueryStoreErrors) {\n          _this.queryObservable.resetQueryStoreErrors();\n        } else {\n          var _a = _this.queryObservable,\n              queryManager = _a.queryManager,\n              queryId = _a.queryId;\n          var queryStore = queryManager.queryStore.get(queryId);\n\n          if (queryStore) {\n            queryStore.networkError = null;\n            queryStore.graphQLErrors = [];\n          }\n        }\n      });\n      result.client = _this.client;\n      _this.lastRenderedResult = result;\n      return result;\n    };\n\n    _this.client = getClient(props, context);\n\n    _this.initializeQueryObservable(props);\n\n    return _this;\n  }\n\n  Query.prototype.fetchData = function () {\n    if (this.props.skip) return false;\n\n    var _a = this.props,\n        children = _a.children,\n        ssr = _a.ssr,\n        displayName = _a.displayName,\n        skip = _a.skip,\n        client = _a.client,\n        onCompleted = _a.onCompleted,\n        onError = _a.onError,\n        partialRefetch = _a.partialRefetch,\n        opts = __rest(_a, [\"children\", \"ssr\", \"displayName\", \"skip\", \"client\", \"onCompleted\", \"onError\", \"partialRefetch\"]);\n\n    var fetchPolicy = opts.fetchPolicy;\n    if (ssr === false) return false;\n\n    if (fetchPolicy === 'network-only' || fetchPolicy === 'cache-and-network') {\n      fetchPolicy = 'cache-first';\n    }\n\n    var observable = this.client.watchQuery(__assign({}, opts, {\n      fetchPolicy: fetchPolicy\n    }));\n\n    if (this.context && this.context.renderPromises) {\n      this.context.renderPromises.registerSSRObservable(this, observable);\n    }\n\n    var result = this.queryObservable.currentResult();\n    return result.loading ? observable.result() : false;\n  };\n\n  Query.prototype.componentDidMount = function () {\n    this.hasMounted = true;\n    if (this.props.skip) return;\n    this.startQuerySubscription();\n\n    if (this.refetcherQueue) {\n      var _a = this.refetcherQueue,\n          args = _a.args,\n          resolve = _a.resolve,\n          reject = _a.reject;\n      this.queryObservable.refetch(args).then(resolve).catch(reject);\n    }\n  };\n\n  Query.prototype.componentWillReceiveProps = function (nextProps, nextContext) {\n    if (nextProps.skip && !this.props.skip) {\n      this.queryObservable.resetLastResults();\n      this.removeQuerySubscription();\n      return;\n    }\n\n    var nextClient = getClient(nextProps, nextContext);\n\n    if (shallowEqual(this.props, nextProps) && this.client === nextClient) {\n      return;\n    }\n\n    if (this.client !== nextClient) {\n      this.client = nextClient;\n      this.removeQuerySubscription();\n      this.queryObservable = null;\n    }\n\n    if (this.props.query !== nextProps.query) {\n      this.queryObservable.resetLastResults();\n      this.removeQuerySubscription();\n    }\n\n    this.updateQuery(nextProps);\n    if (nextProps.skip) return;\n    this.startQuerySubscription();\n  };\n\n  Query.prototype.componentWillUnmount = function () {\n    this.removeQuerySubscription();\n    this.hasMounted = false;\n  };\n\n  Query.prototype.componentDidUpdate = function (prevProps) {\n    var isDiffRequest = !isEqual(prevProps.query, this.props.query) || !isEqual(prevProps.variables, this.props.variables);\n\n    if (isDiffRequest) {\n      this.handleErrorOrCompleted();\n    }\n  };\n\n  Query.prototype.render = function () {\n    var _this = this;\n\n    var context = this.context;\n\n    var finish = function () {\n      return _this.props.children(_this.getQueryResult());\n    };\n\n    if (context && context.renderPromises) {\n      return context.renderPromises.addQueryPromise(this, finish);\n    }\n\n    return finish();\n  };\n\n  Query.prototype.extractOptsFromProps = function (props) {\n    this.operation = parser(props.query);\n    process.env.NODE_ENV === \"production\" ? invariant(this.operation.type === DocumentType.Query) : invariant(this.operation.type === DocumentType.Query, \"The <Query /> component requires a graphql query, but got a \" + (this.operation.type === DocumentType.Mutation ? 'mutation' : 'subscription') + \".\");\n    var displayName = props.displayName || 'Query';\n    return __assign({}, props, {\n      displayName: displayName,\n      context: props.context || {},\n      metadata: {\n        reactComponent: {\n          displayName: displayName\n        }\n      }\n    });\n  };\n\n  Query.prototype.initializeQueryObservable = function (props) {\n    var opts = this.extractOptsFromProps(props);\n    this.setOperations(opts);\n\n    if (this.context && this.context.renderPromises) {\n      this.queryObservable = this.context.renderPromises.getSSRObservable(this);\n    }\n\n    if (!this.queryObservable) {\n      this.queryObservable = this.client.watchQuery(opts);\n    }\n  };\n\n  Query.prototype.setOperations = function (props) {\n    if (this.context.operations) {\n      this.context.operations.set(this.operation.name, {\n        query: props.query,\n        variables: props.variables\n      });\n    }\n  };\n\n  Query.prototype.updateQuery = function (props) {\n    if (!this.queryObservable) {\n      this.initializeQueryObservable(props);\n    } else {\n      this.setOperations(props);\n    }\n\n    this.queryObservable.setOptions(this.extractOptsFromProps(props)).catch(function () {\n      return null;\n    });\n  };\n\n  Query.prototype.resubscribeToQuery = function () {\n    this.removeQuerySubscription();\n    var lastError = this.queryObservable.getLastError();\n    var lastResult = this.queryObservable.getLastResult();\n    this.queryObservable.resetLastResults();\n    this.startQuerySubscription();\n    Object.assign(this.queryObservable, {\n      lastError: lastError,\n      lastResult: lastResult\n    });\n  };\n\n  Query.contextTypes = {\n    client: object,\n    operations: object,\n    renderPromises: object\n  };\n  Query.propTypes = {\n    client: object,\n    children: func.isRequired,\n    fetchPolicy: string,\n    notifyOnNetworkStatusChange: bool,\n    onCompleted: func,\n    onError: func,\n    pollInterval: number,\n    query: object.isRequired,\n    variables: object,\n    ssr: bool,\n    partialRefetch: bool,\n    returnPartialData: bool\n  };\n  return Query;\n}(Component);\n\nvar initialState = {\n  loading: false,\n  called: false,\n  error: undefined,\n  data: undefined\n};\n\nvar Mutation = function (_super) {\n  __extends(Mutation, _super);\n\n  function Mutation(props, context) {\n    var _this = _super.call(this, props, context) || this;\n\n    _this.hasMounted = false;\n\n    _this.runMutation = function (options) {\n      if (options === void 0) {\n        options = {};\n      }\n\n      _this.onMutationStart();\n\n      var mutationId = _this.generateNewMutationId();\n\n      return _this.mutate(options).then(function (response) {\n        _this.onMutationCompleted(response, mutationId);\n\n        return response;\n      }).catch(function (e) {\n        _this.onMutationError(e, mutationId);\n\n        if (!_this.props.onError) throw e;\n      });\n    };\n\n    _this.mutate = function (options) {\n      var _a = _this.props,\n          mutation = _a.mutation,\n          variables = _a.variables,\n          optimisticResponse = _a.optimisticResponse,\n          update = _a.update,\n          _b = _a.context,\n          context = _b === void 0 ? {} : _b,\n          _c = _a.awaitRefetchQueries,\n          awaitRefetchQueries = _c === void 0 ? false : _c,\n          fetchPolicy = _a.fetchPolicy;\n\n      var mutateOptions = __assign({}, options);\n\n      var refetchQueries = mutateOptions.refetchQueries || _this.props.refetchQueries;\n\n      if (refetchQueries && refetchQueries.length && Array.isArray(refetchQueries)) {\n        refetchQueries = refetchQueries.map(function (x) {\n          if (typeof x === 'string' && _this.context.operations) return _this.context.operations.get(x) || x;\n          return x;\n        });\n        delete mutateOptions.refetchQueries;\n      }\n\n      var mutateVariables = Object.assign({}, variables, mutateOptions.variables);\n      delete mutateOptions.variables;\n      return _this.client.mutate(__assign({\n        mutation: mutation,\n        optimisticResponse: optimisticResponse,\n        refetchQueries: refetchQueries,\n        awaitRefetchQueries: awaitRefetchQueries,\n        update: update,\n        context: context,\n        fetchPolicy: fetchPolicy,\n        variables: mutateVariables\n      }, mutateOptions));\n    };\n\n    _this.onMutationStart = function () {\n      if (!_this.state.loading && !_this.props.ignoreResults) {\n        _this.setState({\n          loading: true,\n          error: undefined,\n          data: undefined,\n          called: true\n        });\n      }\n    };\n\n    _this.onMutationCompleted = function (response, mutationId) {\n      var _a = _this.props,\n          onCompleted = _a.onCompleted,\n          ignoreResults = _a.ignoreResults;\n      var data = response.data,\n          errors = response.errors;\n      var error = errors && errors.length > 0 ? new ApolloError({\n        graphQLErrors: errors\n      }) : undefined;\n\n      var callOncomplete = function () {\n        return onCompleted ? onCompleted(data) : null;\n      };\n\n      if (_this.hasMounted && _this.isMostRecentMutation(mutationId) && !ignoreResults) {\n        _this.setState({\n          loading: false,\n          data: data,\n          error: error\n        }, callOncomplete);\n      } else {\n        callOncomplete();\n      }\n    };\n\n    _this.onMutationError = function (error, mutationId) {\n      var onError = _this.props.onError;\n\n      var callOnError = function () {\n        return onError ? onError(error) : null;\n      };\n\n      if (_this.hasMounted && _this.isMostRecentMutation(mutationId)) {\n        _this.setState({\n          loading: false,\n          error: error\n        }, callOnError);\n      } else {\n        callOnError();\n      }\n    };\n\n    _this.generateNewMutationId = function () {\n      _this.mostRecentMutationId = _this.mostRecentMutationId + 1;\n      return _this.mostRecentMutationId;\n    };\n\n    _this.isMostRecentMutation = function (mutationId) {\n      return _this.mostRecentMutationId === mutationId;\n    };\n\n    _this.verifyDocumentIsMutation = function (mutation) {\n      var operation = parser(mutation);\n      process.env.NODE_ENV === \"production\" ? invariant(operation.type === DocumentType.Mutation) : invariant(operation.type === DocumentType.Mutation, \"The <Mutation /> component requires a graphql mutation, but got a \" + (operation.type === DocumentType.Query ? 'query' : 'subscription') + \".\");\n    };\n\n    _this.client = getClient(props, context);\n\n    _this.verifyDocumentIsMutation(props.mutation);\n\n    _this.mostRecentMutationId = 0;\n    _this.state = initialState;\n    return _this;\n  }\n\n  Mutation.prototype.componentDidMount = function () {\n    this.hasMounted = true;\n  };\n\n  Mutation.prototype.componentWillUnmount = function () {\n    this.hasMounted = false;\n  };\n\n  Mutation.prototype.componentWillReceiveProps = function (nextProps, nextContext) {\n    var nextClient = getClient(nextProps, nextContext);\n\n    if (shallowEqual(this.props, nextProps) && this.client === nextClient) {\n      return;\n    }\n\n    if (this.props.mutation !== nextProps.mutation) {\n      this.verifyDocumentIsMutation(nextProps.mutation);\n    }\n\n    if (this.client !== nextClient) {\n      this.client = nextClient;\n      this.setState(initialState);\n    }\n  };\n\n  Mutation.prototype.render = function () {\n    var children = this.props.children;\n    var _a = this.state,\n        loading = _a.loading,\n        data = _a.data,\n        error = _a.error,\n        called = _a.called;\n    var result = {\n      called: called,\n      loading: loading,\n      data: data,\n      error: error,\n      client: this.client\n    };\n    return children(this.runMutation, result);\n  };\n\n  Mutation.contextTypes = {\n    client: object,\n    operations: object\n  };\n  Mutation.propTypes = {\n    mutation: object.isRequired,\n    variables: object,\n    optimisticResponse: object,\n    refetchQueries: oneOfType([arrayOf(oneOfType([string, object])), func]),\n    awaitRefetchQueries: bool,\n    update: func,\n    children: func.isRequired,\n    onCompleted: func,\n    onError: func,\n    fetchPolicy: string\n  };\n  return Mutation;\n}(Component);\n\nvar Subscription = function (_super) {\n  __extends(Subscription, _super);\n\n  function Subscription(props, context) {\n    var _this = _super.call(this, props, context) || this;\n\n    _this.initialize = function (props) {\n      if (_this.queryObservable) return;\n      _this.queryObservable = _this.client.subscribe({\n        query: props.subscription,\n        variables: props.variables,\n        fetchPolicy: props.fetchPolicy\n      });\n    };\n\n    _this.startSubscription = function () {\n      if (_this.querySubscription) return;\n      _this.querySubscription = _this.queryObservable.subscribe({\n        next: _this.updateCurrentData,\n        error: _this.updateError,\n        complete: _this.completeSubscription\n      });\n    };\n\n    _this.getInitialState = function () {\n      return {\n        loading: true,\n        error: undefined,\n        data: undefined\n      };\n    };\n\n    _this.updateCurrentData = function (result) {\n      var _a = _this,\n          client = _a.client,\n          onSubscriptionData = _a.props.onSubscriptionData;\n\n      _this.setState({\n        data: result.data,\n        loading: false,\n        error: undefined\n      });\n\n      if (onSubscriptionData) onSubscriptionData({\n        client: client,\n        subscriptionData: result\n      });\n    };\n\n    _this.updateError = function (error) {\n      _this.setState({\n        error: error,\n        loading: false\n      });\n    };\n\n    _this.completeSubscription = function () {\n      var onSubscriptionComplete = _this.props.onSubscriptionComplete;\n      if (onSubscriptionComplete) onSubscriptionComplete();\n\n      _this.endSubscription();\n    };\n\n    _this.endSubscription = function () {\n      if (_this.querySubscription) {\n        _this.querySubscription.unsubscribe();\n\n        delete _this.querySubscription;\n      }\n    };\n\n    _this.client = getClient(props, context);\n\n    _this.initialize(props);\n\n    _this.state = _this.getInitialState();\n    return _this;\n  }\n\n  Subscription.prototype.componentDidMount = function () {\n    this.startSubscription();\n  };\n\n  Subscription.prototype.componentWillReceiveProps = function (nextProps, nextContext) {\n    var nextClient = getClient(nextProps, nextContext);\n\n    if (shallowEqual(this.props.variables, nextProps.variables) && this.client === nextClient && this.props.subscription === nextProps.subscription) {\n      return;\n    }\n\n    var shouldResubscribe = nextProps.shouldResubscribe;\n\n    if (typeof shouldResubscribe === 'function') {\n      shouldResubscribe = !!shouldResubscribe(this.props, nextProps);\n    }\n\n    var shouldNotResubscribe = shouldResubscribe === false;\n\n    if (this.client !== nextClient) {\n      this.client = nextClient;\n    }\n\n    if (!shouldNotResubscribe) {\n      this.endSubscription();\n      delete this.queryObservable;\n      this.initialize(nextProps);\n      this.startSubscription();\n      this.setState(this.getInitialState());\n      return;\n    }\n\n    this.initialize(nextProps);\n    this.startSubscription();\n  };\n\n  Subscription.prototype.componentWillUnmount = function () {\n    this.endSubscription();\n  };\n\n  Subscription.prototype.render = function () {\n    var renderFn = this.props.children;\n    if (!renderFn) return null;\n    var result = Object.assign({}, this.state, {\n      variables: this.props.variables\n    });\n    return renderFn(result);\n  };\n\n  Subscription.contextTypes = {\n    client: object\n  };\n  Subscription.propTypes = {\n    subscription: object.isRequired,\n    variables: object,\n    children: func,\n    onSubscriptionData: func,\n    onSubscriptionComplete: func,\n    shouldResubscribe: oneOfType([func, bool])\n  };\n  return Subscription;\n}(Component);\n\nvar defaultMapPropsToOptions = function () {\n  return {};\n};\n\nvar defaultMapPropsToSkip = function () {\n  return false;\n};\n\nfunction getDisplayName(WrappedComponent) {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n\nfunction calculateVariablesFromProps(operation, props) {\n  var variables = {};\n\n  for (var _i = 0, _a = operation.variables; _i < _a.length; _i++) {\n    var _b = _a[_i],\n        variable = _b.variable,\n        type = _b.type;\n    if (!variable.name || !variable.name.value) continue;\n    var variableName = variable.name.value;\n    var variableProp = props[variableName];\n\n    if (typeof variableProp !== 'undefined') {\n      variables[variableName] = variableProp;\n      continue;\n    }\n\n    if (type.kind !== 'NonNullType') {\n      variables[variableName] = undefined;\n    }\n  }\n\n  return variables;\n}\n\nvar GraphQLBase = function (_super) {\n  __extends(GraphQLBase, _super);\n\n  function GraphQLBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.withRef = false;\n    _this.setWrappedInstance = _this.setWrappedInstance.bind(_this);\n    return _this;\n  }\n\n  GraphQLBase.prototype.getWrappedInstance = function () {\n    process.env.NODE_ENV === \"production\" ? invariant(this.withRef) : invariant(this.withRef, \"To access the wrapped instance, you need to specify \" + \"{ withRef: true } in the options\");\n    return this.wrappedInstance;\n  };\n\n  GraphQLBase.prototype.setWrappedInstance = function (ref) {\n    this.wrappedInstance = ref;\n  };\n\n  return GraphQLBase;\n}(Component);\n\nfunction withQuery(document, operationOptions) {\n  if (operationOptions === void 0) {\n    operationOptions = {};\n  }\n\n  var operation = parser(document);\n  var _a = operationOptions.options,\n      options = _a === void 0 ? defaultMapPropsToOptions : _a,\n      _b = operationOptions.skip,\n      skip = _b === void 0 ? defaultMapPropsToSkip : _b,\n      _c = operationOptions.alias,\n      alias = _c === void 0 ? 'Apollo' : _c;\n  var mapPropsToOptions = options;\n\n  if (typeof mapPropsToOptions !== 'function') {\n    mapPropsToOptions = function () {\n      return options;\n    };\n  }\n\n  var mapPropsToSkip = skip;\n\n  if (typeof mapPropsToSkip !== 'function') {\n    mapPropsToSkip = function () {\n      return skip;\n    };\n  }\n\n  var lastResultProps;\n  return function (WrappedComponent) {\n    var graphQLDisplayName = alias + \"(\" + getDisplayName(WrappedComponent) + \")\";\n\n    var GraphQL = function (_super) {\n      __extends(GraphQL, _super);\n\n      function GraphQL() {\n        return _super !== null && _super.apply(this, arguments) || this;\n      }\n\n      GraphQL.prototype.render = function () {\n        var _this = this;\n\n        var props = this.props;\n        var shouldSkip = mapPropsToSkip(props);\n        var opts = shouldSkip ? Object.create(null) : __assign({}, mapPropsToOptions(props));\n\n        if (!shouldSkip && !opts.variables && operation.variables.length > 0) {\n          opts.variables = calculateVariablesFromProps(operation, props);\n        }\n\n        return createElement(Query, __assign({}, opts, {\n          displayName: graphQLDisplayName,\n          skip: shouldSkip,\n          query: document,\n          warnUnhandledError: true\n        }), function (_a) {\n          var _b, _c;\n\n          var _ = _a.client,\n              data = _a.data,\n              r = __rest(_a, [\"client\", \"data\"]);\n\n          if (operationOptions.withRef) {\n            _this.withRef = true;\n            props = Object.assign({}, props, {\n              ref: _this.setWrappedInstance\n            });\n          }\n\n          if (shouldSkip) {\n            return createElement(WrappedComponent, __assign({}, props, {}));\n          }\n\n          var result = Object.assign(r, data || {});\n          var name = operationOptions.name || 'data';\n          var childProps = (_b = {}, _b[name] = result, _b);\n\n          if (operationOptions.props) {\n            var newResult = (_c = {}, _c[name] = result, _c.ownProps = props, _c);\n            lastResultProps = operationOptions.props(newResult, lastResultProps);\n            childProps = lastResultProps;\n          }\n\n          return createElement(WrappedComponent, __assign({}, props, childProps));\n        });\n      };\n\n      GraphQL.displayName = graphQLDisplayName;\n      GraphQL.WrappedComponent = WrappedComponent;\n      return GraphQL;\n    }(GraphQLBase);\n\n    return hoistNonReactStatics(GraphQL, WrappedComponent, {});\n  };\n}\n\nfunction withMutation(document, operationOptions) {\n  if (operationOptions === void 0) {\n    operationOptions = {};\n  }\n\n  var operation = parser(document);\n  var _a = operationOptions.options,\n      options = _a === void 0 ? defaultMapPropsToOptions : _a,\n      _b = operationOptions.alias,\n      alias = _b === void 0 ? 'Apollo' : _b;\n  var mapPropsToOptions = options;\n  if (typeof mapPropsToOptions !== 'function') mapPropsToOptions = function () {\n    return options;\n  };\n  return function (WrappedComponent) {\n    var graphQLDisplayName = alias + \"(\" + getDisplayName(WrappedComponent) + \")\";\n\n    var GraphQL = function (_super) {\n      __extends(GraphQL, _super);\n\n      function GraphQL() {\n        return _super !== null && _super.apply(this, arguments) || this;\n      }\n\n      GraphQL.prototype.render = function () {\n        var props = this.props;\n        var opts = mapPropsToOptions(props);\n\n        if (operationOptions.withRef) {\n          this.withRef = true;\n          props = Object.assign({}, props, {\n            ref: this.setWrappedInstance\n          });\n        }\n\n        if (!opts.variables && operation.variables.length > 0) {\n          opts.variables = calculateVariablesFromProps(operation, props);\n        }\n\n        return createElement(Mutation, __assign({}, opts, {\n          mutation: document,\n          ignoreResults: true\n        }), function (mutate, _a) {\n          var _b, _c;\n\n          var data = _a.data,\n              r = __rest(_a, [\"data\"]);\n\n          var result = Object.assign(r, data || {});\n          var name = operationOptions.name || 'mutate';\n          var resultName = operationOptions.name ? name + \"Result\" : 'result';\n          var childProps = (_b = {}, _b[name] = mutate, _b[resultName] = result, _b);\n\n          if (operationOptions.props) {\n            var newResult = (_c = {}, _c[name] = mutate, _c[resultName] = result, _c.ownProps = props, _c);\n            childProps = operationOptions.props(newResult);\n          }\n\n          return createElement(WrappedComponent, __assign({}, props, childProps));\n        });\n      };\n\n      GraphQL.displayName = graphQLDisplayName;\n      GraphQL.WrappedComponent = WrappedComponent;\n      return GraphQL;\n    }(GraphQLBase);\n\n    return hoistNonReactStatics(GraphQL, WrappedComponent, {});\n  };\n}\n\nfunction withSubscription(document, operationOptions) {\n  if (operationOptions === void 0) {\n    operationOptions = {};\n  }\n\n  var operation = parser(document);\n  var _a = operationOptions.options,\n      options = _a === void 0 ? defaultMapPropsToOptions : _a,\n      _b = operationOptions.skip,\n      skip = _b === void 0 ? defaultMapPropsToSkip : _b,\n      _c = operationOptions.alias,\n      alias = _c === void 0 ? 'Apollo' : _c,\n      shouldResubscribe = operationOptions.shouldResubscribe;\n  var mapPropsToOptions = options;\n  if (typeof mapPropsToOptions !== 'function') mapPropsToOptions = function () {\n    return options;\n  };\n  var mapPropsToSkip = skip;\n  if (typeof mapPropsToSkip !== 'function') mapPropsToSkip = function () {\n    return skip;\n  };\n  var lastResultProps;\n  return function (WrappedComponent) {\n    var graphQLDisplayName = alias + \"(\" + getDisplayName(WrappedComponent) + \")\";\n\n    var GraphQL = function (_super) {\n      __extends(GraphQL, _super);\n\n      function GraphQL(props) {\n        var _this = _super.call(this, props) || this;\n\n        _this.state = {\n          resubscribe: false\n        };\n        return _this;\n      }\n\n      GraphQL.prototype.componentWillReceiveProps = function (nextProps) {\n        if (!shouldResubscribe) return;\n        this.setState({\n          resubscribe: shouldResubscribe(this.props, nextProps)\n        });\n      };\n\n      GraphQL.prototype.render = function () {\n        var _this = this;\n\n        var props = this.props;\n        var shouldSkip = mapPropsToSkip(props);\n        var opts = shouldSkip ? Object.create(null) : mapPropsToOptions(props);\n\n        if (!shouldSkip && !opts.variables && operation.variables.length > 0) {\n          opts.variables = calculateVariablesFromProps(operation, props);\n        }\n\n        return createElement(Subscription, __assign({}, opts, {\n          displayName: graphQLDisplayName,\n          skip: shouldSkip,\n          subscription: document,\n          shouldResubscribe: this.state.resubscribe\n        }), function (_a) {\n          var _b, _c;\n\n          var data = _a.data,\n              r = __rest(_a, [\"data\"]);\n\n          if (operationOptions.withRef) {\n            _this.withRef = true;\n            props = Object.assign({}, props, {\n              ref: _this.setWrappedInstance\n            });\n          }\n\n          if (shouldSkip) {\n            return createElement(WrappedComponent, __assign({}, props, {}));\n          }\n\n          var result = Object.assign(r, data || {});\n          var name = operationOptions.name || 'data';\n          var childProps = (_b = {}, _b[name] = result, _b);\n\n          if (operationOptions.props) {\n            var newResult = (_c = {}, _c[name] = result, _c.ownProps = props, _c);\n            lastResultProps = operationOptions.props(newResult, lastResultProps);\n            childProps = lastResultProps;\n          }\n\n          return createElement(WrappedComponent, __assign({}, props, childProps));\n        });\n      };\n\n      GraphQL.displayName = graphQLDisplayName;\n      GraphQL.WrappedComponent = WrappedComponent;\n      return GraphQL;\n    }(GraphQLBase);\n\n    return hoistNonReactStatics(GraphQL, WrappedComponent, {});\n  };\n}\n\nfunction graphql(document, operationOptions) {\n  if (operationOptions === void 0) {\n    operationOptions = {};\n  }\n\n  switch (parser(document).type) {\n    case DocumentType.Mutation:\n      return withMutation(document, operationOptions);\n\n    case DocumentType.Subscription:\n      return withSubscription(document, operationOptions);\n\n    case DocumentType.Query:\n    default:\n      return withQuery(document, operationOptions);\n  }\n}\n\nfunction getDisplayName$1(WrappedComponent) {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n\nfunction withApollo(WrappedComponent, operationOptions) {\n  if (operationOptions === void 0) {\n    operationOptions = {};\n  }\n\n  var withDisplayName = \"withApollo(\" + getDisplayName$1(WrappedComponent) + \")\";\n\n  var WithApollo = function (_super) {\n    __extends(WithApollo, _super);\n\n    function WithApollo(props) {\n      var _this = _super.call(this, props) || this;\n\n      _this.setWrappedInstance = _this.setWrappedInstance.bind(_this);\n      return _this;\n    }\n\n    WithApollo.prototype.getWrappedInstance = function () {\n      process.env.NODE_ENV === \"production\" ? invariant(operationOptions.withRef) : invariant(operationOptions.withRef, \"To access the wrapped instance, you need to specify \" + \"{ withRef: true } in the options\");\n      return this.wrappedInstance;\n    };\n\n    WithApollo.prototype.setWrappedInstance = function (ref) {\n      this.wrappedInstance = ref;\n    };\n\n    WithApollo.prototype.render = function () {\n      var _this = this;\n\n      return createElement(ApolloConsumer, null, function (client) {\n        var props = Object.assign({}, _this.props, {\n          client: client,\n          ref: operationOptions.withRef ? _this.setWrappedInstance : undefined\n        });\n        return createElement(WrappedComponent, __assign({}, props));\n      });\n    };\n\n    WithApollo.displayName = withDisplayName;\n    WithApollo.WrappedComponent = WrappedComponent;\n    return WithApollo;\n  }(Component);\n\n  return hoistNonReactStatics(WithApollo, WrappedComponent, {});\n}\n\nfunction makeDefaultQueryInfo() {\n  return {\n    seen: false,\n    observable: null\n  };\n}\n\nvar RenderPromises = function () {\n  function RenderPromises() {\n    this.queryPromises = new Map();\n    this.queryInfoTrie = new Map();\n  }\n\n  RenderPromises.prototype.registerSSRObservable = function (queryInstance, observable) {\n    this.lookupQueryInfo(queryInstance).observable = observable;\n  };\n\n  RenderPromises.prototype.getSSRObservable = function (queryInstance) {\n    return this.lookupQueryInfo(queryInstance).observable;\n  };\n\n  RenderPromises.prototype.addQueryPromise = function (queryInstance, finish) {\n    var info = this.lookupQueryInfo(queryInstance);\n\n    if (!info.seen) {\n      this.queryPromises.set(queryInstance, new Promise(function (resolve) {\n        resolve(queryInstance.fetchData());\n      }));\n      return null;\n    }\n\n    return finish();\n  };\n\n  RenderPromises.prototype.hasPromises = function () {\n    return this.queryPromises.size > 0;\n  };\n\n  RenderPromises.prototype.consumeAndAwaitPromises = function () {\n    var _this = this;\n\n    var promises = [];\n    this.queryPromises.forEach(function (promise, queryInstance) {\n      _this.lookupQueryInfo(queryInstance).seen = true;\n      promises.push(promise);\n    });\n    this.queryPromises.clear();\n    return Promise.all(promises);\n  };\n\n  RenderPromises.prototype.lookupQueryInfo = function (queryInstance) {\n    var queryInfoTrie = this.queryInfoTrie;\n    var _a = queryInstance.props,\n        query = _a.query,\n        variables = _a.variables;\n    var varMap = queryInfoTrie.get(query) || new Map();\n    if (!queryInfoTrie.has(query)) queryInfoTrie.set(query, varMap);\n    var variablesString = JSON.stringify(variables);\n    var info = varMap.get(variablesString) || makeDefaultQueryInfo();\n    if (!varMap.has(variablesString)) varMap.set(variablesString, info);\n    return info;\n  };\n\n  return RenderPromises;\n}();\n\nfunction getDataFromTree(tree, context) {\n  if (context === void 0) {\n    context = {};\n  }\n\n  return getMarkupFromTree({\n    tree: tree,\n    context: context,\n    renderFunction: require(\"react-dom/server\").renderToStaticMarkup\n  });\n}\n\nfunction getMarkupFromTree(_a) {\n  var tree = _a.tree,\n      _b = _a.context,\n      context = _b === void 0 ? {} : _b,\n      _c = _a.renderFunction,\n      renderFunction = _c === void 0 ? require(\"react-dom/server\").renderToStaticMarkup : _c;\n  var renderPromises = new RenderPromises();\n\n  var RenderPromisesProvider = function (_super) {\n    __extends(RenderPromisesProvider, _super);\n\n    function RenderPromisesProvider() {\n      return _super !== null && _super.apply(this, arguments) || this;\n    }\n\n    RenderPromisesProvider.prototype.getChildContext = function () {\n      return __assign({}, context, {\n        renderPromises: renderPromises\n      });\n    };\n\n    RenderPromisesProvider.prototype.render = function () {\n      return tree;\n    };\n\n    RenderPromisesProvider.childContextTypes = {\n      renderPromises: object\n    };\n    return RenderPromisesProvider;\n  }(Component);\n\n  Object.keys(context).forEach(function (key) {\n    RenderPromisesProvider.childContextTypes[key] = any;\n  });\n\n  function process() {\n    var html = renderFunction(createElement(RenderPromisesProvider));\n    return renderPromises.hasPromises() ? renderPromises.consumeAndAwaitPromises().then(process) : html;\n  }\n\n  return Promise.resolve().then(process);\n}\n\nfunction renderToStringWithData(component) {\n  return getMarkupFromTree({\n    tree: component,\n    renderFunction: require(\"react-dom/server\").renderToString\n  });\n}\n\nfunction compose() {\n  var funcs = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    funcs[_i] = arguments[_i];\n  }\n\n  var functions = funcs.reverse();\n  return function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    var firstFunction = functions[0],\n        restFunctions = functions.slice(1);\n    var result = firstFunction.apply(null, args);\n    restFunctions.forEach(function (fnc) {\n      result = fnc.call(null, result);\n    });\n    return result;\n  };\n}\n\nexport { ApolloConsumer, ApolloContext, ApolloProvider, Mutation, Query, RenderPromises, Subscription, compose, getDataFromTree, getMarkupFromTree, graphql, renderToStringWithData, withApollo, withMutation, withQuery, withSubscription };","map":{"version":3,"sources":["../src/ApolloContext.ts","../src/ApolloConsumer.tsx","../src/ApolloProvider.tsx","../src/parser.ts","../src/component-utils.tsx","../src/utils/shallowEqual.ts","../src/Query.tsx","../src/Mutation.tsx","../src/Subscriptions.tsx","../src/hoc-utils.tsx","../src/query-hoc.tsx","../src/mutation-hoc.tsx","../src/subscription-hoc.tsx","../src/graphql.tsx","../src/withApollo.tsx","../src/getDataFromTree.ts","../src/renderToStringWithData.ts","../src/utils/flowRight.ts"],"names":["React.createContext","React.createElement","PropTypes.object","PropTypes.func","PropTypes.node","React.Component","PropTypes.string","PropTypes.bool","PropTypes.number","PropTypes.oneOfType","PropTypes.arrayOf","getDisplayName","PropTypes.any"],"mappings":";;;;;;;IASa,aAAa,GAAGA,aAAmB,IAC9CA,aAAmB,CAAiC,SAAjC,C;;ACArB,IAAM,cAAc,GAClB,UAAC,KAAD,EAAQ,aAAR,EAAqB;EACnB,SAAS,MAAT,CAAgB,OAAhB,EAA4B;IAC1B,IAAI,CAAC,OAAD,IAAY,CAAC,OAAO,CAAC,MAAzB,EAAiC;MAC/B,MAAM,OAAA,CAAA,GAAA,CAAA,QAAA,KAAA,YAAA,GAAA,IAAA,cAAA,EAAA,GAAA,IAAA,cAAA,CAAA,+DAEJ,iDAFI,CAAN;IAID;;IACD,OAAO,KAAK,CAAC,QAAN,CAAe,OAAO,CAAC,MAAvB,CAAP;EACD;;EAED,OAAO,aAAa,GAClBC,aAAAA,CAAC,aAAa,CAAC,QAAfA,EAAuB,IAAvBA,EACG,MADHA,CADkB,GAMlB,MAAM,CAAC,aAAD,CANR;AAQD,CApBH;;AAsBA,cAAc,CAAC,YAAf,GAA8B;EAC5B,MAAM,EAAEC,MAAgB,CAAC;AADG,CAA9B;AAIA,cAAc,CAAC,SAAf,GAA2B;EACzB,QAAQ,EAAEC,IAAc,CAAC;AADA,CAA3B;;ACtBA,IAAA,cAAA,GAAA,UAAA,MAAA,EAAA;EAAoD,SAAA,CAAA,cAAA,EAAA,MAAA,CAAA;;EAalD,SAAA,cAAA,CAAY,KAAZ,EAAgD,OAAhD,EAA4D;IAA5D,IAAA,KAAA,GACE,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,KAAN,EAAa,OAAb,KAAqB,IADvB;;IAFQ,KAAA,CAAA,UAAA,GAAmE,IAAI,GAAJ,EAAnE;IAKN,OAAA,CAAA,GAAA,CAAA,QAAA,KAAA,YAAA,GAAA,SAAA,CAAA,KAAA,CAAA,MAAA,CAAA,GAAA,SAAA,CAAA,KAAA,CAAA,MAAA,EAAA,2DAGI,qDAHJ,CAAA;;IASA,IAAI,CAAE,KAAK,CAAC,MAAN,CAAqB,oBAA3B,EAAiD;MAC9C,KAAK,CAAC,MAAN,CAAqB,oBAArB,GAA4C,KAAI,CAAC,UAAjD;IACF;;;EACF;;EAED,cAAA,CAAA,SAAA,CAAA,eAAA,GAAA,YAAA;IACE,OAAO;MACL,MAAM,EAAE,KAAK,KAAL,CAAW,MADd;MAEL,UAAU,EAAG,KAAK,KAAL,CAAW,MAAX,CAA0B;IAFlC,CAAP;EAID,CALD;;EAOA,cAAA,CAAA,SAAA,CAAA,MAAA,GAAA,YAAA;IACE,OAAO,aAAa,GAClBF,aAAAA,CAAC,aAAa,CAAC,QAAfA,EAAuB;MAAC,KAAK,EAAE,KAAK,eAAL;IAAR,CAAvBA,EACG,KAAK,KAAL,CAAW,QADdA,CADkB,GAKlB,KAAK,KAAL,CAAW,QALb;EAOD,CARD;;EApCO,cAAA,CAAA,SAAA,GAAY;IACjB,MAAM,EAAEC,MAAgB,CAAC,UADR;IAEjB,QAAQ,EAAEE,IAAc,CAAC;EAFR,CAAZ;EAKA,cAAA,CAAA,iBAAA,GAAoB;IACzB,MAAM,EAAEF,MAAgB,CAAC,UADA;IAEzB,UAAU,EAAEA;EAFa,CAApB;EAwCT,OAAA,cAAA;AAAC,CA9CD,CAAoD,SAApD,CAAA;;ACLA,IAAY,YAAZ;;AAAA,CAAA,UAAY,YAAZ,EAAwB;EACtB,YAAA,CAAA,YAAA,CAAA,OAAA,CAAA,GAAA,CAAA,CAAA,GAAA,OAAA;EACA,YAAA,CAAA,YAAA,CAAA,UAAA,CAAA,GAAA,CAAA,CAAA,GAAA,UAAA;EACA,YAAA,CAAA,YAAA,CAAA,cAAA,CAAA,GAAA,CAAA,CAAA,GAAA,cAAA;AACD,CAJD,EAAY,YAAY,KAAZ,YAAY,GAAA,EAAA,CAAxB;;AAYA,IAAM,KAAK,GAAG,IAAI,GAAJ,EAAd;;AAGA,SAAgB,MAAhB,CAAuB,QAAvB,EAA6C;EAC3C,IAAM,MAAM,GAAG,KAAK,CAAC,GAAN,CAAU,QAAV,CAAf;EACA,IAAI,MAAJ,EAAY,OAAO,MAAP;EAEZ,IAAI,SAAJ,EAAe,IAAf,EAAqB,IAArB;EAOA,OAAA,CAAA,GAAA,CACI,QADJ,KACiB,YADjB,GACiB,SAAA,CAAA,CAAA,CAAA,QAAA,IAAA,CAAA,CAEQ,QAAA,CAAA,IAFR,CADjB,GAGyB,SAAA,CAAA,CAAA,CAAA,QAAA,IAAA,CAAA,CAAA,QAAA,CAAA,IAAA,EAAA,iBAAA,QAAA,GAAA,4CAAA,GACrB,oEADqB,GAErB,2CAFqB,CAHzB;EAQA,IAAM,SAAS,GAAG,QAAQ,CAAC,WAAT,CAAqB,MAArB,CAChB,UAAC,CAAD,EAAkB;IAAK,OAAA,CAAC,CAAC,IAAF,KAAW,oBAAX;EAA+B,CADtC,CAAlB;EAIA,IAAM,OAAO,GAAG,QAAQ,CAAC,WAAT,CAAqB,MAArB,CACd,UAAC,CAAD,EAAkB;IAAK,OAAA,CAAC,CAAC,IAAF,KAAW,qBAAX,IAAoC,CAAC,CAAC,SAAF,KAAgB,OAApD;EAA2D,CADpE,CAAhB;EAIA,IAAM,SAAS,GAAG,QAAQ,CAAC,WAAT,CAAqB,MAArB,CAChB,UAAC,CAAD,EAAkB;IAAK,OAAA,CAAC,CAAC,IAAF,KAAW,qBAAX,IAAoC,CAAC,CAAC,SAAF,KAAgB,UAApD;EAA8D,CADrE,CAAlB;EAIA,IAAM,aAAa,GAAG,QAAQ,CAAC,WAAT,CAAqB,MAArB,CACpB,UAAC,CAAD,EAAkB;IAAK,OAAA,CAAC,CAAC,IAAF,KAAW,qBAAX,IAAoC,CAAC,CAAC,SAAF,KAAgB,cAApD;EAAkE,CADrE,CAAtB;EAIA,OAAA,CAAA,GAAA,CACG,QADH,KACY,YADZ,GACgC,SAAA,CAE5B,CAAA,SAAA,CAAA,MAAA,IAAA,OAAA,CAAA,MAAA,IAAA,SAAA,CAAA,MAAA,IAA4D,aAAA,CAAA,MAFhC,CADhC,G,oBAOgB,CAAA,M,IAAY,OAAO,CAAA,MAAP,IAAO,SAAA,CAAA,MAAP,IAAkC,aAAA,CAAA,M,EAAA,gE,6DAP9D;2BAWkC,Y,GAAA,SAAA,CAAA,OAAA,CAAA,MAAA,GAAA,SAAA,CAAA,MAAA,GAAA,aAAA,CAAA,MAAA,IAAA,CAAA,C,GAAA,SAAA,CAAA,OAAA,CAAA,MAAA,GAAA,SAAA,CAAA,MAAA,GAAA,aAAA,CAAA,MAAA,IAAA,CAAA,EAAA,+E,+EAAA,K,gCAIG,CAAA,M,GAAO,cAJV,IAK9B,uEAL8B,C;MAKQ,GAAA,OAAA,CAAA,MAAA,GAAoB,YAAY,CAAC,KAAjC,GAAiC,YAAA,CAAA,Q;EAE3E,IAAM,CAAA,OAAA,CAAA,MAAA,IAAA,CAAA,SAA6B,CAAC,MAApC,E,oBAKE,Y;qCACuC,O,GAAA,SAAA,CAAA,MAAA,GAAA,SAAA,GAAA,a;2EACkC,C,IAAA,SAAA,CAAA,WAAA,CAAA,MAAA,KAAA,CAAA,EAAA,wDAAA,QAAA,GAAA,OAAA,I,YAGxD,M,GAAA,gBAHwD,I,uEAAA,C;EAM3E,IAAI,UAAU,GAAA,WAAA,CAAA,CAAA,CAAd;wBACoB,CAAA,mB,IAAA,E;;;;;IAKd,IAAA,GAAO,MAAP;;;EAEN,IAAA,OAAA,GAAc;IAAA,IAAA,EAAA,IAAA;IAAA,IAAA,EAAA,IAAA;IAAA,SAAA,EAAA;EAAA,CAAd;;;;;SCvFc,S,CACd,K,EACA,O,EAA+B;EAE/B,IAAM,MAAM,GAAG,KAAK,CAAC,MAAN,IAAgB,OAAO,CAAC,MAAvC;EAEA,OAAA,CAAA,GAAA,CACI,QADJ,KAEE,YAFF,GAEE,SAAA,CAAA,CAAA,CAAA,MAAA,CAFF,GAEE,SAAA,CAAA,CAAA,CAAA,MAAA,EAAA,oEACE,6DADF,GAEE,qCAFF,CAFF;EAOA,OAAO,MAAP;AACD;;ACzBO,IAAA,cAAA,GAAA,MAAA,CAAA,SAAA,CAAA,cAAA;;AAER,SAAS,EAAT,CAAY,CAAZ,EAAoB,CAApB,EAA0B;EACxB,IAAI,CAAC,KAAK,CAAV,EAAa;IACX,OAAO,CAAC,KAAK,CAAN,IAAW,CAAC,KAAK,CAAjB,IAAsB,IAAI,CAAJ,KAAU,IAAI,CAA3C;EACD;;EACD,OAAO,CAAC,KAAK,CAAN,IAAW,CAAC,KAAK,CAAxB;AACD;;AAED,SAAS,QAAT,CAAkB,GAAlB,EAA0B;EACxB,OAAO,GAAG,KAAK,IAAR,IAAgB,OAAO,GAAP,KAAe,QAAtC;AACD;;AAED,SAAwB,YAAxB,CAAqC,IAArC,EAAgD,IAAhD,EAAyD;EACvD,IAAI,EAAE,CAAC,IAAD,EAAO,IAAP,CAAN,EAAoB;IAClB,OAAO,IAAP;EACD;;EAED,IAAI,CAAC,QAAQ,CAAC,IAAD,CAAT,IAAmB,CAAC,QAAQ,CAAC,IAAD,CAAhC,EAAwC;IACtC,OAAO,KAAP;EACD;;EAED,IAAM,IAAI,GAAG,MAAM,CAAC,IAAP,CAAY,IAAZ,CAAb;;EAEA,IAAI,IAAI,CAAC,MAAL,KAAgB,MAAM,CAAC,IAAP,CAAY,IAAZ,EAAkB,MAAtC,EAA8C;IAC5C,OAAO,KAAP;EACD;;EAED,OAAO,IAAI,CAAC,KAAL,CACL,UAAA,GAAA,EAAG;IAAI,OAAA,cAAc,CAAC,IAAf,CAAoB,IAApB,EAA0B,GAA1B,KAAkC,EAAE,CAAC,IAAI,CAAC,GAAD,CAAL,EAAY,IAAI,CAAC,GAAD,CAAhB,CAApC;EAA0D,CAD5D,CAAP;AAGD;;ACID,SAAS,qBAAT,CACE,UADF,EACgD;EAE9C,IAAM,MAAM,GAAG;IACb,SAAS,EAAE,UAAU,CAAC,SADT;IAEb,OAAO,EAAE,UAAU,CAAC,OAAX,CAAmB,IAAnB,CAAwB,UAAxB,CAFI;IAGb,SAAS,EAAE,UAAU,CAAC,SAAX,CAAqB,IAArB,CAA0B,UAA1B,CAHE;IAIb,WAAW,EAAE,UAAU,CAAC,WAAX,CAAuB,IAAvB,CAA4B,UAA5B,CAJA;IAKb,YAAY,EAAE,UAAU,CAAC,YAAX,CAAwB,IAAxB,CAA6B,UAA7B,CALD;IAMb,WAAW,EAAE,UAAU,CAAC,WAAX,CAAuB,IAAvB,CAA4B,UAA5B,CANA;IAOb,eAAe,EAAE,UAAU,CAAC,eAAX,CAA2B,IAA3B,CAAgC,UAAhC;EAPJ,CAAf;EAYA,OAAO,MAAP;AACD;;AAkCD,IAAA,KAAA,GAAA,UAAA,MAAA,EAAA;EAAiFG,SAAAA,CAAAA,KAAAA,EAAAA,MAAAA,CAAAA;;EA2C/E,SAAA,KAAA,CAAY,KAAZ,EAAkD,OAAlD,EAAuE;IAAvE,IAAA,KAAA,GACE,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,KAAN,EAAa,OAAb,KAAqB,IADvB;;IAJQ,KAAA,CAAA,UAAA,GAAsB,KAAtB;IAEA,KAAA,CAAA,kBAAA,GAAsD,IAAtD;;IAgLA,KAAA,CAAA,sBAAA,GAAyB,YAAA;MAS/B,IAAI,KAAI,CAAC,iBAAT,EAA4B;MAE5B,KAAI,CAAC,iBAAL,GAAyB,KAAI,CAAC,eAAL,CAAsB,SAAtB,CAAgC;QACvD,IAAI,EAAE,UAAC,MAAD,EAAO;UACX,IACE,KAAI,CAAC,kBAAL,IACA,KAAI,CAAC,kBAAL,CAAwB,OAAxB,KAAoC,MAAM,CAAC,OAD3C,IAEA,KAAI,CAAC,kBAAL,CAAwB,aAAxB,KAA0C,MAAM,CAAC,aAFjD,IAGA,YAAY,CAAC,KAAI,CAAC,kBAAL,CAAwB,IAAzB,EAA+B,MAAM,CAAC,IAAtC,CAJd,EAKE;YACA;UACD;;UAED,KAAI,CAAC,iBAAL;QACD,CAZsD;QAavD,KAAK,EAAE,UAAA,KAAA,EAAK;UACV,KAAI,CAAC,kBAAL;;UAEA,IAAI,CAAC,KAAK,CAAC,cAAN,CAAqB,eAArB,CAAL,EAA4C,MAAM,KAAN;;UAC5C,KAAI,CAAC,iBAAL;QACD;MAlBsD,CAAhC,CAAzB;IAoBD,CA/BO;;IAiCA,KAAA,CAAA,uBAAA,GAA0B,YAAA;MAChC,IAAI,KAAI,CAAC,iBAAT,EAA4B;QAC1B,KAAI,CAAC,iBAAL,CAAuB,WAAvB;;QACA,OAAO,KAAI,CAAC,kBAAZ;QACA,OAAO,KAAI,CAAC,iBAAZ;MACD;IACF,CANO;;IAyBA,KAAA,CAAA,iBAAA,GAAoB,YAAA;MAG1B,KAAI,CAAC,sBAAL;;MAGA,IAAI,KAAI,CAAC,UAAT,EAAqB,KAAI,CAAC,WAAL;IACtB,CAPO;;IASA,KAAA,CAAA,sBAAA,GAAyB,YAAA;MAC/B,IAAM,MAAM,GAAG,KAAI,CAAC,eAAL,CAAsB,aAAtB,EAAf;;MACQ,IAAA,IAAA,GAAA,MAAA,CAAA,IAAA;MAAA,IAAM,OAAA,GAAA,MAAA,CAAA,OAAN;MAAA,IAAe,KAAA,GAAA,MAAA,CAAA,KAAf;MACF,IAAA,EAAA,GAAA,KAAA,CAAA,KAAA;MAAA,IAAE,WAAA,GAAA,EAAA,CAAA,WAAF;MAAA,IAAe,OAAA,GAAA,EAAA,CAAA,OAAf;;MACN,IAAI,WAAW,IAAI,CAAC,OAAhB,IAA2B,CAAC,KAAhC,EAAuC;QACrC,WAAW,CAAC,IAAD,CAAX;MACD,CAFD,MAEO,IAAI,OAAO,IAAI,CAAC,OAAZ,IAAuB,KAA3B,EAAkC;QACvC,OAAO,CAAC,KAAD,CAAP;MACD;IACF,CATO;;IAWA,KAAA,CAAA,cAAA,GAAiB,YAAA;MACvB,IAAI,MAAM,GAAG;QAAE,IAAI,EAAE,MAAM,CAAC,MAAP,CAAc,IAAd;MAAR,CAAb;MAEA,MAAM,CAAC,MAAP,CAAc,MAAd,EAAsB,qBAAqB,CAAC,KAAI,CAAC,eAAN,CAA3C;;MAKA,IAAI,KAAI,CAAC,KAAL,CAAW,IAAf,EAAqB;QACnB,MAAM,GAAA,QAAA,CAAA,EAAA,EACD,MADC,EACK;UACT,IAAI,EAAE,SADG;UAET,KAAK,EAAE,SAFE;UAGT,OAAO,EAAE;QAHA,CADL,CAAN;MAMD,CAPD,MAOO;QACL,IAAM,aAAa,GAAG,KAAI,CAAC,eAAL,CAAsB,aAAtB,EAAtB;;QACQ,IAAA,OAAA,GAAA,aAAA,CAAA,OAAA;QAAA,IAAS,OAAA,GAAA,aAAA,CAAA,OAAT;QAAA,IAAkB,aAAA,GAAA,aAAA,CAAA,aAAlB;QAAA,IAAiC,MAAA,GAAA,aAAA,CAAA,MAAjC;QACF,IAAA,KAAA,GAAA,aAAA,CAAA,KAAA;;QAIN,IAAI,MAAM,IAAI,MAAM,CAAC,MAAP,GAAgB,CAA9B,EAAiC;UAC/B,KAAK,GAAG,IAAI,WAAJ,CAAgB;YAAE,aAAa,EAAE;UAAjB,CAAhB,CAAR;QACD;;QAEO,IAAA,WAAA,GAAA,KAAA,CAAA,eAAA,CAAA,OAAA,CAAA,WAAA;QACR,MAAM,CAAC,MAAP,CAAc,MAAd,EAAsB;UAAE,OAAO,EAAA,OAAT;UAAW,aAAa,EAAA,aAAxB;UAA0B,KAAK,EAAA;QAA/B,CAAtB;QAEA,IAAM,YAAY,GAChB,KAAI,CAAC,kBAAL,GAA0B,KAAI,CAAC,kBAAL,CAAwB,IAAlD,GAAyD,EAD3D;;QAGA,IAAI,OAAJ,EAAa;UACX,MAAM,CAAC,MAAP,CAAc,MAAM,CAAC,IAArB,EAA2B,YAA3B,EAAyC,aAAa,CAAC,IAAvD;QACD,CAFD,MAEO,IAAI,KAAJ,EAAW;UAChB,MAAM,CAAC,MAAP,CAAc,MAAd,EAAsB;YACpB,IAAI,EAAE,CAAC,KAAI,CAAC,eAAL,CAAsB,aAAtB,MAAyC,EAA1C,EAA8C;UADhC,CAAtB;QAGD,CAJM,MAIA,IACL,WAAW,KAAK,UAAhB,IACA,MAAM,CAAC,IAAP,CAAY,aAAa,CAAC,IAA1B,EAAgC,MAAhC,KAA2C,CAFtC,EAGL;UAGA,MAAM,CAAC,IAAP,GAAc,YAAd;QACD,CAPM,MAOA;UACG,IAAA,cAAA,GAAA,KAAA,CAAA,KAAA,CAAA,cAAA;;UACR,IACE,cAAc,IACd,aAAa,CAAC,IAAd,KAAuB,IADvB,IAEA,OAAO,aAAa,CAAC,IAArB,KAA8B,QAF9B,IAGA,MAAM,CAAC,IAAP,CAAY,aAAa,CAAC,IAA1B,EAAgC,MAAhC,KAA2C,CAH3C,IAIA,OAJA,IAKA,WAAW,KAAK,YANlB,EAOE;YASA,MAAM,CAAC,MAAP,CAAc,MAAd,EAAsB;cAAE,OAAO,EAAE,IAAX;cAAiB,aAAa,EAAE,aAAa,CAAC;YAA9C,CAAtB;YACA,MAAM,CAAC,OAAP;YACA,KAAI,CAAC,kBAAL,GAA0B,MAA1B;YACA,OAAO,MAAP;UACD;;UAED,MAAM,CAAC,MAAP,CAAc,MAAM,CAAC,IAArB,EAA2B,aAAa,CAAC,IAAzC;QACD;MACF;;MAqBD,IAAI,CAAC,KAAI,CAAC,iBAAV,EAA6B;QAC3B,IAAM,YAAU,GAAI,MAA2C,CAAC,OAAhE;;QAEC,MAA2C,CAAC,OAA5C,GAAsD,UAAA,IAAA,EAAI;UACzD,IAAI,KAAI,CAAC,iBAAT,EAA4B;YAC1B,OAAO,YAAU,CAAC,IAAD,CAAjB;UACD,CAFD,MAEO;YACL,OAAO,IAAI,OAAJ,CAAY,UAAC,CAAD,EAAI,CAAJ,EAAK;cACtB,KAAI,CAAC,cAAL,GAAsB;gBAAE,OAAO,EAAE,CAAX;gBAAc,MAAM,EAAE,CAAtB;gBAAyB,IAAI,EAAA;cAA7B,CAAtB;YACD,CAFM,CAAP;UAGD;QACF,CARA;MASF;;MAcD,UAAU,CAAC,YAAA;QACT,IAAK,KAAI,CAAC,eAAL,CAA8B,qBAAnC,EAA0D;UAEvD,KAAI,CAAC,eAAL,CAA8B,qBAA9B;QACF,CAHD,MAGO;UAEC,IAAA,EAAA,GAAA,KAAA,CAAA,eAAA;UAAA,IAAE,YAAA,GAAA,EAAA,CAAA,YAAF;UAAA,IAAgB,OAAA,GAAA,EAAA,CAAA,OAAhB;UACN,IAAM,UAAU,GAAG,YAAY,CAAC,UAAb,CAAwB,GAAxB,CAA4B,OAA5B,CAAnB;;UACA,IAAI,UAAJ,EAAgB;YACd,UAAU,CAAC,YAAX,GAA0B,IAA1B;YACA,UAAU,CAAC,aAAX,GAA2B,EAA3B;UACD;QACF;MACF,CAbS,CAAV;MAeA,MAAM,CAAC,MAAP,GAAgB,KAAI,CAAC,MAArB;MACA,KAAI,CAAC,kBAAL,GAA0B,MAA1B;MACA,OAAO,MAAP;IACD,CAxIO;;IAzPN,KAAI,CAAC,MAAL,GAAc,SAAS,CAAC,KAAD,EAAQ,OAAR,CAAvB;;IACA,KAAI,CAAC,yBAAL,CAA+B,KAA/B;;;EACD;;EAGD,KAAA,CAAA,SAAA,CAAA,SAAA,GAAA,YAAA;IACE,IAAI,KAAK,KAAL,CAAW,IAAf,EAAqB,OAAO,KAAP;;IAGrB,IAAM,EAAA,GAAA,KAAA,KAAN;IAAA,IACE,QAAA,GAAA,EAAA,CAAA,QADF;IAAA,IAEE,GAAA,GAAA,EAAA,CAAA,GAFF;IAAA,IAGE,WAAA,GAAA,EAAA,CAAA,WAHF;IAAA,IAIE,IAAA,GAAA,EAAA,CAAA,IAJF;IAAA,IAKE,MAAA,GAAA,EAAA,CAAA,MALF;IAAA,IAME,WAAA,GAAA,EAAA,CAAA,WANF;IAAA,IAOE,OAAA,GAAA,EAAA,CAAA,OAPF;IAAA,IAQE,cAAA,GAAA,EAAA,CAAA,cARF;IAAA,IASE,IAAA,GAAA,MAAA,CAAA,EAAA,EAAA,CAAA,UAAA,EAAA,KAAA,EAAA,aAAA,EAAA,MAAA,EAAA,QAAA,EAAA,aAAA,EAAA,SAAA,EAAA,gBAAA,CAAA,CATF;;IAYM,IAAA,WAAA,GAAA,IAAA,CAAA,WAAA;IACN,IAAI,GAAG,KAAK,KAAZ,EAAmB,OAAO,KAAP;;IACnB,IAAI,WAAW,KAAK,cAAhB,IAAkC,WAAW,KAAK,mBAAtD,EAA2E;MACzE,WAAW,GAAG,aAAd;IACD;;IAED,IAAM,UAAU,GAAG,KAAK,MAAL,CAAY,UAAZ,CAAsB,QAAA,CAAA,EAAA,EACpC,IADoC,EAChC;MACP,WAAW,EAAA;IADJ,CADgC,CAAtB,CAAnB;;IAMA,IAAI,KAAK,OAAL,IAAgB,KAAK,OAAL,CAAa,cAAjC,EAAiD;MAC/C,KAAK,OAAL,CAAa,cAAb,CAA4B,qBAA5B,CAAkD,IAAlD,EAAwD,UAAxD;IACD;;IAED,IAAM,MAAM,GAAG,KAAK,eAAL,CAAsB,aAAtB,EAAf;IAEA,OAAO,MAAM,CAAC,OAAP,GAAiB,UAAU,CAAC,MAAX,EAAjB,GAAuC,KAA9C;EACD,CAnCD;;EAqCA,KAAA,CAAA,SAAA,CAAA,iBAAA,GAAA,YAAA;IACE,KAAK,UAAL,GAAkB,IAAlB;IACA,IAAI,KAAK,KAAL,CAAW,IAAf,EAAqB;IAErB,KAAK,sBAAL;;IACA,IAAI,KAAK,cAAT,EAAyB;MACjB,IAAA,EAAA,GAAA,KAAA,cAAA;MAAA,IAAE,IAAA,GAAA,EAAA,CAAA,IAAF;MAAA,IAAQ,OAAA,GAAA,EAAA,CAAA,OAAR;MAAA,IAAiB,MAAA,GAAA,EAAA,CAAA,MAAjB;MACN,KAAK,eAAL,CAAsB,OAAtB,CAA8B,IAA9B,EACG,IADH,CACQ,OADR,EAEG,KAFH,CAES,MAFT;IAGD;EACF,CAXD;;EAaA,KAAA,CAAA,SAAA,CAAA,yBAAA,GAAA,UAA0B,SAA1B,EAAoE,WAApE,EAA6F;IAE3F,IAAI,SAAS,CAAC,IAAV,IAAkB,CAAC,KAAK,KAAL,CAAW,IAAlC,EAAwC;MACtC,KAAK,eAAL,CAAsB,gBAAtB;MACA,KAAK,uBAAL;MACA;IACD;;IAED,IAAM,UAAU,GAAG,SAAS,CAAC,SAAD,EAAY,WAAZ,CAA5B;;IAEA,IAAI,YAAY,CAAC,KAAK,KAAN,EAAa,SAAb,CAAZ,IAAuC,KAAK,MAAL,KAAgB,UAA3D,EAAuE;MACrE;IACD;;IAED,IAAI,KAAK,MAAL,KAAgB,UAApB,EAAgC;MAC9B,KAAK,MAAL,GAAc,UAAd;MACA,KAAK,uBAAL;MACA,KAAK,eAAL,GAAuB,IAAvB;IACD;;IAED,IAAI,KAAK,KAAL,CAAW,KAAX,KAAqB,SAAS,CAAC,KAAnC,EAA0C;MACxC,KAAK,eAAL,CAAsB,gBAAtB;MACA,KAAK,uBAAL;IACD;;IAED,KAAK,WAAL,CAAiB,SAAjB;IACA,IAAI,SAAS,CAAC,IAAd,EAAoB;IACpB,KAAK,sBAAL;EACD,CA5BD;;EA8BA,KAAA,CAAA,SAAA,CAAA,oBAAA,GAAA,YAAA;IACE,KAAK,uBAAL;IACA,KAAK,UAAL,GAAkB,KAAlB;EACD,CAHD;;EAKA,KAAA,CAAA,SAAA,CAAA,kBAAA,GAAA,UAAmB,SAAnB,EAA2D;IACzD,IAAM,aAAa,GACjB,CAAC,OAAO,CAAC,SAAS,CAAC,KAAX,EAAkB,KAAK,KAAL,CAAW,KAA7B,CAAR,IACA,CAAC,OAAO,CAAC,SAAS,CAAC,SAAX,EAAsB,KAAK,KAAL,CAAW,SAAjC,CAFV;;IAGA,IAAI,aAAJ,EAAmB;MAGjB,KAAK,sBAAL;IACD;EACF,CATD;;EAWA,KAAA,CAAA,SAAA,CAAA,MAAA,GAAA,YAAA;IAAA,IAAA,KAAA,GAAA,IAAA;;IACU,IAAA,OAAA,GAAA,KAAA,OAAA;;IACR,IAAM,MAAM,GAAG,YAAA;MAAM,OAAA,KAAI,CAAC,KAAL,CAAW,QAAX,CAAoB,KAAI,CAAC,cAAL,EAApB,CAAA;IAA0C,CAA/D;;IACA,IAAI,OAAO,IAAI,OAAO,CAAC,cAAvB,EAAuC;MACrC,OAAO,OAAO,CAAC,cAAR,CAAuB,eAAvB,CAAuC,IAAvC,EAA6C,MAA7C,CAAP;IACD;;IACD,OAAO,MAAM,EAAb;EACD,CAPD;;EASQ,KAAA,CAAA,SAAA,CAAA,oBAAA,GAAR,UAA6B,KAA7B,EAAiE;IAC/D,KAAK,SAAL,GAAiB,MAAM,CAAC,KAAK,CAAC,KAAP,CAAvB;IAEA,OAAA,CAAA,GAAA,CAAA,QAAA,KACiB,YADjB,GACiB,SAAA,CAAA,KACf,SADe,CACf,IADe,KACf,YAAA,CAAA,KADe,CADjB,GAEE,SAAA,CAAA,KAAA,SAAA,CACE,IADF,KACO,YAAA,CAAA,KADP,EACO,kEAAA,KAAA,SAAA,CAAA,IAAA,KAAA,YAAA,CAAA,QAAA,GAAA,UAAA,GAAA,cAAA,IAAA,GADP,CAFF;IAOA,IAAM,WAAW,GAAG,KAAK,CAAC,WAAN,IAAqB,OAAzC;IAEA,OAAA,QAAA,CAAA,EAAA,EACK,KADL,EACU;MACR,WAAW,EAAA,WADH;MAER,OAAO,EAAE,KAAK,CAAC,OAAN,IAAiB,EAFlB;MAGR,QAAQ,EAAE;QAAE,cAAc,EAAE;UAAE,WAAW,EAAA;QAAb;MAAlB;IAHF,CADV,CAAA;EAMD,CAlBO;;EAoBA,KAAA,CAAA,SAAA,CAAA,yBAAA,GAAR,UAAkC,KAAlC,EAAsE;IACpE,IAAM,IAAI,GAAG,KAAK,oBAAL,CAA0B,KAA1B,CAAb;IAEA,KAAK,aAAL,CAAmB,IAAnB;;IAKA,IAAI,KAAK,OAAL,IAAgB,KAAK,OAAL,CAAa,cAAjC,EAAiD;MAC/C,KAAK,eAAL,GAAuB,KAAK,OAAL,CAAa,cAAb,CAA4B,gBAA5B,CAA6C,IAA7C,CAAvB;IACD;;IACD,IAAI,CAAC,KAAK,eAAV,EAA2B;MACzB,KAAK,eAAL,GAAuB,KAAK,MAAL,CAAY,UAAZ,CAAuB,IAAvB,CAAvB;IACD;EACF,CAdO;;EAgBA,KAAA,CAAA,SAAA,CAAA,aAAA,GAAR,UAAsB,KAAtB,EAA0D;IACxD,IAAI,KAAK,OAAL,CAAc,UAAlB,EAA8B;MAC5B,KAAK,OAAL,CAAc,UAAd,CAA0B,GAA1B,CAA8B,KAAK,SAAL,CAAgB,IAA9C,EAAoD;QAClD,KAAK,EAAE,KAAK,CAAC,KADqC;QAElD,SAAS,EAAE,KAAK,CAAC;MAFiC,CAApD;IAID;EACF,CAPO;;EASA,KAAA,CAAA,SAAA,CAAA,WAAA,GAAR,UAAoB,KAApB,EAAwD;IAEtD,IAAI,CAAC,KAAK,eAAV,EAA2B;MACzB,KAAK,yBAAL,CAA+B,KAA/B;IACD,CAFD,MAEO;MACL,KAAK,aAAL,CAAmB,KAAnB;IACD;;IAED,KAAK,eAAL,CAAsB,UAAtB,CAAiC,KAAK,oBAAL,CAA0B,KAA1B,CAAjC,EAKG,KALH,CAKS,YAAA;MAAM,OAAA,IAAA;IAAI,CALnB;EAMD,CAdO;;EAyDA,KAAA,CAAA,SAAA,CAAA,kBAAA,GAAR,YAAA;IACE,KAAK,uBAAL;IASA,IAAM,SAAS,GAAG,KAAK,eAAL,CAAsB,YAAtB,EAAlB;IACA,IAAM,UAAU,GAAG,KAAK,eAAL,CAAsB,aAAtB,EAAnB;IACA,KAAK,eAAL,CAAsB,gBAAtB;IACA,KAAK,sBAAL;IACA,MAAM,CAAC,MAAP,CAAc,KAAK,eAAnB,EAAqC;MAAE,SAAS,EAAA,SAAX;MAAa,UAAU,EAAA;IAAvB,CAArC;EACD,CAfO;;EA/PD,KAAA,CAAA,YAAA,GAAe;IACpB,MAAM,EAAEH,MADY;IAEpB,UAAU,EAAEA,MAFQ;IAGpB,cAAc,EAAEA;EAHI,CAAf;EAMA,KAAA,CAAA,SAAA,GAAY;IACjB,MAAM,EAAEA,MADS;IAEjB,QAAQ,EAAEC,IAAc,CAAC,UAFR;IAGjB,WAAW,EAAEG,MAHI;IAIjB,2BAA2B,EAAEC,IAJZ;IAKjB,WAAW,EAAEJ,IALI;IAMjB,OAAO,EAAEA,IANQ;IAOjB,YAAY,EAAEK,MAPG;IAQjB,KAAK,EAAEN,MAAgB,CAAC,UARP;IASjB,SAAS,EAAEA,MATM;IAUjB,GAAG,EAAEK,IAVY;IAWjB,cAAc,EAAEA,IAXC;IAYjB,iBAAiB,EAAEA;EAZF,CAAZ;EAuaT,OAAA,KAAA;AAhbA,CAAA,CAAiFF,SAAjF,CAAA;;ACIA,IAAM,YAAY,GAAG;EACnB,OAAO,EAAE,KADU;EAEnB,MAAM,EAAE,KAFW;EAGnB,KAAK,EAAE,SAHY;EAInB,IAAI,EAAE;AAJa,CAArB;;AAOA,IAAA,QAAA,GAAA,UAAA,MAAA,EAAA;EAAqEA,SAAAA,CAAAA,QAAAA,EAAAA,MAAAA,CAAAA;;EA8BnE,SAAA,QAAA,CAAY,KAAZ,EAAqD,OAArD,EAAiE;IAAjE,IAAA,KAAA,GACE,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,KAAN,EAAa,OAAb,KAAqB,IADvB;;IAFQ,KAAA,CAAA,UAAA,GAAsB,KAAtB;;IAoDA,KAAA,CAAA,WAAA,GAAc,UAAC,OAAD,EAAiD;MAAhD,IAAA,OAAA,KAAA,KAAA,CAAA,EAAA;QAAA,OAAA,GAAA,EAAA;MAAgD;;MACrE,KAAI,CAAC,eAAL;;MACA,IAAM,UAAU,GAAG,KAAI,CAAC,qBAAL,EAAnB;;MAEA,OAAO,KAAI,CAAC,MAAL,CAAY,OAAZ,EACJ,IADI,CACC,UAAC,QAAD,EAAiC;QACrC,KAAI,CAAC,mBAAL,CAAyB,QAAzB,EAAmC,UAAnC;;QACA,OAAO,QAAP;MACD,CAJI,EAKJ,KALI,CAKE,UAAC,CAAD,EAAe;QACpB,KAAI,CAAC,eAAL,CAAqB,CAArB,EAAwB,UAAxB;;QACA,IAAI,CAAC,KAAI,CAAC,KAAL,CAAW,OAAhB,EAAyB,MAAM,CAAN;MAC1B,CARI,CAAP;IASD,CAbO;;IAeA,KAAA,CAAA,MAAA,GAAS,UAAC,OAAD,EAA4C;MACrD,IAAA,EAAA,GAAA,KAAA,CAAA,KAAA;MAAA,IACJ,QAAA,GAAA,EAAA,CAAA,QADI;MAAA,IAEJ,SAAA,GAAA,EAAA,CAAA,SAFI;MAAA,IAGJ,kBAAA,GAAA,EAAA,CAAA,kBAHI;MAAA,IAIJ,MAAA,GAAA,EAAA,CAAA,MAJI;MAAA,IAKJ,EAAA,GAAA,EAAA,CAAA,OALI;MAAA,IAKJ,OAAA,GAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAA,EALI;MAAA,IAMJ,EAAA,GAAA,EAAA,CAAA,mBANI;MAAA,IAMJ,mBAAA,GAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,GAAA,EANI;MAAA,IAOJ,WAAA,GAAA,EAAA,CAAA,WAPI;;MASN,IAAM,aAAa,GAAA,QAAA,CAAA,EAAA,EAAQ,OAAR,CAAnB;;MAEA,IAAI,cAAc,GAAG,aAAa,CAAC,cAAd,IAAgC,KAAI,CAAC,KAAL,CAAW,cAAhE;;MASA,IAAI,cAAc,IAAI,cAAc,CAAC,MAAjC,IAA2C,KAAK,CAAC,OAAN,CAAc,cAAd,CAA/C,EAA8E;QAC5E,cAAc,GAAI,cAAsB,CAAC,GAAvB,CAA2B,UAAC,CAAD,EAA6B;UACxE,IAAI,OAAO,CAAP,KAAa,QAAb,IAAyB,KAAI,CAAC,OAAL,CAAa,UAA1C,EACE,OAAO,KAAI,CAAC,OAAL,CAAa,UAAb,CAAwB,GAAxB,CAA4B,CAA5B,KAAkC,CAAzC;UACF,OAAO,CAAP;QACD,CAJiB,CAAlB;QAKA,OAAO,aAAa,CAAC,cAArB;MACD;;MAED,IAAM,eAAe,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,SAAlB,EAA6B,aAAa,CAAC,SAA3C,CAAxB;MACA,OAAO,aAAa,CAAC,SAArB;MAEA,OAAO,KAAI,CAAC,MAAL,CAAY,MAAZ,CAAkB,QAAA,CAAA;QACvB,QAAQ,EAAA,QADe;QAEvB,kBAAkB,EAAA,kBAFK;QAGvB,cAAc,EAAA,cAHS;QAIvB,mBAAmB,EAAA,mBAJI;QAKvB,MAAM,EAAA,MALiB;QAMvB,OAAO,EAAA,OANgB;QAOvB,WAAW,EAAA,WAPY;QAQvB,SAAS,EAAE;MARY,CAAA,EASpB,aAToB,CAAlB,CAAP;IAWD,CA5CO;;IA8CA,KAAA,CAAA,eAAA,GAAkB,YAAA;MACxB,IAAI,CAAC,KAAI,CAAC,KAAL,CAAW,OAAZ,IAAuB,CAAC,KAAI,CAAC,KAAL,CAAW,aAAvC,EAAsD;QACpD,KAAI,CAAC,QAAL,CAAc;UACZ,OAAO,EAAE,IADG;UAEZ,KAAK,EAAE,SAFK;UAGZ,IAAI,EAAE,SAHM;UAIZ,MAAM,EAAE;QAJI,CAAd;MAMD;IACF,CATO;;IAWA,KAAA,CAAA,mBAAA,GAAsB,UAAC,QAAD,EAAmC,UAAnC,EAAqD;MAC3E,IAAA,EAAA,GAAA,KAAA,CAAA,KAAA;MAAA,IAAE,WAAA,GAAA,EAAA,CAAA,WAAF;MAAA,IAAe,aAAA,GAAA,EAAA,CAAA,aAAf;MAEE,IAAA,IAAA,GAAA,QAAA,CAAA,IAAA;MAAA,IAAM,MAAA,GAAA,QAAA,CAAA,MAAN;MACR,IAAM,KAAK,GACT,MAAM,IAAI,MAAM,CAAC,MAAP,GAAgB,CAA1B,GAA8B,IAAI,WAAJ,CAAgB;QAAE,aAAa,EAAE;MAAjB,CAAhB,CAA9B,GAA2E,SAD7E;;MAGA,IAAM,cAAc,GAAG,YAAA;QAAM,OAAC,WAAW,GAAG,WAAW,CAAC,IAAD,CAAd,GAAgC,IAA5C;MAAiD,CAA9E;;MAEA,IAAI,KAAI,CAAC,UAAL,IAAmB,KAAI,CAAC,oBAAL,CAA0B,UAA1B,CAAnB,IAA4D,CAAC,aAAjE,EAAgF;QAC9E,KAAI,CAAC,QAAL,CAAc;UAAE,OAAO,EAAE,KAAX;UAAkB,IAAI,EAAA,IAAtB;UAAwB,KAAK,EAAA;QAA7B,CAAd,EAA+C,cAA/C;MACD,CAFD,MAEO;QACL,cAAc;MACf;IACF,CAdO;;IAgBA,KAAA,CAAA,eAAA,GAAkB,UAAC,KAAD,EAAqB,UAArB,EAAuC;MACvD,IAAA,OAAA,GAAA,KAAA,CAAA,KAAA,CAAA,OAAA;;MACR,IAAM,WAAW,GAAG,YAAA;QAAM,OAAC,OAAO,GAAG,OAAO,CAAC,KAAD,CAAV,GAAoB,IAA5B;MAAiC,CAA3D;;MAEA,IAAI,KAAI,CAAC,UAAL,IAAmB,KAAI,CAAC,oBAAL,CAA0B,UAA1B,CAAvB,EAA8D;QAC5D,KAAI,CAAC,QAAL,CAAc;UAAE,OAAO,EAAE,KAAX;UAAkB,KAAK,EAAA;QAAvB,CAAd,EAAyC,WAAzC;MACD,CAFD,MAEO;QACL,WAAW;MACZ;IACF,CATO;;IAWA,KAAA,CAAA,qBAAA,GAAwB,YAAA;MAC9B,KAAI,CAAC,oBAAL,GAA4B,KAAI,CAAC,oBAAL,GAA4B,CAAxD;MACA,OAAO,KAAI,CAAC,oBAAZ;IACD,CAHO;;IAKA,KAAA,CAAA,oBAAA,GAAuB,UAAC,UAAD,EAAmB;MAChD,OAAO,KAAI,CAAC,oBAAL,KAA8B,UAArC;IACD,CAFO;;IAIA,KAAA,CAAA,wBAAA,GAA2B,UAAC,QAAD,EAAuB;MACxD,IAAM,SAAS,GAAG,MAAM,CAAC,QAAD,CAAxB;MACA,OAAA,CAAA,GAAA,CAAA,QAAA,KACY,YADZ,GACY,SAAA,CAA8B,SAAA,CAAA,IAAA,KAAA,YAAA,CAAA,QAA9B,CADZ,GAC0C,SAAA,CAAA,SAAA,CAAA,IAAA,KAAA,YAAA,CAAA,QAAA,EAAA,wEAAA,SAAA,CAAA,IAAA,KAAA,YAAA,CAAA,KAAA,GAAA,OAAA,GAAA,cAAA,IAAA,GAAA,CAD1C;IAMD,CARO;;IA5JN,KAAI,CAAC,MAAL,GAAc,SAAS,CAAC,KAAD,EAAQ,OAAR,CAAvB;;IACA,KAAI,CAAC,wBAAL,CAA8B,KAAK,CAAC,QAApC;;IACA,KAAI,CAAC,oBAAL,GAA4B,CAA5B;IACA,KAAI,CAAC,KAAL,GAAa,YAAb;;EACD;;EAED,QAAA,CAAA,SAAA,CAAA,iBAAA,GAAA,YAAA;IACE,KAAK,UAAL,GAAkB,IAAlB;EACD,CAFD;;EAIA,QAAA,CAAA,SAAA,CAAA,oBAAA,GAAA,YAAA;IACE,KAAK,UAAL,GAAkB,KAAlB;EACD,CAFD;;EAIA,QAAA,CAAA,SAAA,CAAA,yBAAA,GAAA,UACE,SADF,EAEE,WAFF,EAE8B;IAE5B,IAAM,UAAU,GAAG,SAAS,CAAC,SAAD,EAAY,WAAZ,CAA5B;;IACA,IAAI,YAAY,CAAC,KAAK,KAAN,EAAa,SAAb,CAAZ,IAAuC,KAAK,MAAL,KAAgB,UAA3D,EAAuE;MACrE;IACD;;IAED,IAAI,KAAK,KAAL,CAAW,QAAX,KAAwB,SAAS,CAAC,QAAtC,EAAgD;MAC9C,KAAK,wBAAL,CAA8B,SAAS,CAAC,QAAxC;IACD;;IAED,IAAI,KAAK,MAAL,KAAgB,UAApB,EAAgC;MAC9B,KAAK,MAAL,GAAc,UAAd;MACA,KAAK,QAAL,CAAc,YAAd;IACD;EACF,CAjBD;;EAmBA,QAAA,CAAA,SAAA,CAAA,MAAA,GAAA,YAAA;IACU,IAAA,QAAA,GAAA,KAAA,KAAA,CAAA,QAAA;IACF,IAAA,EAAA,GAAA,KAAA,KAAA;IAAA,IAAE,OAAA,GAAA,EAAA,CAAA,OAAF;IAAA,IAAW,IAAA,GAAA,EAAA,CAAA,IAAX;IAAA,IAAiB,KAAA,GAAA,EAAA,CAAA,KAAjB;IAAA,IAAwB,MAAA,GAAA,EAAA,CAAA,MAAxB;IAEN,IAAM,MAAM,GAAG;MACb,MAAM,EAAA,MADO;MAEb,OAAO,EAAA,OAFM;MAGb,IAAI,EAAA,IAHS;MAIb,KAAK,EAAA,KAJQ;MAKb,MAAM,EAAE,KAAK;IALA,CAAf;IAQA,OAAO,QAAQ,CAAC,KAAK,WAAN,EAAmB,MAAnB,CAAf;EACD,CAbD;;EA7DO,QAAA,CAAA,YAAA,GAAe;IACpB,MAAM,EAAEH,MADY;IAEpB,UAAU,EAAEA;EAFQ,CAAf;EAKA,QAAA,CAAA,SAAA,GAAY;IACjB,QAAQ,EAAEA,MAAgB,CAAC,UADV;IAEjB,SAAS,EAAEA,MAFM;IAGjB,kBAAkB,EAAEA,MAHH;IAIjB,cAAc,EAAEO,SAAmB,CAAC,CAClCC,OAAiB,CAACD,SAAmB,CAAC,CAACH,MAAD,EAAmBJ,MAAnB,CAAD,CAApB,CADiB,EAElCC,IAFkC,CAAD,CAJlB;IAQjB,mBAAmB,EAAEI,IARJ;IASjB,MAAM,EAAEJ,IATS;IAUjB,QAAQ,EAAEA,IAAc,CAAC,UAVR;IAWjB,WAAW,EAAEA,IAXI;IAYjB,OAAO,EAAEA,IAZQ;IAajB,WAAW,EAAEG;EAbI,CAAZ;EA4LT,OAAA,QAAA;AArMA,CAAA,CAAqED,SAArE,CAAA;;ACnDA,IAAA,YAAA,GAAA,UAAA,MAAA,EAAA;EAA0DA,SAAAA,CAAAA,YAAAA,EAAAA,MAAAA,CAAAA;;EAqBxD,SAAA,YAAA,CAAY,KAAZ,EAAyD,OAAzD,EAAqF;IAArF,IAAA,KAAA,GACE,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,KAAN,EAAa,OAAb,KAAqB,IADvB;;IA4DQ,KAAA,CAAA,UAAA,GAAa,UAAC,KAAD,EAA4C;MAC/D,IAAI,KAAI,CAAC,eAAT,EAA0B;MAC1B,KAAI,CAAC,eAAL,GAAuB,KAAI,CAAC,MAAL,CAAY,SAAZ,CAAsB;QAC3C,KAAK,EAAE,KAAK,CAAC,YAD8B;QAE3C,SAAS,EAAE,KAAK,CAAC,SAF0B;QAG3C,WAAW,EAAE,KAAK,CAAC;MAHwB,CAAtB,CAAvB;IAKD,CAPO;;IASA,KAAA,CAAA,iBAAA,GAAoB,YAAA;MAC1B,IAAI,KAAI,CAAC,iBAAT,EAA4B;MAC5B,KAAI,CAAC,iBAAL,GAAyB,KAAI,CAAC,eAAL,CAAsB,SAAtB,CAAgC;QACvD,IAAI,EAAE,KAAI,CAAC,iBAD4C;QAEvD,KAAK,EAAE,KAAI,CAAC,WAF2C;QAGvD,QAAQ,EAAE,KAAI,CAAC;MAHwC,CAAhC,CAAzB;IAKD,CAPO;;IASA,KAAA,CAAA,eAAA,GAAkB,YAAA;MAAM,OAAC;QAC/B,OAAO,EAAE,IADsB;QAE/B,KAAK,EAAE,SAFwB;QAG/B,IAAI,EAAE;MAHyB,CAAD;IAI9B,CAJM;;IAMA,KAAA,CAAA,iBAAA,GAAoB,UAAC,MAAD,EAAkC;MACtD,IAAA,EAAA,GAAA,KAAA;MAAA,IACJ,MAAA,GAAA,EAAA,CAAA,MADI;MAAA,IAEK,kBAAA,GAAA,EAAA,CAAA,KAAA,CAAA,kBAFL;;MAIN,KAAI,CAAC,QAAL,CAAc;QACZ,IAAI,EAAE,MAAM,CAAC,IADD;QAEZ,OAAO,EAAE,KAFG;QAGZ,KAAK,EAAE;MAHK,CAAd;;MAKA,IAAI,kBAAJ,EAAwB,kBAAkB,CAAC;QAAE,MAAM,EAAA,MAAR;QAAU,gBAAgB,EAAE;MAA5B,CAAD,CAAlB;IACzB,CAXO;;IAaA,KAAA,CAAA,WAAA,GAAc,UAAC,KAAD,EAAW;MAC/B,KAAI,CAAC,QAAL,CAAc;QACZ,KAAK,EAAA,KADO;QAEZ,OAAO,EAAE;MAFG,CAAd;IAID,CALO;;IAOA,KAAA,CAAA,oBAAA,GAAuB,YAAA;MACrB,IAAA,sBAAA,GAAA,KAAA,CAAA,KAAA,CAAA,sBAAA;MACR,IAAI,sBAAJ,EAA4B,sBAAsB;;MAClD,KAAI,CAAC,eAAL;IACD,CAJO;;IAMA,KAAA,CAAA,eAAA,GAAkB,YAAA;MACxB,IAAI,KAAI,CAAC,iBAAT,EAA4B;QAC1B,KAAI,CAAC,iBAAL,CAAuB,WAAvB;;QACA,OAAO,KAAI,CAAC,iBAAZ;MACD;IACF,CALO;;IA3GN,KAAI,CAAC,MAAL,GAAc,SAAS,CAAC,KAAD,EAAQ,OAAR,CAAvB;;IACA,KAAI,CAAC,UAAL,CAAgB,KAAhB;;IACA,KAAI,CAAC,KAAL,GAAa,KAAI,CAAC,eAAL,EAAb;;EACD;;EAED,YAAA,CAAA,SAAA,CAAA,iBAAA,GAAA,YAAA;IACE,KAAK,iBAAL;EACD,CAFD;;EAIA,YAAA,CAAA,SAAA,CAAA,yBAAA,GAAA,UACE,SADF,EAEE,WAFF,EAEkC;IAEhC,IAAM,UAAU,GAAG,SAAS,CAAC,SAAD,EAAY,WAAZ,CAA5B;;IAEA,IACE,YAAY,CAAC,KAAK,KAAL,CAAW,SAAZ,EAAuB,SAAS,CAAC,SAAjC,CAAZ,IACA,KAAK,MAAL,KAAgB,UADhB,IAEA,KAAK,KAAL,CAAW,YAAX,KAA4B,SAAS,CAAC,YAHxC,EAIE;MACA;IACD;;IAED,IAAI,iBAAiB,GAAG,SAAS,CAAC,iBAAlC;;IACA,IAAI,OAAO,iBAAP,KAA6B,UAAjC,EAA6C;MAC3C,iBAAiB,GAAG,CAAC,CAAC,iBAAiB,CAAC,KAAK,KAAN,EAAa,SAAb,CAAvC;IACD;;IACD,IAAM,oBAAoB,GAAG,iBAAiB,KAAK,KAAnD;;IACA,IAAI,KAAK,MAAL,KAAgB,UAApB,EAAgC;MAC9B,KAAK,MAAL,GAAc,UAAd;IACD;;IAED,IAAI,CAAC,oBAAL,EAA2B;MACzB,KAAK,eAAL;MACA,OAAO,KAAK,eAAZ;MACA,KAAK,UAAL,CAAgB,SAAhB;MACA,KAAK,iBAAL;MACA,KAAK,QAAL,CAAc,KAAK,eAAL,EAAd;MACA;IACD;;IACD,KAAK,UAAL,CAAgB,SAAhB;IACA,KAAK,iBAAL;EACD,CAjCD;;EAmCA,YAAA,CAAA,SAAA,CAAA,oBAAA,GAAA,YAAA;IACE,KAAK,eAAL;EACD,CAFD;;EAIA,YAAA,CAAA,SAAA,CAAA,MAAA,GAAA,YAAA;IACE,IAAM,QAAQ,GAAQ,KAAK,KAAL,CAAW,QAAjC;IACA,IAAI,CAAC,QAAL,EAAe,OAAO,IAAP;IACf,IAAM,MAAM,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,KAAK,KAAvB,EAA8B;MAC3C,SAAS,EAAE,KAAK,KAAL,CAAW;IADqB,CAA9B,CAAf;IAGA,OAAO,QAAQ,CAAC,MAAD,CAAf;EACD,CAPD;;EApEO,YAAA,CAAA,YAAA,GAAe;IACpB,MAAM,EAAEH;EADY,CAAf;EAIA,YAAA,CAAA,SAAA,GAAY;IACjB,YAAY,EAAEA,MAAgB,CAAC,UADd;IAEjB,SAAS,EAAEA,MAFM;IAGjB,QAAQ,EAAEC,IAHO;IAIjB,kBAAkB,EAAEA,IAJH;IAKjB,sBAAsB,EAAEA,IALP;IAMjB,iBAAiB,EAAEM,SAAmB,CAAC,CAACN,IAAD,EAAiBI,IAAjB,CAAD;EANrB,CAAZ;EAiIT,OAAA,YAAA;AAzIA,CAAA,CAA0DF,SAA1D,CAAA;;ACvCO,IAAM,wBAAwB,GAAG,YAAA;EAAM,OAAC,EAAD;AAAI,CAA3C;;AAEA,IAAM,qBAAqB,GAAG,YAAA;EAAM,OAAA,KAAA;AAAK,CAAzC;;AAEP,SAAgB,cAAhB,CAAkC,gBAAlC,EAA0E;EACxE,OAAO,gBAAgB,CAAC,WAAjB,IAAgC,gBAAgB,CAAC,IAAjD,IAAyD,WAAhE;AACD;;AAED,SAAgB,2BAAhB,CAAoD,SAApD,EAAoF,KAApF,EAAiG;EAC/F,IAAI,SAAS,GAAuB,EAApC;;EACA,KAA+B,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,SAAS,CAAC,SAAzC,EAA+B,EAAA,GAAA,EAAA,CAAA,MAA/B,EAA+B,EAAA,EAA/B,EAAoD;IAA3C,IAAA,EAAA,GAAA,EAAA,CAAA,EAAA,CAAA;IAAA,IAAE,QAAA,GAAA,EAAA,CAAA,QAAF;IAAA,IAAY,IAAA,GAAA,EAAA,CAAA,IAAZ;IACP,IAAI,CAAC,QAAQ,CAAC,IAAV,IAAkB,CAAC,QAAQ,CAAC,IAAT,CAAc,KAArC,EAA4C;IAE5C,IAAM,YAAY,GAAG,QAAQ,CAAC,IAAT,CAAc,KAAnC;IACA,IAAM,YAAY,GAAI,KAAa,CAAC,YAAD,CAAnC;;IAEA,IAAI,OAAO,YAAP,KAAwB,WAA5B,EAAyC;MACvC,SAAS,CAAC,YAAD,CAAT,GAA0B,YAA1B;MACA;IACD;;IAGD,IAAI,IAAI,CAAC,IAAL,KAAc,aAAlB,EAAiC;MAC/B,SAAS,CAAC,YAAD,CAAT,GAA0B,SAA1B;IACD;EACF;;EACD,OAAO,SAAP;AACD;;AAKD,IAAA,WAAA,GAAA,UAAA,MAAA,EAAA;EAAoEA,SAAAA,CAAAA,WAAAA,EAAAA,MAAAA,CAAAA;;EAQlE,SAAA,WAAA,CAAY,KAAZ,EAAyB;IAAzB,IAAA,KAAA,GACE,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,KAAN,KAAY,IADd;;IAJO,KAAA,CAAA,OAAA,GAAmB,KAAnB;IAML,KAAI,CAAC,kBAAL,GAA0B,KAAI,CAAC,kBAAL,CAAwB,IAAxB,CAA6B,KAA7B,CAA1B;;EACD;;EAED,WAAA,CAAA,SAAA,CAAA,kBAAA,GAAA,YAAA;IACE,OAAA,CAAA,GAAA,CAAA,QAAA,KAAA,YAAA,GAAA,SAAA,CAAA,KAAA,OAAA,CAAA,GAAA,SAAA,CAAA,KAE2D,OAF3D,EAE2D,yDAAA,kCAF3D,CAAA;IAKA,OAAO,KAAK,eAAZ;EACD,CAPD;;EASA,WAAA,CAAA,SAAA,CAAA,kBAAA,GAAA,UAAmB,GAAnB,EAAyD;IACvD,KAAK,eAAL,GAAuB,GAAvB;EACD,CAFD;;EAGF,OAAA,WAAA;AAAC,CAzBD,CAAoEA,SAApE,CAAA;;SCvBgB,S,CAMd,Q,EACA,gB,EAAqF;EAArF,IAAA,gBAAA,KAAA,KAAA,CAAA,EAAA;IAAA,gBAAA,GAAA,EAAA;EAAqF;;EAGrF,IAAM,SAAS,GAAG,MAAM,CAAC,QAAD,CAAxB;EAGE,IAAA,EAAA,GAAA,gBAAA,CAAA,OAAA;EAAA,IAAA,OAAA,GAAA,EAAA,KAAA,KAAA,CAAA,GAAA,wBAAA,GAAA,EAAA;EAAA,IACA,EAAA,GAAA,gBAAA,CAAA,IADA;EAAA,IACA,IAAA,GAAA,EAAA,KAAA,KAAA,CAAA,GAAA,qBAAA,GAAA,EADA;EAAA,IAEA,EAAA,GAAA,gBAAA,CAAA,KAFA;EAAA,IAEA,KAAA,GAAA,EAAA,KAAA,KAAA,CAAA,GAAA,QAAA,GAAA,EAFA;EAKF,IAAI,iBAAiB,GAAG,OAAxB;;EACA,IAAI,OAAO,iBAAP,KAA6B,UAAjC,EAA6C;IAC3C,iBAAiB,GAAG,YAAA;MAAM,OAAA,OAAA;IAAoB,CAA9C;EACD;;EAED,IAAI,cAAc,GAAG,IAArB;;EACA,IAAI,OAAO,cAAP,KAA0B,UAA9B,EAA0C;IACxC,cAAc,GAAG,YAAA;MAAM,OAAA,IAAA;IAAW,CAAlC;EACD;;EAGD,IAAI,eAAJ;EACA,OAAO,UACL,gBADK,EACsD;IAE3D,IAAM,kBAAkB,GAAM,KAAK,GAAA,GAAL,GAAS,cAAc,CAAC,gBAAD,CAAvB,GAAyC,GAAvE;;IACA,IAAA,OAAA,GAAA,UAAA,MAAA,EAAA;MAAsB,SAAA,CAAA,OAAA,EAAA,MAAA,CAAA;;MAAtB,SAAA,OAAA,GAAA;;MAiEC;;MA7DC,OAAA,CAAA,SAAA,CAAA,MAAA,GAAA,YAAA;QAAA,IAAA,KAAA,GAAA,IAAA;;QACE,IAAI,KAAK,GAAG,KAAK,KAAjB;QACA,IAAM,UAAU,GAAG,cAAc,CAAC,KAAD,CAAjC;QACA,IAAM,IAAI,GAAG,UAAU,GAAG,MAAM,CAAC,MAAP,CAAc,IAAd,CAAH,GAAsB,QAAA,CAAA,EAAA,EAAQ,iBAAiB,CAAC,KAAD,CAAzB,CAA7C;;QAEA,IAAI,CAAC,UAAD,IAAe,CAAC,IAAI,CAAC,SAArB,IAAkC,SAAS,CAAC,SAAV,CAAoB,MAApB,GAA6B,CAAnE,EAAsE;UACpE,IAAI,CAAC,SAAL,GAAiB,2BAA2B,CAC1C,SAD0C,EAE1C,KAF0C,CAA5C;QAID;;QACD,OACEJ,aAAAA,CAAC,KAADA,EAAM,QAAA,CAAA,EAAA,EACA,IADA,EACI;UACR,WAAW,EAAE,kBADL;UAER,IAAI,EAAE,UAFE;UAGR,KAAK,EAAE,QAHC;UAIR,kBAAkB,EAAA;QAJV,CADJ,CAANA,EAOG,UAAC,EAAD,EAA0B;;;UAAvB,IAAA,CAAA,GAAA,EAAA,CAAA,MAAA;UAAA,IAAW,IAAA,GAAA,EAAA,CAAA,IAAX;UAAA,IAAiB,CAAA,GAAA,MAAA,CAAA,EAAA,EAAA,CAAA,QAAA,EAAA,MAAA,CAAA,CAAjB;;UACF,IAAI,gBAAgB,CAAC,OAArB,EAA8B;YAC5B,KAAI,CAAC,OAAL,GAAe,IAAf;YACA,KAAK,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,KAAlB,EAAyB;cAC/B,GAAG,EAAE,KAAI,CAAC;YADqB,CAAzB,CAAR;UAGD;;UAED,IAAI,UAAJ,EAAgB;YACd,OACEA,aAAAA,CAAC,gBAADA,EAAiB,QAAA,CAAA,EAAA,EACX,KADW,EAEX,EAFW,CAAjBA,CADF;UAMD;;UAKD,IAAM,MAAM,GAAG,MAAM,CAAC,MAAP,CAAc,CAAd,EAAiB,IAAI,IAAI,EAAzB,CAAf;UACA,IAAM,IAAI,GAAG,gBAAgB,CAAC,IAAjB,IAAyB,MAAtC;UACA,IAAI,UAAU,IAAA,EAAA,GAAA,EAAA,EAAK,EAAA,CAAC,IAAD,CAAA,GAAQ,MAAb,EAAmB,EAAnB,CAAd;;UACA,IAAI,gBAAgB,CAAC,KAArB,EAA4B;YAC1B,IAAM,SAAS,IAAA,EAAA,GAAA,EAAA,EACb,EAAA,CAAC,IAAD,CAAA,GAAQ,MADK,EAEb,EAAA,CAAA,QAAA,GAAU,KAFG,EAGd,EAHc,CAAf;YAIA,eAAe,GAAG,gBAAgB,CAAC,KAAjB,CAAuB,SAAvB,EAAkC,eAAlC,CAAlB;YACA,UAAU,GAAG,eAAb;UACD;;UAED,OACEA,aAAAA,CAAC,gBAADA,EAAiB,QAAA,CAAA,EAAA,EACX,KADW,EAEX,UAFW,CAAjBA,CADF;QAMD,CA7CHA,CADF;MAiDD,CA5DD;;MAHO,OAAA,CAAA,WAAA,GAAc,kBAAd;MACA,OAAA,CAAA,gBAAA,GAAmB,gBAAnB;MA+DT,OAAA,OAAA;IAAC,CAjED,CAAsB,WAAtB,CAAA;;IAoEA,OAAO,oBAAoB,CAAC,OAAD,EAAU,gBAAV,EAA4B,EAA5B,CAA3B;EACD,CAzED;AA0ED;;SCzGe,Y,CAMd,Q,EACA,gB,EAAqF;EAArF,IAAA,gBAAA,KAAA,KAAA,CAAA,EAAA;IAAA,gBAAA,GAAA,EAAA;EAAqF;;EAGrF,IAAM,SAAS,GAAG,MAAM,CAAC,QAAD,CAAxB;EAGQ,IAAA,EAAA,GAAA,gBAAA,CAAA,OAAA;EAAA,IAAA,OAAA,GAAA,EAAA,KAAA,KAAA,CAAA,GAAA,wBAAA,GAAA,EAAA;EAAA,IAAoC,EAAA,GAAA,gBAAA,CAAA,KAApC;EAAA,IAAoC,KAAA,GAAA,EAAA,KAAA,KAAA,CAAA,GAAA,QAAA,GAAA,EAApC;EAER,IAAI,iBAAiB,GAAG,OAAxB;EACA,IAAI,OAAO,iBAAP,KAA6B,UAAjC,EAA6C,iBAAiB,GAAG,YAAA;IAAM,OAAA,OAAA;EAAuB,CAAjD;EAE7C,OAAO,UACL,gBADK,EACsD;IAE3D,IAAM,kBAAkB,GAAM,KAAK,GAAA,GAAL,GAAS,cAAc,CAAC,gBAAD,CAAvB,GAAyC,GAAvE;;IACA,IAAA,OAAA,GAAA,UAAA,MAAA,EAAA;MAAsB,SAAA,CAAA,OAAA,EAAA,MAAA,CAAA;;MAAtB,SAAA,OAAA,GAAA;;MAkDC;;MA/CC,OAAA,CAAA,SAAA,CAAA,MAAA,GAAA,YAAA;QACE,IAAI,KAAK,GAAG,KAAK,KAAjB;QACA,IAAM,IAAI,GAAG,iBAAiB,CAAC,KAAD,CAA9B;;QAEA,IAAI,gBAAgB,CAAC,OAArB,EAA8B;UAC5B,KAAK,OAAL,GAAe,IAAf;UACA,KAAK,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,KAAlB,EAAyB;YAC/B,GAAG,EAAE,KAAK;UADqB,CAAzB,CAAR;QAGD;;QACD,IAAI,CAAC,IAAI,CAAC,SAAN,IAAmB,SAAS,CAAC,SAAV,CAAoB,MAApB,GAA6B,CAApD,EAAuD;UACrD,IAAI,CAAC,SAAL,GAAiB,2BAA2B,CAC1C,SAD0C,EAE1C,KAF0C,CAA5C;QAID;;QAED,OACEA,aAAAA,CAAC,QAADA,EAAS,QAAA,CAAA,EAAA,EAAK,IAAL,EAAS;UAAE,QAAQ,EAAE,QAAZ;UAAsB,aAAa,EAAA;QAAnC,CAAT,CAATA,EACG,UAAC,MAAD,EAAS,EAAT,EAAuB;;;UAAZ,IAAA,IAAA,GAAA,EAAA,CAAA,IAAA;UAAA,IAAM,CAAA,GAAA,MAAA,CAAA,EAAA,EAAA,CAAA,MAAA,CAAA,CAAN;;UAKV,IAAM,MAAM,GAAG,MAAM,CAAC,MAAP,CAAc,CAAd,EAAiB,IAAI,IAAI,EAAzB,CAAf;UACA,IAAM,IAAI,GAAG,gBAAgB,CAAC,IAAjB,IAAyB,QAAtC;UACA,IAAM,UAAU,GAAG,gBAAgB,CAAC,IAAjB,GAA2B,IAAI,GAAA,QAA/B,GAA0C,QAA7D;UACA,IAAI,UAAU,IAAA,EAAA,GAAA,EAAA,EAAK,EAAA,CAAC,IAAD,CAAA,GAAQ,MAAb,EAAqB,EAAA,CAAC,UAAD,CAAA,GAAc,MAAnC,EAAyC,EAAzC,CAAd;;UACA,IAAI,gBAAgB,CAAC,KAArB,EAA4B;YAC1B,IAAM,SAAS,IAAA,EAAA,GAAA,EAAA,EACb,EAAA,CAAC,IAAD,CAAA,GAAQ,MADK,EAEb,EAAA,CAAC,UAAD,CAAA,GAAc,MAFD,EAGb,EAAA,CAAA,QAAA,GAAU,KAHG,EAId,EAJc,CAAf;YAKA,UAAU,GAAG,gBAAgB,CAAC,KAAjB,CAAuB,SAAvB,CAAb;UACD;;UAED,OACEA,aAAAA,CAAC,gBAADA,EAAiB,QAAA,CAAA,EAAA,EACX,KADW,EAEX,UAFW,CAAjBA,CADF;QAMD,CAzBHA,CADF;MA6BD,CA9CD;;MAFO,OAAA,CAAA,WAAA,GAAc,kBAAd;MACA,OAAA,CAAA,gBAAA,GAAmB,gBAAnB;MAgDT,OAAA,OAAA;IAAC,CAlDD,CAAsB,WAAtB,CAAA;;IAqDA,OAAO,oBAAoB,CAAC,OAAD,EAAU,gBAAV,EAA4B,EAA5B,CAA3B;EACD,CA1DD;AA2DD;;SC5Ee,gB,CAMd,Q,EACA,gB,EAAqF;EAArF,IAAA,gBAAA,KAAA,KAAA,CAAA,EAAA;IAAA,gBAAA,GAAA,EAAA;EAAqF;;EAGrF,IAAM,SAAS,GAAG,MAAM,CAAC,QAAD,CAAxB;EAGE,IAAA,EAAA,GAAA,gBAAA,CAAA,OAAA;EAAA,IAAA,OAAA,GAAA,EAAA,KAAA,KAAA,CAAA,GAAA,wBAAA,GAAA,EAAA;EAAA,IACA,EAAA,GAAA,gBAAA,CAAA,IADA;EAAA,IACA,IAAA,GAAA,EAAA,KAAA,KAAA,CAAA,GAAA,qBAAA,GAAA,EADA;EAAA,IAEA,EAAA,GAAA,gBAAA,CAAA,KAFA;EAAA,IAEA,KAAA,GAAA,EAAA,KAAA,KAAA,CAAA,GAAA,QAAA,GAAA,EAFA;EAAA,IAGA,iBAAA,GAAA,gBAAA,CAAA,iBAHA;EAMF,IAAI,iBAAiB,GAAG,OAAxB;EACA,IAAI,OAAO,iBAAP,KAA6B,UAAjC,EAA6C,iBAAiB,GAAG,YAAA;IAAM,OAAA,OAAA;EAAoB,CAA9C;EAE7C,IAAI,cAAc,GAAG,IAArB;EACA,IAAI,OAAO,cAAP,KAA0B,UAA9B,EAA0C,cAAc,GAAG,YAAA;IAAM,OAAA,IAAA;EAAW,CAAlC;EAG1C,IAAI,eAAJ;EACA,OAAO,UACL,gBADK,EACsD;IAE3D,IAAM,kBAAkB,GAAM,KAAK,GAAA,GAAL,GAAS,cAAc,CAAC,gBAAD,CAAvB,GAAyC,GAAvE;;IACA,IAAA,OAAA,GAAA,UAAA,MAAA,EAAA;MAAsB,SAAA,CAAA,OAAA,EAAA,MAAA,CAAA;;MAGpB,SAAA,OAAA,CAAY,KAAZ,EAAyB;QAAzB,IAAA,KAAA,GACE,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,KAAN,KAAY,IADd;;QAEE,KAAI,CAAC,KAAL,GAAa;UAAE,WAAW,EAAE;QAAf,CAAb;;MACD;;MACD,OAAA,CAAA,SAAA,CAAA,yBAAA,GAAA,UAA0B,SAA1B,EAA2C;QACzC,IAAI,CAAC,iBAAL,EAAwB;QACxB,KAAK,QAAL,CAAc;UACZ,WAAW,EAAE,iBAAiB,CAAC,KAAK,KAAN,EAAa,SAAb;QADlB,CAAd;MAGD,CALD;;MAOA,OAAA,CAAA,SAAA,CAAA,MAAA,GAAA,YAAA;QAAA,IAAA,KAAA,GAAA,IAAA;;QACE,IAAI,KAAK,GAAG,KAAK,KAAjB;QACA,IAAM,UAAU,GAAG,cAAc,CAAC,KAAD,CAAjC;QACA,IAAM,IAAI,GAAG,UAAU,GAAG,MAAM,CAAC,MAAP,CAAc,IAAd,CAAH,GAAyB,iBAAiB,CAAC,KAAD,CAAjE;;QAEA,IAAI,CAAC,UAAD,IAAe,CAAC,IAAI,CAAC,SAArB,IAAkC,SAAS,CAAC,SAAV,CAAoB,MAApB,GAA6B,CAAnE,EAAsE;UACpE,IAAI,CAAC,SAAL,GAAiB,2BAA2B,CAC1C,SAD0C,EAE1C,KAF0C,CAA5C;QAID;;QACD,OACEA,aAAAA,CAAC,YAADA,EAAa,QAAA,CAAA,EAAA,EACP,IADO,EACH;UACR,WAAW,EAAE,kBADL;UAER,IAAI,EAAE,UAFE;UAGR,YAAY,EAAE,QAHN;UAIR,iBAAiB,EAAE,KAAK,KAAL,CAAW;QAJtB,CADG,CAAbA,EAOG,UAAC,EAAD,EAAe;;;UAAZ,IAAA,IAAA,GAAA,EAAA,CAAA,IAAA;UAAA,IAAM,CAAA,GAAA,MAAA,CAAA,EAAA,EAAA,CAAA,MAAA,CAAA,CAAN;;UACF,IAAI,gBAAgB,CAAC,OAArB,EAA8B;YAC5B,KAAI,CAAC,OAAL,GAAe,IAAf;YACA,KAAK,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,KAAlB,EAAyB;cAC/B,GAAG,EAAE,KAAI,CAAC;YADqB,CAAzB,CAAR;UAGD;;UAED,IAAI,UAAJ,EAAgB;YACd,OACEA,aAAAA,CAAC,gBAADA,EAAiB,QAAA,CAAA,EAAA,EACX,KADW,EAEX,EAFW,CAAjBA,CADF;UAMD;;UAKD,IAAM,MAAM,GAAG,MAAM,CAAC,MAAP,CAAc,CAAd,EAAiB,IAAI,IAAI,EAAzB,CAAf;UACA,IAAM,IAAI,GAAG,gBAAgB,CAAC,IAAjB,IAAyB,MAAtC;UACA,IAAI,UAAU,IAAA,EAAA,GAAA,EAAA,EAAK,EAAA,CAAC,IAAD,CAAA,GAAQ,MAAb,EAAmB,EAAnB,CAAd;;UACA,IAAI,gBAAgB,CAAC,KAArB,EAA4B;YAC1B,IAAM,SAAS,IAAA,EAAA,GAAA,EAAA,EACb,EAAA,CAAC,IAAD,CAAA,GAAQ,MADK,EAEb,EAAA,CAAA,QAAA,GAAU,KAFG,EAGd,EAHc,CAAf;YAIA,eAAe,GAAG,gBAAgB,CAAC,KAAjB,CAAuB,SAAvB,EAAkC,eAAlC,CAAlB;YACA,UAAU,GAAG,eAAb;UACD;;UAED,OACEA,aAAAA,CAAC,gBAADA,EAAiB,QAAA,CAAA,EAAA,EACX,KADW,EAEX,UAFW,CAAjBA,CADF;QAMD,CA7CHA,CADF;MAiDD,CA5DD;;MAbO,OAAA,CAAA,WAAA,GAAc,kBAAd;MACA,OAAA,CAAA,gBAAA,GAAmB,gBAAnB;MAyET,OAAA,OAAA;IAAC,CA3ED,CAAsB,WAAtB,CAAA;;IA8EA,OAAO,oBAAoB,CAAC,OAAD,EAAU,gBAAV,EAA4B,EAA5B,CAA3B;EACD,CAnFD;AAoFD;;SCrHe,O,CAOd,Q,EACA,gB,EAAqF;EAArF,IAAA,gBAAA,KAAA,KAAA,CAAA,EAAA;IAAA,gBAAA,GAAA,EAAA;EAAqF;;EAErF,QAAQ,MAAM,CAAC,QAAD,CAAN,CAAiB,IAAzB;IACE,KAAK,YAAY,CAAC,QAAlB;MACE,OAAO,YAAY,CAAC,QAAD,EAAW,gBAAX,CAAnB;;IACF,KAAK,YAAY,CAAC,YAAlB;MACE,OAAO,gBAAgB,CAAC,QAAD,EAAW,gBAAX,CAAvB;;IAGF,KAAK,YAAY,CAAC,KAAlB;IACA;MACE,OAAO,SAAS,CAAC,QAAD,EAAW,gBAAX,CAAhB;EATJ;AAWD;;ACtBD,SAASU,gBAAT,CAA2B,gBAA3B,EAAmE;EACjE,OAAO,gBAAgB,CAAC,WAAjB,IAAgC,gBAAgB,CAAC,IAAjD,IAAyD,WAAhE;AACD;;AAID,SAAwB,UAAxB,CACE,gBADF,EAEE,gBAFF,EAEyD;EAAvD,IAAA,gBAAA,KAAA,KAAA,CAAA,EAAA;IAAA,gBAAA,GAAA,EAAA;EAAuD;;EAEvD,IAAM,eAAe,GAAG,gBAAcA,gBAAc,CAAC,gBAAD,CAA5B,GAA8C,GAAtE;;EAEA,IAAA,UAAA,GAAA,UAAA,MAAA,EAAA;IAAyBN,SAAAA,CAAAA,UAAAA,EAAAA,MAAAA,CAAAA;;IAOvB,SAAA,UAAA,CAAY,KAAZ,EAAyB;MAAzB,IAAA,KAAA,GACE,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,KAAN,KAAY,IADd;;MAEE,KAAI,CAAC,kBAAL,GAA0B,KAAI,CAAC,kBAAL,CAAwB,IAAxB,CAA6B,KAA7B,CAA1B;;IACD;;IAED,UAAA,CAAA,SAAA,CAAA,kBAAA,GAAA,YAAA;MACE,OAAA,CAAA,GAAA,CAAA,QAAA,KAAA,YAAA,GAAA,SAAA,CAAA,gBAAA,CAAA,OAAA,CAAA,GAAA,SAAA,CAAA,gBAAA,CAAA,OAAA,EAAA,yDAAA,kCAAA,CAAA;MAKA,OAAO,KAAK,eAAZ;IACD,CAPD;;IASA,UAAA,CAAA,SAAA,CAAA,kBAAA,GAAA,UAAmB,GAAnB,EAAqE;MACnE,KAAK,eAAL,GAAuB,GAAvB;IACD,CAFD;;IAIA,UAAA,CAAA,SAAA,CAAA,MAAA,GAAA,YAAA;MAAA,IAAA,KAAA,GAAA,IAAA;;MACE,OACEJ,aAAAA,CAAC,cAADA,EAAe,IAAfA,EACG,UAAA,MAAA,EAAM;QACL,IAAM,KAAK,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,KAAI,CAAC,KAAvB,EAA8B;UAC1C,MAAM,EAAA,MADoC;UAE1C,GAAG,EAAE,gBAAgB,CAAC,OAAjB,GAA2B,KAAI,CAAC,kBAAhC,GAAqD;QAFhB,CAA9B,CAAd;QAIA,OAAOA,aAAAA,CAAC,gBAADA,EAAiB,QAAA,CAAA,EAAA,EAAK,KAAL,CAAjBA,CAAP;MACD,CAPHA,CADF;IAWD,CAZD;;IAxBO,UAAA,CAAA,WAAA,GAAc,eAAd;IACA,UAAA,CAAA,gBAAA,GAAmB,gBAAnB;IAoCT,OAAA,UAAA;EAtCA,CAAA,CAAyBI,SAAzB,CAAA;;EAyCA,OAAO,oBAAoB,CAAC,UAAD,EAAa,gBAAb,EAA+B,EAA/B,CAA3B;AACD;;ACnDD,SAAS,oBAAT,GAA6B;EAC3B,OAAO;IACL,IAAI,EAAE,KADD;IAEL,UAAU,EAAE;EAFP,CAAP;AAID;;AAED,IAAA,cAAA,GAAA,YAAA;EAAA,SAAA,cAAA,GAAA;IAEU,KAAA,aAAA,GAAgB,IAAI,GAAJ,EAAhB;IAMA,KAAA,aAAA,GAAgB,IAAI,GAAJ,EAAhB;EAqET;;EAlEQ,cAAA,CAAA,SAAA,CAAA,qBAAA,GAAP,UACE,aADF,EAEE,UAFF,EAE8C;IAE5C,KAAK,eAAL,CAAqB,aAArB,EAAoC,UAApC,GAAiD,UAAjD;EACD,CALM;;EAQA,cAAA,CAAA,SAAA,CAAA,gBAAA,GAAP,UAA2C,aAA3C,EAAkF;IAChF,OAAO,KAAK,eAAL,CAAqB,aAArB,EAAoC,UAA3C;EACD,CAFM;;EAIA,cAAA,CAAA,SAAA,CAAA,eAAA,GAAP,UACE,aADF,EAEE,MAFF,EAE+B;IAE7B,IAAM,IAAI,GAAG,KAAK,eAAL,CAAqB,aAArB,CAAb;;IACA,IAAI,CAAC,IAAI,CAAC,IAAV,EAAgB;MACd,KAAK,aAAL,CAAmB,GAAnB,CACE,aADF,EAEE,IAAI,OAAJ,CAAY,UAAA,OAAA,EAAO;QACjB,OAAO,CAAC,aAAa,CAAC,SAAd,EAAD,CAAP;MACD,CAFD,CAFF;MAQA,OAAO,IAAP;IACD;;IACD,OAAO,MAAM,EAAb;EACD,CAjBM;;EAmBA,cAAA,CAAA,SAAA,CAAA,WAAA,GAAP,YAAA;IACE,OAAO,KAAK,aAAL,CAAmB,IAAnB,GAA0B,CAAjC;EACD,CAFM;;EAIA,cAAA,CAAA,SAAA,CAAA,uBAAA,GAAP,YAAA;IAAA,IAAA,KAAA,GAAA,IAAA;;IACE,IAAM,QAAQ,GAAmB,EAAjC;IACA,KAAK,aAAL,CAAmB,OAAnB,CAA2B,UAAC,OAAD,EAAU,aAAV,EAAuB;MAUhD,KAAI,CAAC,eAAL,CAAqB,aAArB,EAAoC,IAApC,GAA2C,IAA3C;MACA,QAAQ,CAAC,IAAT,CAAc,OAAd;IACD,CAZD;IAaA,KAAK,aAAL,CAAmB,KAAnB;IACA,OAAO,OAAO,CAAC,GAAR,CAAY,QAAZ,CAAP;EACD,CAjBM;;EAmBC,cAAA,CAAA,SAAA,CAAA,eAAA,GAAR,UACE,aADF,EACyC;IAE/B,IAAA,aAAA,GAAA,KAAA,aAAA;IACF,IAAA,EAAA,GAAA,aAAA,CAAA,KAAA;IAAA,IAAE,KAAA,GAAA,EAAA,CAAA,KAAF;IAAA,IAAS,SAAA,GAAA,EAAA,CAAA,SAAT;IACN,IAAM,MAAM,GAAG,aAAa,CAAC,GAAd,CAAkB,KAAlB,KAA4B,IAAI,GAAJ,EAA3C;IACA,IAAI,CAAC,aAAa,CAAC,GAAd,CAAkB,KAAlB,CAAL,EAA+B,aAAa,CAAC,GAAd,CAAkB,KAAlB,EAAyB,MAAzB;IAC/B,IAAM,eAAe,GAAG,IAAI,CAAC,SAAL,CAAe,SAAf,CAAxB;IACA,IAAM,IAAI,GAAG,MAAM,CAAC,GAAP,CAAW,eAAX,KAA+B,oBAAoB,EAAhE;IACA,IAAI,CAAC,MAAM,CAAC,GAAP,CAAW,eAAX,CAAL,EAAkC,MAAM,CAAC,GAAP,CAAW,eAAX,EAA4B,IAA5B;IAClC,OAAO,IAAP;EACD,CAXO;;EAYV,OAAA,cAAA;AAAC,CA7ED,EAAA;;SA+EwB,e,CACtB,I,EACA,O,EAAoC;EAApC,IAAA,OAAA,KAAA,KAAA,CAAA,EAAA;IAAA,OAAA,GAAA,EAAA;EAAoC;;EAEpC,OAAO,iBAAiB,CAAC;IACvB,IAAI,EAAA,IADmB;IAEvB,OAAO,EAAA,OAFgB;IAKvB,cAAc,EAAE,OAAO,CAAC,kBAAD,CAAP,CAA4B;EALrB,CAAD,CAAxB;AAOD;;AAQD,SAAgB,iBAAhB,CAAkC,EAAlC,EAO2B;MANzB,IAAA,GAAA,EAAA,CAAA,I;MACA,EAAA,GAAA,EAAA,CAAA,O;MAAA,OAAA,GAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAA,E;MAIA,EAAA,GAAA,EAAA,CAAA,c;MAAA,cAAA,GAAA,EAAA,KAAA,KAAA,CAAA,GAAA,OAAA,CAAA,kBAAA,CAAA,CAAA,oBAAA,GAAA,E;EAEA,IAAM,cAAc,GAAG,IAAI,cAAJ,EAAvB;;EAEA,IAAA,sBAAA,GAAA,UAAA,MAAA,EAAA;IAAqCA,SAAAA,CAAAA,sBAAAA,EAAAA,MAAAA,CAAAA;;IAArC,SAAA,sBAAA,GAAA;;IAiBC;;IAZC,sBAAA,CAAA,SAAA,CAAA,eAAA,GAAA,YAAA;MACE,OAAA,QAAA,CAAA,EAAA,EAAY,OAAZ,EAAmB;QAAE,cAAc,EAAA;MAAhB,CAAnB,CAAA;IACD,CAFD;;IAIA,sBAAA,CAAA,SAAA,CAAA,MAAA,GAAA,YAAA;MAME,OAAO,IAAP;IACD,CAPD;;IARO,sBAAA,CAAA,iBAAA,GAA4C;MACjD,cAAc,EAAEH;IADiC,CAA5C;IAgBT,OAAA,sBAAA;EAjBA,CAAA,CAAqCG,SAArC,CAAA;;EAmBA,MAAM,CAAC,IAAP,CAAY,OAAZ,EAAqB,OAArB,CAA6B,UAAA,GAAA,EAAG;IAC9B,sBAAsB,CAAC,iBAAvB,CAAyC,GAAzC,IAAgDO,GAAhD;EACD,CAFD;;EAIA,SAAS,OAAT,GAAgB;IACd,IAAM,IAAI,GAAG,cAAc,CAACX,aAAmB,CAAC,sBAAD,CAApB,CAA3B;IACA,OAAO,cAAc,CAAC,WAAf,KACH,cAAc,CAAC,uBAAf,GAAyC,IAAzC,CAA8C,OAA9C,CADG,GAEH,IAFJ;EAGD;;EAED,OAAO,OAAO,CAAC,OAAR,GAAkB,IAAlB,CAAuB,OAAvB,CAAP;AACD;;SC1Je,sB,CAAuB,S,EAA4B;EACjE,OAAO,iBAAiB,CAAC;IACvB,IAAI,EAAE,SADiB;IAEvB,cAAc,EAAE,OAAO,CAAC,kBAAD,CAAP,CAA4B;EAFrB,CAAD,CAAxB;AAID;;SCRe,O,GAAO;EAAC,IAAA,KAAA,GAAA,EAAA;;OAAA,IAAA,EAAA,GAAA,C,EAAA,EAAA,GAAA,SAAA,CAAA,M,EAAA,EAAA,E,EAAoB;IAApB,KAAA,CAAA,EAAA,CAAA,GAAA,SAAA,CAAA,EAAA,CAAA;;;EACtB,IAAM,SAAS,GAAG,KAAK,CAAC,OAAN,EAAlB;EACA,OAAO,YAAA;IAAU,IAAA,IAAA,GAAA,EAAA;;SAAA,IAAA,EAAA,GAAA,C,EAAA,EAAA,GAAA,SAAA,CAAA,M,EAAA,EAAA,E,EAAc;MAAd,IAAA,CAAA,EAAA,CAAA,GAAA,SAAA,CAAA,EAAA,CAAA;;;IACR,IAAA,aAAA,GAAA,SAAA,CAAA,CAAA,CAAA;IAAA,IAAe,aAAA,GAAA,SAAA,CAAA,KAAA,CAAA,CAAA,CAAf;IACP,IAAI,MAAM,GAAG,aAAa,CAAC,KAAd,CAAoB,IAApB,EAA0B,IAA1B,CAAb;IACA,aAAa,CAAC,OAAd,CAAsB,UAAC,GAAD,EAAI;MACxB,MAAM,GAAG,GAAG,CAAC,IAAJ,CAAS,IAAT,EAAe,MAAf,CAAT;IACD,CAFD;IAGA,OAAO,MAAP;EACD,CAPD;AAQD","sourcesContent":["import * as React from 'react';\nimport ApolloClient from 'apollo-client';\nimport { DocumentNode } from 'graphql';\n\nexport interface ApolloContextValue {\n  client?: ApolloClient<Object>;\n  operations?: Map<string, { query: DocumentNode; variables: any }>;\n}\n\nexport const ApolloContext = React.createContext &&\n  React.createContext<ApolloContextValue | undefined>(undefined)\n","import * as React from 'react';\nimport * as PropTypes from 'prop-types';\nimport ApolloClient from 'apollo-client';\nimport { ApolloContext } from './ApolloContext';\nimport { InvariantError } from 'ts-invariant';\n\nexport interface ApolloConsumerProps {\n  children: (client: ApolloClient<any>) => React.ReactElement<any> | null;\n}\n\nconst ApolloConsumer: React.StatelessComponent<ApolloConsumerProps> =\n  (props, legacyContext) => {\n    function finish(context: any) {\n      if (!context || !context.client) {\n        throw new InvariantError(\n          'Could not find \"client\" in the context of ApolloConsumer. ' +\n          'Wrap the root component in an <ApolloProvider>.'\n        );\n      }\n      return props.children(context.client);\n    }\n\n    return ApolloContext ? (\n      <ApolloContext.Consumer>\n        {finish}\n      </ApolloContext.Consumer>\n    ) : (\n      // Fall back to legacy context API if React.createContext not available.\n      finish(legacyContext)\n    );\n  };\n\nApolloConsumer.contextTypes = {\n  client: PropTypes.object.isRequired,\n};\n\nApolloConsumer.propTypes = {\n  children: PropTypes.func.isRequired,\n};\n\nexport default ApolloConsumer;\n","import * as React from 'react';\nimport * as PropTypes from 'prop-types';\nimport { Component } from 'react';\nimport ApolloClient from 'apollo-client';\nimport { DocumentNode } from 'graphql';\nimport { ApolloContext } from './ApolloContext';\n\nimport { invariant } from 'ts-invariant';\n\nexport interface ApolloProviderProps<TCache> {\n  client: ApolloClient<TCache>;\n  children: React.ReactNode;\n}\n\nexport default class ApolloProvider<TCache> extends Component<ApolloProviderProps<TCache>> {\n  static propTypes = {\n    client: PropTypes.object.isRequired,\n    children: PropTypes.node.isRequired,\n  };\n\n  static childContextTypes = {\n    client: PropTypes.object.isRequired,\n    operations: PropTypes.object,\n  };\n\n  private operations: Map<string, { query: DocumentNode; variables: any }> = new Map();\n\n  constructor(props: ApolloProviderProps<TCache>, context: any) {\n    super(props, context);\n\n    invariant(\n      props.client,\n      'ApolloProvider was not passed a client instance. Make ' +\n        'sure you pass in your client via the \"client\" prop.',\n    );\n\n    // we have to attach to the client since you could have multiple\n    // providers\n    // XXX this is backwards compat and will be removed in 3.0\n    if (!(props.client as any).__operations_cache__) {\n      (props.client as any).__operations_cache__ = this.operations;\n    }\n  }\n\n  getChildContext() {\n    return {\n      client: this.props.client,\n      operations: (this.props.client as any).__operations_cache__,\n    };\n  }\n\n  render() {\n    return ApolloContext ? (\n      <ApolloContext.Provider value={this.getChildContext()}>\n        {this.props.children}\n      </ApolloContext.Provider>\n    ) : (\n      this.props.children\n    );\n  }\n}\n","import {\n  DocumentNode,\n  DefinitionNode,\n  VariableDefinitionNode,\n  OperationDefinitionNode,\n} from 'graphql';\n\nimport { invariant } from 'ts-invariant';\n\nexport enum DocumentType {\n  Query,\n  Mutation,\n  Subscription,\n}\n\nexport interface IDocumentDefinition {\n  type: DocumentType;\n  name: string;\n  variables: ReadonlyArray<VariableDefinitionNode>;\n}\n\nconst cache = new Map();\n\n// the parser is mainly a safety check for the HOC\nexport function parser(document: DocumentNode): IDocumentDefinition {\n  const cached = cache.get(document);\n  if (cached) return cached;\n  // variables\n  let variables, type, name;\n\n  /*\n\n    Saftey checks for proper usage of react-apollo\n\n  */\n  invariant(\n    !!document && !!document.kind,\n    // tslint:disable-line\n    `Argument of ${document} passed to parser was not a valid GraphQL ` +\n      `DocumentNode. You may need to use 'graphql-tag' or another method ` +\n      `to convert your operation into a document`,\n  );\n\n  const fragments = document.definitions.filter(\n    (x: DefinitionNode) => x.kind === 'FragmentDefinition',\n  );\n\n  const queries = document.definitions.filter(\n    (x: DefinitionNode) => x.kind === 'OperationDefinition' && x.operation === 'query',\n  );\n\n  const mutations = document.definitions.filter(\n    (x: DefinitionNode) => x.kind === 'OperationDefinition' && x.operation === 'mutation',\n  );\n\n  const subscriptions = document.definitions.filter(\n    (x: DefinitionNode) => x.kind === 'OperationDefinition' && x.operation === 'subscription',\n  );\n\n  invariant(\n    !fragments.length || (queries.length || mutations.length || subscriptions.length),\n    `Passing only a fragment to 'graphql' is not yet supported. ` +\n      `You must include a query, subscription or mutation as well`,\n  );\n\n  invariant(\n    queries.length + mutations.length + subscriptions.length <= 1,\n    // tslint:disable-line\n    `react-apollo only supports a query, subscription, or a mutation per HOC. ` +\n      `${document} had ${queries.length} queries, ${subscriptions.length} ` +\n      `subscriptions and ${mutations.length} mutations. ` +\n      `You can use 'compose' to join multiple operation types to a component`,\n  );\n\n  type = queries.length ? DocumentType.Query : DocumentType.Mutation;\n  if (!queries.length && !mutations.length) type = DocumentType.Subscription;\n\n  const definitions = queries.length ? queries : mutations.length ? mutations : subscriptions;\n\n  invariant(\n    definitions.length === 1,\n    // tslint:disable-line\n    `react-apollo only supports one definition per HOC. ${document} had ` +\n      `${definitions.length} definitions. ` +\n      `You can use 'compose' to join multiple operation types to a component`,\n  );\n\n  const definition = definitions[0] as OperationDefinitionNode;\n  variables = definition.variableDefinitions || [];\n\n  if (definition.name && definition.name.kind === 'Name') {\n    name = definition.name.value;\n  } else {\n    name = 'data'; // fallback to using data if no name\n  }\n\n  const payload = { name, type, variables };\n  cache.set(document, payload);\n  return payload;\n}\n","import ApolloClient from 'apollo-client';\nimport { invariant } from 'ts-invariant';\n\nexport interface CommonComponentProps {\n  client?: ApolloClient<Object>;\n}\n\nexport interface CommonComponentContext {\n  client?: ApolloClient<Object>;\n}\n\nexport function getClient(\n  props: CommonComponentProps,\n  context: CommonComponentContext,\n): ApolloClient<Object> {\n  const client = props.client || context.client;\n\n  invariant(\n    !!client,\n    'Could not find \"client\" in the context or passed in as a prop. ' +\n      'Wrap the root component in an <ApolloProvider>, or pass an ' +\n      'ApolloClient instance in via props.',\n  );\n\n  return client as ApolloClient<Object>;\n}\n","const { hasOwnProperty } = Object.prototype;\n\nfunction is(x: any, y: any) {\n  if (x === y) {\n    return x !== 0 || y !== 0 || 1 / x === 1 / y;\n  }\n  return x !== x && y !== y;\n}\n\nfunction isObject(obj: any): obj is { [key: string]: any } {\n  return obj !== null && typeof obj === \"object\";\n}\n\nexport default function shallowEqual(objA: any, objB: any) {\n  if (is(objA, objB)) {\n    return true;\n  }\n\n  if (!isObject(objA) || !isObject(objB)) {\n    return false;\n  }\n\n  const keys = Object.keys(objA);\n\n  if (keys.length !== Object.keys(objB).length) {\n    return false;\n  }\n\n  return keys.every(\n    key => hasOwnProperty.call(objB, key) && is(objA[key], objB[key]),\n  );\n}\n","import * as React from 'react';\nimport * as PropTypes from 'prop-types';\nimport ApolloClient, {\n  ObservableQuery,\n  ApolloError,\n  ApolloQueryResult,\n  NetworkStatus,\n  FetchMoreOptions,\n  FetchMoreQueryOptions,\n  ApolloCurrentResult\n} from 'apollo-client';\nimport { DocumentNode } from 'graphql';\nimport { ZenObservable } from 'zen-observable-ts';\nimport { OperationVariables, QueryControls, QueryOpts } from './types';\nimport { parser, DocumentType, IDocumentDefinition } from './parser';\nimport { getClient } from './component-utils';\nimport { RenderPromises } from './getDataFromTree';\n\nimport isEqual from 'lodash.isequal';\nimport shallowEqual from './utils/shallowEqual';\nimport { invariant } from 'ts-invariant';\n\nexport type ObservableQueryFields<TData, TVariables> = Pick<\n  ObservableQuery<TData, TVariables>,\n  'startPolling' | 'stopPolling' | 'subscribeToMore' | 'updateQuery' | 'refetch' | 'variables'\n> & {\n  fetchMore: (<K extends keyof TVariables>(\n    fetchMoreOptions: FetchMoreQueryOptions<TVariables, K> & FetchMoreOptions<TData, TVariables>,\n  ) => Promise<ApolloQueryResult<TData>>) &\n    (<TData2, TVariables2, K extends keyof TVariables2>(\n      fetchMoreOptions: { query?: DocumentNode } & FetchMoreQueryOptions<TVariables2, K> &\n        FetchMoreOptions<TData2, TVariables2>,\n    ) => Promise<ApolloQueryResult<TData2>>);\n};\n\nfunction observableQueryFields<TData, TVariables>(\n  observable: ObservableQuery<TData, TVariables>,\n): ObservableQueryFields<TData, TVariables> {\n  const fields = {\n    variables: observable.variables,\n    refetch: observable.refetch.bind(observable),\n    fetchMore: observable.fetchMore.bind(observable),\n    updateQuery: observable.updateQuery.bind(observable),\n    startPolling: observable.startPolling.bind(observable),\n    stopPolling: observable.stopPolling.bind(observable),\n    subscribeToMore: observable.subscribeToMore.bind(observable),\n  };\n  // TODO: Need to cast this because we improved the type of `updateQuery` to be parametric\n  // on variables, while the type in Apollo client just has object.\n  // Consider removing this when that is properly typed\n  return fields as ObservableQueryFields<TData, TVariables>;\n}\n\nexport interface QueryResult<TData = any, TVariables = OperationVariables>\n  extends ObservableQueryFields<TData, TVariables> {\n  client: ApolloClient<any>;\n  // we create an empty object to make checking for data\n  // easier for consumers (i.e. instead of data && data.user\n  // you can just check data.user) this also makes destructring\n  // easier (i.e. { data: { user } })\n  // however, this isn't realy possible with TypeScript that\n  // I'm aware of. So intead we enforce checking for data\n  // like so result.data!.user. This tells TS to use TData\n  // XXX is there a better way to do this?\n  data: TData | undefined;\n  error?: ApolloError;\n  loading: boolean;\n  networkStatus: NetworkStatus;\n}\n\nexport interface QueryProps<TData = any, TVariables = OperationVariables> extends QueryOpts<TVariables> {\n  children: (result: QueryResult<TData, TVariables>) => React.ReactNode;\n  query: DocumentNode;\n  displayName?: string;\n  skip?: boolean;\n  onCompleted?: (data: TData) => void;\n  onError?: (error: ApolloError) => void;\n}\n\nexport interface QueryContext {\n  client?: ApolloClient<Object>;\n  operations?: Map<string, { query: DocumentNode; variables: any }>;\n  renderPromises?: RenderPromises;\n}\n\nexport default class Query<TData = any, TVariables = OperationVariables> extends React.Component<\n  QueryProps<TData, TVariables>\n> {\n  static contextTypes = {\n    client: PropTypes.object,\n    operations: PropTypes.object,\n    renderPromises: PropTypes.object,\n  };\n\n  static propTypes = {\n    client: PropTypes.object,\n    children: PropTypes.func.isRequired,\n    fetchPolicy: PropTypes.string,\n    notifyOnNetworkStatusChange: PropTypes.bool,\n    onCompleted: PropTypes.func,\n    onError: PropTypes.func,\n    pollInterval: PropTypes.number,\n    query: PropTypes.object.isRequired,\n    variables: PropTypes.object,\n    ssr: PropTypes.bool,\n    partialRefetch: PropTypes.bool,\n    returnPartialData: PropTypes.bool,\n  };\n\n  context: QueryContext | undefined;\n\n  private client: ApolloClient<Object>;\n\n  // request / action storage. Note that we delete querySubscription if we\n  // unsubscribe but never delete queryObservable once it is created. We\n  // only delete queryObservable when we unmount the component.\n  private queryObservable?: ObservableQuery<TData, TVariables> | null;\n  private querySubscription?: ZenObservable.Subscription;\n  private refetcherQueue?: {\n    args: any;\n    resolve: (value?: any | PromiseLike<any>) => void;\n    reject: (reason?: any) => void;\n  };\n\n  private hasMounted: boolean = false;\n  private operation?: IDocumentDefinition;\n  private lastRenderedResult: ApolloQueryResult<TData> | null = null;\n\n  constructor(props: QueryProps<TData, TVariables>, context: QueryContext) {\n    super(props, context);\n\n    this.client = getClient(props, context);\n    this.initializeQueryObservable(props);\n  }\n\n  // For server-side rendering (see getDataFromTree.ts)\n  fetchData(): Promise<ApolloQueryResult<any>> | boolean {\n    if (this.props.skip) return false;\n\n    // pull off react options\n    const {\n      children,\n      ssr,\n      displayName,\n      skip,\n      client,\n      onCompleted,\n      onError,\n      partialRefetch,\n      ...opts\n    } = this.props;\n\n    let { fetchPolicy } = opts;\n    if (ssr === false) return false;\n    if (fetchPolicy === 'network-only' || fetchPolicy === 'cache-and-network') {\n      fetchPolicy = 'cache-first'; // ignore force fetch in SSR;\n    }\n\n    const observable = this.client.watchQuery({\n      ...opts,\n      fetchPolicy,\n    });\n\n    // Register the SSR observable, so it can be re-used once the value comes back.\n    if (this.context && this.context.renderPromises) {\n      this.context.renderPromises.registerSSRObservable(this, observable);\n    }\n\n    const result = this.queryObservable!.currentResult();\n\n    return result.loading ? observable.result() : false;\n  }\n\n  componentDidMount() {\n    this.hasMounted = true;\n    if (this.props.skip) return;\n\n    this.startQuerySubscription();\n    if (this.refetcherQueue) {\n      const { args, resolve, reject } = this.refetcherQueue;\n      this.queryObservable!.refetch(args)\n        .then(resolve)\n        .catch(reject);\n    }\n  }\n\n  componentWillReceiveProps(nextProps: QueryProps<TData, TVariables>, nextContext: QueryContext) {\n    // the next render wants to skip\n    if (nextProps.skip && !this.props.skip) {\n      this.queryObservable!.resetLastResults();\n      this.removeQuerySubscription();\n      return;\n    }\n\n    const nextClient = getClient(nextProps, nextContext);\n\n    if (shallowEqual(this.props, nextProps) && this.client === nextClient) {\n      return;\n    }\n\n    if (this.client !== nextClient) {\n      this.client = nextClient;\n      this.removeQuerySubscription();\n      this.queryObservable = null;\n    }\n\n    if (this.props.query !== nextProps.query) {\n      this.queryObservable!.resetLastResults();\n      this.removeQuerySubscription();\n    }\n\n    this.updateQuery(nextProps);\n    if (nextProps.skip) return;\n    this.startQuerySubscription();\n  }\n\n  componentWillUnmount() {\n    this.removeQuerySubscription();\n    this.hasMounted = false;\n  }\n\n  componentDidUpdate(prevProps: QueryProps<TData, TVariables>) {\n    const isDiffRequest =\n      !isEqual(prevProps.query, this.props.query) ||\n      !isEqual(prevProps.variables, this.props.variables);\n    if (isDiffRequest) {\n      // If specified, `onError` / `onCompleted` callbacks are called here\n      // after local cache results are loaded.\n      this.handleErrorOrCompleted();\n    }\n  }\n\n  render(): React.ReactNode {\n    const { context } = this;\n    const finish = () => this.props.children(this.getQueryResult());\n    if (context && context.renderPromises) {\n      return context.renderPromises.addQueryPromise(this, finish);\n    }\n    return finish();\n  }\n\n  private extractOptsFromProps(props: QueryProps<TData, TVariables>) {\n    this.operation = parser(props.query);\n\n    invariant(\n      this.operation.type === DocumentType.Query,\n      `The <Query /> component requires a graphql query, but got a ${\n        this.operation.type === DocumentType.Mutation ? 'mutation' : 'subscription'\n      }.`,\n    );\n\n    const displayName = props.displayName || 'Query';\n\n    return {\n      ...props,\n      displayName,\n      context: props.context || {},\n      metadata: { reactComponent: { displayName }},\n    };\n  }\n\n  private initializeQueryObservable(props: QueryProps<TData, TVariables>) {\n    const opts = this.extractOptsFromProps(props);\n    // save for backwards compat of refetcherQueries without a recycler\n    this.setOperations(opts);\n\n    // See if there is an existing observable that was used to fetch the same data and\n    // if so, use it instead since it will contain the proper queryId to fetch\n    // the result set. This is used during SSR.\n    if (this.context && this.context.renderPromises) {\n      this.queryObservable = this.context.renderPromises.getSSRObservable(this);\n    }\n    if (!this.queryObservable) {\n      this.queryObservable = this.client.watchQuery(opts);\n    }\n  }\n\n  private setOperations(props: QueryProps<TData, TVariables>) {\n    if (this.context!.operations) {\n      this.context!.operations!.set(this.operation!.name, {\n        query: props.query,\n        variables: props.variables,\n      });\n    }\n  }\n\n  private updateQuery(props: QueryProps<TData, TVariables>) {\n    // if we skipped initially, we may not have yet created the observable\n    if (!this.queryObservable) {\n      this.initializeQueryObservable(props);\n    } else {\n      this.setOperations(props);\n    }\n\n    this.queryObservable!.setOptions(this.extractOptsFromProps(props))\n      // The error will be passed to the child container, so we don't\n      // need to log it here. We could conceivably log something if\n      // an option was set. OTOH we don't log errors w/ the original\n      // query. See https://github.com/apollostack/react-apollo/issues/404\n      .catch(() => null);\n  }\n\n  private startQuerySubscription = () => {\n    // When the `Query` component receives new props, or when we explicitly\n    // re-subscribe to a query using `resubscribeToQuery`, we start a new\n    // subscription in this method. To avoid un-necessary re-renders when\n    // receiving new props or re-subscribing, we track the full last\n    // observable result so it can be compared against incoming new data.\n    // We only trigger a re-render if the incoming result is different than\n    // the stored `lastRenderedResult`.\n\n    if (this.querySubscription) return;\n\n    this.querySubscription = this.queryObservable!.subscribe({\n      next: (result) => {\n        if (\n          this.lastRenderedResult &&\n          this.lastRenderedResult.loading === result.loading &&\n          this.lastRenderedResult.networkStatus === result.networkStatus &&\n          shallowEqual(this.lastRenderedResult.data, result.data)\n        ) {\n          return;\n        }\n\n        this.updateCurrentData();\n      },\n      error: error => {\n        this.resubscribeToQuery();\n\n        if (!error.hasOwnProperty('graphQLErrors')) throw error;\n        this.updateCurrentData();\n      },\n    });\n  };\n\n  private removeQuerySubscription = () => {\n    if (this.querySubscription) {\n      this.querySubscription.unsubscribe();\n      delete this.lastRenderedResult;\n      delete this.querySubscription;\n    }\n  };\n\n  private resubscribeToQuery() {\n    this.removeQuerySubscription();\n\n    // Unfortunately, if `lastError` is set in the current\n    // `queryObservable` when the subscription is re-created,\n    // the subscription will immediately receive the error, which will\n    // cause it to terminate again. To avoid this, we first clear\n    // the last error/result from the `queryObservable` before re-starting\n    // the subscription, and restore it afterwards (so the subscription\n    // has a chance to stay open).\n    const lastError = this.queryObservable!.getLastError();\n    const lastResult = this.queryObservable!.getLastResult();\n    this.queryObservable!.resetLastResults();\n    this.startQuerySubscription();\n    Object.assign(this.queryObservable!, { lastError, lastResult });\n  }\n\n  private updateCurrentData = () => {\n    // If specified, `onError` / `onCompleted` callbacks are called here\n    // after a network based Query result has been received.\n    this.handleErrorOrCompleted();\n\n    // Force a rerender that goes through shouldComponentUpdate.\n    if (this.hasMounted) this.forceUpdate();\n  };\n\n  private handleErrorOrCompleted = () => {\n    const result = this.queryObservable!.currentResult();\n    const { data, loading, error } = result;\n    const { onCompleted, onError } = this.props;\n    if (onCompleted && !loading && !error) {\n      onCompleted(data as TData);\n    } else if (onError && !loading && error) {\n      onError(error);\n    }\n  }\n\n  private getQueryResult = (): QueryResult<TData, TVariables> => {\n    let result = { data: Object.create(null) as TData } as any;\n    // Attach bound methods\n    Object.assign(result, observableQueryFields(this.queryObservable!));\n\n    // When skipping a query (ie. we're not querying for data but still want\n    // to render children), make sure the `data` is cleared out and\n    // `loading` is set to `false` (since we aren't loading anything).\n    if (this.props.skip) {\n      result = {\n        ...result,\n        data: undefined,\n        error: undefined,\n        loading: false,\n      };\n    } else {\n      const currentResult = this.queryObservable!.currentResult();\n      const { loading, partial, networkStatus, errors } = currentResult;\n      let { error } = currentResult;\n\n      // Until a set naming convention for networkError and graphQLErrors is\n      // decided upon, we map errors (graphQLErrors) to the error props.\n      if (errors && errors.length > 0) {\n        error = new ApolloError({ graphQLErrors: errors });\n      }\n\n      const { fetchPolicy } = this.queryObservable!.options;\n      Object.assign(result, { loading, networkStatus, error });\n\n      const previousData =\n        this.lastRenderedResult ? this.lastRenderedResult.data : {};\n\n      if (loading) {\n        Object.assign(result.data, previousData, currentResult.data);\n      } else if (error) {\n        Object.assign(result, {\n          data: (this.queryObservable!.getLastResult() || {}).data,\n        });\n      } else if (\n        fetchPolicy === 'no-cache' &&\n        Object.keys(currentResult.data).length === 0\n      ) {\n        // Make sure data pulled in by a `no-cache` query is preserved\n        // when the components parent tree is re-rendered.\n        result.data = previousData;\n      } else {\n        const { partialRefetch } = this.props;\n        if (\n          partialRefetch &&\n          currentResult.data !== null &&\n          typeof currentResult.data === 'object' &&\n          Object.keys(currentResult.data).length === 0 &&\n          partial &&\n          fetchPolicy !== 'cache-only'\n        ) {\n          // When a `Query` component is mounted, and a mutation is executed\n          // that returns the same ID as the mounted `Query`, but has less\n          // fields in its result, Apollo Client's `QueryManager` returns the\n          // data as an empty Object since a hit can't be found in the cache.\n          // This can lead to application errors when the UI elements rendered by\n          // the original `Query` component are expecting certain data values to\n          // exist, and they're all of a sudden stripped away. To help avoid\n          // this we'll attempt to refetch the `Query` data.\n          Object.assign(result, { loading: true, networkStatus: NetworkStatus.loading });\n          result.refetch();\n          this.lastRenderedResult = result;\n          return result;\n        }\n\n        Object.assign(result.data, currentResult.data);\n      }\n    }\n\n    // Handle race condition where refetch is called on child mount or later\n    // Normal execution model:\n    // render(loading) -> mount -> start subscription -> get data -> render(with data)\n    //\n    // SSR with synchronous refetch:\n    // render(with data) -> refetch -> mount -> start subscription\n    //\n    // SSR with asynchronous refetch:\n    // render(with data) -> mount -> start subscription -> refetch\n    //\n    // If a subscription has not started, then the synchronous call to refetch\n    // must be made at a time when an active network request is being made, so\n    // we ensure that the network requests are deduped, to avoid an\n    // inconsistent UI state that displays different data for the current query\n    // alongside a refetched query.\n    //\n    // Once the Query component is mounted and the subscription is made, we\n    // always hit the network with refetch, since the components data will be\n    // updated and a network request is not currently active.\n    if (!this.querySubscription) {\n      const oldRefetch = (result as QueryControls<TData, TVariables>).refetch;\n\n      (result as QueryControls<TData, TVariables>).refetch = args => {\n        if (this.querySubscription) {\n          return oldRefetch(args);\n        } else {\n          return new Promise((r, f) => {\n            this.refetcherQueue = { resolve: r, reject: f, args };\n          });\n        }\n      };\n    }\n\n    // When the component is done rendering stored query errors, we'll\n    // remove those errors from the `ObservableQuery` query store, so they\n    // aren't re-displayed on subsequent (potentially error free)\n    // requests/responses.\n    //\n    // NOTE: Resetting query store errors is handled in 2 different ways here,\n    // since the `resetQueryStoreErrors` wasn't available until\n    // `apollo-client` 2.6.3. If a previous version of `apollo-client` is\n    // being used, errors are reset by reaching into `ObservableQuery`'s\n    // internals. This hack is temporary, as React Apollo 3 will be\n    // released shortly, and will enforce `apollo-client` 2.6.3 as the\n    // minimum.\n    setTimeout(() => {\n      if ((this.queryObservable! as any).resetQueryStoreErrors) {\n        // Apollo Client >= 2.6.3\n        (this.queryObservable! as any).resetQueryStoreErrors();\n      } else {\n        // Apollo Client < 2.6.3\n        const { queryManager, queryId } = (this.queryObservable! as any);\n        const queryStore = queryManager.queryStore.get(queryId);\n        if (queryStore) {\n          queryStore.networkError = null;\n          queryStore.graphQLErrors = [];\n        }\n      }\n    });\n\n    result.client = this.client;\n    this.lastRenderedResult = result;\n    return result;\n  };\n}\n","import * as React from 'react';\nimport * as PropTypes from 'prop-types';\nimport ApolloClient, { PureQueryOptions, ApolloError, FetchPolicy } from 'apollo-client';\nimport { DataProxy } from 'apollo-cache';\nimport { invariant } from 'ts-invariant';\nimport { DocumentNode, GraphQLError } from 'graphql';\nimport shallowEqual from './utils/shallowEqual';\n\nimport { OperationVariables, RefetchQueriesProviderFn } from './types';\nimport { parser, DocumentType } from './parser';\nimport { getClient } from './component-utils';\n\nexport interface MutationResult<TData = Record<string, any>> {\n  data?: TData;\n  error?: ApolloError;\n  loading: boolean;\n  called: boolean;\n  client: ApolloClient<Object>;\n}\nexport interface MutationContext {\n  client?: ApolloClient<Object>;\n  operations: Map<string, { query: DocumentNode; variables: any }>;\n}\n\nexport interface ExecutionResult<T = Record<string, any>> {\n  data?: T;\n  extensions?: Record<string, any>;\n  errors?: GraphQLError[];\n}\n\n// Improved MutationUpdaterFn type, need to port them back to Apollo Client\nexport declare type MutationUpdaterFn<\n  T = {\n    [key: string]: any;\n  }\n> = (proxy: DataProxy, mutationResult: FetchResult<T>) => void;\n\nexport declare type FetchResult<\n  TData = Record<string, any>,\n  C = Record<string, any>,\n  E = Record<string, any>\n> = ExecutionResult<TData> & {\n  extensions?: E;\n  context?: C;\n};\n\nexport declare type MutationOptions<\n  TData = Record<string, any>,\n  TVariables = OperationVariables\n> = {\n  variables?: TVariables;\n  optimisticResponse?: TData;\n  refetchQueries?: Array<string | PureQueryOptions> | RefetchQueriesProviderFn;\n  awaitRefetchQueries?: boolean;\n  update?: MutationUpdaterFn<TData>;\n  context?: Record<string, any>;\n  fetchPolicy?: FetchPolicy;\n};\n\nexport declare type MutationFn<TData = any, TVariables = OperationVariables> = (\n  options?: MutationOptions<TData, TVariables>,\n) => Promise<void | FetchResult<TData>>;\n\nexport interface MutationProps<TData = any, TVariables = OperationVariables> {\n  client?: ApolloClient<Object>;\n  mutation: DocumentNode;\n  ignoreResults?: boolean;\n  optimisticResponse?: TData;\n  variables?: TVariables;\n  refetchQueries?: Array<string | PureQueryOptions> | RefetchQueriesProviderFn;\n  awaitRefetchQueries?: boolean;\n  update?: MutationUpdaterFn<TData>;\n  children: (\n    mutateFn: MutationFn<TData, TVariables>,\n    result: MutationResult<TData>,\n  ) => React.ReactNode;\n  onCompleted?: (data: TData) => void;\n  onError?: (error: ApolloError) => void;\n  context?: Record<string, any>;\n  fetchPolicy?: FetchPolicy;\n}\n\nexport interface MutationState<TData = any> {\n  called: boolean;\n  error?: ApolloError;\n  data?: TData;\n  loading: boolean;\n}\n\nconst initialState = {\n  loading: false,\n  called: false,\n  error: undefined,\n  data: undefined,\n};\n\nclass Mutation<TData = any, TVariables = OperationVariables> extends React.Component<\n  MutationProps<TData, TVariables>,\n  MutationState<TData>\n> {\n  static contextTypes = {\n    client: PropTypes.object,\n    operations: PropTypes.object,\n  };\n\n  static propTypes = {\n    mutation: PropTypes.object.isRequired,\n    variables: PropTypes.object,\n    optimisticResponse: PropTypes.object,\n    refetchQueries: PropTypes.oneOfType([\n      PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string, PropTypes.object])),\n      PropTypes.func,\n    ]),\n    awaitRefetchQueries: PropTypes.bool,\n    update: PropTypes.func,\n    children: PropTypes.func.isRequired,\n    onCompleted: PropTypes.func,\n    onError: PropTypes.func,\n    fetchPolicy: PropTypes.string,\n  };\n\n  private client: ApolloClient<any>;\n  private mostRecentMutationId: number;\n\n  private hasMounted: boolean = false;\n\n  constructor(props: MutationProps<TData, TVariables>, context: any) {\n    super(props, context);\n    this.client = getClient(props, context);\n    this.verifyDocumentIsMutation(props.mutation);\n    this.mostRecentMutationId = 0;\n    this.state = initialState;\n  }\n\n  componentDidMount() {\n    this.hasMounted = true;\n  }\n\n  componentWillUnmount() {\n    this.hasMounted = false;\n  }\n\n  componentWillReceiveProps(\n    nextProps: MutationProps<TData, TVariables>,\n    nextContext: MutationContext,\n  ) {\n    const nextClient = getClient(nextProps, nextContext);\n    if (shallowEqual(this.props, nextProps) && this.client === nextClient) {\n      return;\n    }\n\n    if (this.props.mutation !== nextProps.mutation) {\n      this.verifyDocumentIsMutation(nextProps.mutation);\n    }\n\n    if (this.client !== nextClient) {\n      this.client = nextClient;\n      this.setState(initialState);\n    }\n  }\n\n  render() {\n    const { children } = this.props;\n    const { loading, data, error, called } = this.state;\n\n    const result = {\n      called,\n      loading,\n      data,\n      error,\n      client: this.client,\n    };\n\n    return children(this.runMutation, result);\n  }\n\n  private runMutation = (options: MutationOptions<TData, TVariables> = {}) => {\n    this.onMutationStart();\n    const mutationId = this.generateNewMutationId();\n\n    return this.mutate(options)\n      .then((response: ExecutionResult<TData>) => {\n        this.onMutationCompleted(response, mutationId);\n        return response;\n      })\n      .catch((e: ApolloError) => {\n        this.onMutationError(e, mutationId);\n        if (!this.props.onError) throw e;\n      });\n  };\n\n  private mutate = (options: MutationOptions<TData, TVariables>) => {\n    const {\n      mutation,\n      variables,\n      optimisticResponse,\n      update,\n      context = {},\n      awaitRefetchQueries = false,\n      fetchPolicy,\n    } = this.props;\n    const mutateOptions = { ...options };\n\n    let refetchQueries = mutateOptions.refetchQueries || this.props.refetchQueries;\n    // XXX this will be removed in the 3.0 of Apollo Client. Currently, we\n    // support refectching of named queries which just pulls the latest\n    // variables to match. This forces us to either a) keep all queries around\n    // to be able to iterate over and refetch, or b) [new in 2.1] keep a map of\n    // operations on the client where operation name => { query, variables }\n    //\n    // Going forward, we should only allow using the full operation + variables to\n    // refetch.\n    if (refetchQueries && refetchQueries.length && Array.isArray(refetchQueries)) {\n      refetchQueries = (refetchQueries as any).map((x: string | PureQueryOptions) => {\n        if (typeof x === 'string' && this.context.operations)\n          return this.context.operations.get(x) || x;\n        return x;\n      });\n      delete mutateOptions.refetchQueries;\n    }\n\n    const mutateVariables = Object.assign({}, variables, mutateOptions.variables);\n    delete mutateOptions.variables;\n\n    return this.client.mutate({\n      mutation,\n      optimisticResponse,\n      refetchQueries,\n      awaitRefetchQueries,\n      update,\n      context,\n      fetchPolicy,\n      variables: mutateVariables,\n      ...mutateOptions,\n    });\n  };\n\n  private onMutationStart = () => {\n    if (!this.state.loading && !this.props.ignoreResults) {\n      this.setState({\n        loading: true,\n        error: undefined,\n        data: undefined,\n        called: true,\n      });\n    }\n  };\n\n  private onMutationCompleted = (response: ExecutionResult<TData>, mutationId: number) => {\n    const { onCompleted, ignoreResults } = this.props;\n\n    const { data, errors } = response;\n    const error =\n      errors && errors.length > 0 ? new ApolloError({ graphQLErrors: errors }) : undefined;\n\n    const callOncomplete = () => (onCompleted ? onCompleted(data as TData) : null);\n\n    if (this.hasMounted && this.isMostRecentMutation(mutationId) && !ignoreResults) {\n      this.setState({ loading: false, data, error }, callOncomplete);\n    } else {\n      callOncomplete();\n    }\n  };\n\n  private onMutationError = (error: ApolloError, mutationId: number) => {\n    const { onError } = this.props;\n    const callOnError = () => (onError ? onError(error) : null);\n\n    if (this.hasMounted && this.isMostRecentMutation(mutationId)) {\n      this.setState({ loading: false, error }, callOnError);\n    } else {\n      callOnError();\n    }\n  };\n\n  private generateNewMutationId = (): number => {\n    this.mostRecentMutationId = this.mostRecentMutationId + 1;\n    return this.mostRecentMutationId;\n  };\n\n  private isMostRecentMutation = (mutationId: number) => {\n    return this.mostRecentMutationId === mutationId;\n  };\n\n  private verifyDocumentIsMutation = (mutation: DocumentNode) => {\n    const operation = parser(mutation);\n    invariant(\n      operation.type === DocumentType.Mutation,\n      `The <Mutation /> component requires a graphql mutation, but got a ${\n        operation.type === DocumentType.Query ? 'query' : 'subscription'\n      }.`,\n    );\n  };\n}\n\nexport default Mutation;\n","import * as React from 'react';\nimport * as PropTypes from 'prop-types';\nimport ApolloClient, { ApolloError, FetchPolicy } from 'apollo-client';\nimport { Observable } from 'apollo-link';\nimport { DocumentNode } from 'graphql';\nimport { ZenObservable } from 'zen-observable-ts';\n\nimport { OperationVariables } from './types';\nimport { getClient } from './component-utils';\n\nimport shallowEqual from './utils/shallowEqual';\nimport { invariant } from 'ts-invariant';\n\nexport interface SubscriptionResult<TData = any> {\n  loading: boolean;\n  data?: TData;\n  error?: ApolloError;\n}\n\nexport interface OnSubscriptionDataOptions<TData = any> {\n  client: ApolloClient<Object>;\n  subscriptionData: SubscriptionResult<TData>;\n}\n\nexport interface SubscriptionProps<TData = any, TVariables = OperationVariables> {\n  subscription: DocumentNode;\n  variables?: TVariables;\n  fetchPolicy?: FetchPolicy;\n  shouldResubscribe?: any;\n  client?: ApolloClient<Object>;\n  onSubscriptionData?: (options: OnSubscriptionDataOptions<TData>) => any;\n  onSubscriptionComplete?: () => void;\n  children?: (result: SubscriptionResult<TData>) => React.ReactNode;\n}\n\nexport interface SubscriptionState<TData = any> {\n  loading: boolean;\n  data?: TData;\n  error?: ApolloError;\n}\n\nexport interface SubscriptionContext {\n  client?: ApolloClient<Object>;\n}\n\nclass Subscription<TData = any, TVariables = any> extends React.Component<\n  SubscriptionProps<TData, TVariables>,\n  SubscriptionState<TData>\n> {\n  static contextTypes = {\n    client: PropTypes.object,\n  };\n\n  static propTypes = {\n    subscription: PropTypes.object.isRequired,\n    variables: PropTypes.object,\n    children: PropTypes.func,\n    onSubscriptionData: PropTypes.func,\n    onSubscriptionComplete: PropTypes.func,\n    shouldResubscribe: PropTypes.oneOfType([PropTypes.func, PropTypes.bool]),\n  };\n\n  private client: ApolloClient<any>;\n  private queryObservable?: Observable<any>;\n  private querySubscription?: ZenObservable.Subscription;\n\n  constructor(props: SubscriptionProps<TData, TVariables>, context: SubscriptionContext) {\n    super(props, context);\n\n    this.client = getClient(props, context);\n    this.initialize(props);\n    this.state = this.getInitialState();\n  }\n\n  componentDidMount() {\n    this.startSubscription();\n  }\n\n  componentWillReceiveProps(\n    nextProps: SubscriptionProps<TData, TVariables>,\n    nextContext: SubscriptionContext,\n  ) {\n    const nextClient = getClient(nextProps, nextContext);\n\n    if (\n      shallowEqual(this.props.variables, nextProps.variables) &&\n      this.client === nextClient &&\n      this.props.subscription === nextProps.subscription\n    ) {\n      return;\n    }\n\n    let shouldResubscribe = nextProps.shouldResubscribe;\n    if (typeof shouldResubscribe === 'function') {\n      shouldResubscribe = !!shouldResubscribe(this.props, nextProps);\n    }\n    const shouldNotResubscribe = shouldResubscribe === false;\n    if (this.client !== nextClient) {\n      this.client = nextClient;\n    }\n\n    if (!shouldNotResubscribe) {\n      this.endSubscription();\n      delete this.queryObservable;\n      this.initialize(nextProps);\n      this.startSubscription();\n      this.setState(this.getInitialState());\n      return;\n    }\n    this.initialize(nextProps);\n    this.startSubscription();\n  }\n\n  componentWillUnmount() {\n    this.endSubscription();\n  }\n\n  render() {\n    const renderFn: any = this.props.children;\n    if (!renderFn) return null;\n    const result = Object.assign({}, this.state, {\n      variables: this.props.variables,\n    });\n    return renderFn(result);\n  }\n\n  private initialize = (props: SubscriptionProps<TData, TVariables>) => {\n    if (this.queryObservable) return;\n    this.queryObservable = this.client.subscribe({\n      query: props.subscription,\n      variables: props.variables,\n      fetchPolicy: props.fetchPolicy,\n    });\n  };\n\n  private startSubscription = () => {\n    if (this.querySubscription) return;\n    this.querySubscription = this.queryObservable!.subscribe({\n      next: this.updateCurrentData,\n      error: this.updateError,\n      complete: this.completeSubscription\n    });\n  };\n\n  private getInitialState = () => ({\n    loading: true,\n    error: undefined,\n    data: undefined,\n  });\n\n  private updateCurrentData = (result: SubscriptionResult<TData>) => {\n    const {\n      client,\n      props: { onSubscriptionData },\n    } = this;\n    this.setState({\n      data: result.data,\n      loading: false,\n      error: undefined,\n    });\n    if (onSubscriptionData) onSubscriptionData({ client, subscriptionData: result });\n  };\n\n  private updateError = (error: any) => {\n    this.setState({\n      error,\n      loading: false,\n    });\n  };\n\n  private completeSubscription = () => {\n    const { onSubscriptionComplete } = this.props;\n    if (onSubscriptionComplete) onSubscriptionComplete();\n    this.endSubscription();\n  };\n\n  private endSubscription = () => {\n    if (this.querySubscription) {\n      this.querySubscription.unsubscribe();\n      delete this.querySubscription;\n    }\n  };\n}\n\nexport default Subscription;\n","import * as React from 'react';\nimport { invariant } from 'ts-invariant';\n\nimport { OperationVariables } from './types';\nimport { DocumentType, IDocumentDefinition } from './parser';\n\nexport const defaultMapPropsToOptions = () => ({});\nexport const defaultMapResultToProps: <P>(props: P) => P = props => props;\nexport const defaultMapPropsToSkip = () => false;\n\nexport function getDisplayName<P>(WrappedComponent: React.ComponentType<P>) {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n\nexport function calculateVariablesFromProps<TProps>(operation: IDocumentDefinition, props: TProps) {\n  let variables: OperationVariables = {};\n  for (let { variable, type } of operation.variables) {\n    if (!variable.name || !variable.name.value) continue;\n\n    const variableName = variable.name.value;\n    const variableProp = (props as any)[variableName];\n\n    if (typeof variableProp !== 'undefined') {\n      variables[variableName] = variableProp;\n      continue;\n    }\n\n    // Allow optional props\n    if (type.kind !== 'NonNullType') {\n      variables[variableName] = undefined;\n    }\n  }\n  return variables;\n}\n\nexport type RefSetter<TChildProps> = (ref: React.ComponentClass<TChildProps>) => void | void;\n\n// base class for hocs to easily manage refs\nexport class GraphQLBase<TProps, TChildProps, TState = any> extends React.Component<\n  TProps,\n  TState\n> {\n  public withRef: boolean = false;\n  // wrapped instance\n  private wrappedInstance?: React.ComponentClass<TChildProps>;\n\n  constructor(props: TProps) {\n    super(props);\n    this.setWrappedInstance = this.setWrappedInstance.bind(this);\n  }\n\n  getWrappedInstance() {\n    invariant(\n      this.withRef,\n      `To access the wrapped instance, you need to specify ` + `{ withRef: true } in the options`,\n    );\n\n    return this.wrappedInstance;\n  }\n\n  setWrappedInstance(ref: React.ComponentClass<TChildProps>) {\n    this.wrappedInstance = ref;\n  }\n}\n","import * as React from 'react';\nimport { DocumentNode } from 'graphql';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\n\nimport { parser } from './parser';\nimport { OperationOption, QueryOpts, OptionProps, DataProps } from './types';\nimport { default as Query } from './Query';\nimport {\n  getDisplayName,\n  GraphQLBase,\n  calculateVariablesFromProps,\n  defaultMapPropsToOptions,\n  defaultMapPropsToSkip,\n} from './hoc-utils';\n\nexport function withQuery<\n  TProps extends TGraphQLVariables | {} = {},\n  TData = {},\n  TGraphQLVariables = {},\n  TChildProps = DataProps<TData, TGraphQLVariables>\n>(\n  document: DocumentNode,\n  operationOptions: OperationOption<TProps, TData, TGraphQLVariables, TChildProps> = {},\n) {\n  // this is memoized so if coming from `graphql` there is nearly no extra cost\n  const operation = parser(document);\n  // extract options\n  const {\n    options = defaultMapPropsToOptions,\n    skip = defaultMapPropsToSkip,\n    alias = 'Apollo',\n  } = operationOptions;\n\n  let mapPropsToOptions = options as (props: any) => QueryOpts;\n  if (typeof mapPropsToOptions !== 'function') {\n    mapPropsToOptions = () => options as QueryOpts;\n  }\n\n  let mapPropsToSkip = skip as (props: any) => boolean;\n  if (typeof mapPropsToSkip !== 'function') {\n    mapPropsToSkip = () => skip as any;\n  }\n\n  // allow for advanced referential equality checks\n  let lastResultProps: TChildProps | void;\n  return (\n    WrappedComponent: React.ComponentType<TProps & TChildProps>,\n  ): React.ComponentClass<TProps> => {\n    const graphQLDisplayName = `${alias}(${getDisplayName(WrappedComponent)})`;\n    class GraphQL extends GraphQLBase<TProps, TChildProps> {\n      static displayName = graphQLDisplayName;\n      static WrappedComponent = WrappedComponent;\n\n      render() {\n        let props = this.props;\n        const shouldSkip = mapPropsToSkip(props);\n        const opts = shouldSkip ? Object.create(null) : { ...mapPropsToOptions(props) };\n\n        if (!shouldSkip && !opts.variables && operation.variables.length > 0) {\n          opts.variables = calculateVariablesFromProps(\n            operation,\n            props,\n          );\n        }\n        return (\n          <Query\n            {...opts}\n            displayName={graphQLDisplayName}\n            skip={shouldSkip}\n            query={document}\n            warnUnhandledError\n          >\n            {({ client: _, data, ...r }) => {\n              if (operationOptions.withRef) {\n                this.withRef = true;\n                props = Object.assign({}, props, {\n                  ref: this.setWrappedInstance,\n                });\n              }\n              // if we have skipped, no reason to manage any reshaping\n              if (shouldSkip) {\n                return (\n                  <WrappedComponent\n                    {...props as TProps}\n                    {...{} as TChildProps}\n                  />\n                );\n              }\n\n              // the HOC's historically hoisted the data from the execution result\n              // up onto the result since it was passed as a nested prop\n              // we massage the Query components shape here to replicate that\n              const result = Object.assign(r, data || {});\n              const name = operationOptions.name || 'data';\n              let childProps = { [name]: result };\n              if (operationOptions.props) {\n                const newResult: OptionProps<TProps, TData, TGraphQLVariables> = {\n                  [name]: result,\n                  ownProps: props as TProps,\n                };\n                lastResultProps = operationOptions.props(newResult, lastResultProps);\n                childProps = lastResultProps;\n              }\n\n              return (\n                <WrappedComponent\n                  {...props as TProps}\n                  {...childProps as TChildProps}\n                />\n              );\n            }}\n          </Query>\n        );\n      }\n    }\n\n    // Make sure we preserve any custom statics on the original component.\n    return hoistNonReactStatics(GraphQL, WrappedComponent, {});\n  };\n}\n","import * as React from 'react';\nimport { DocumentNode } from 'graphql';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\n\nimport { parser } from './parser';\nimport { MutationOpts, OperationOption, OptionProps, MutateProps } from './types';\nimport { default as Mutation } from './Mutation';\nimport {\n  defaultMapPropsToOptions,\n  getDisplayName,\n  calculateVariablesFromProps,\n  GraphQLBase,\n} from './hoc-utils';\n\nexport function withMutation<\n  TProps extends TGraphQLVariables | {} = {},\n  TData = {},\n  TGraphQLVariables = {},\n  TChildProps = MutateProps<TData, TGraphQLVariables>\n>(\n  document: DocumentNode,\n  operationOptions: OperationOption<TProps, TData, TGraphQLVariables, TChildProps> = {},\n) {\n  // this is memoized so if coming from `graphql` there is nearly no extra cost\n  const operation = parser(document);\n  // extract options\n\n  const { options = defaultMapPropsToOptions, alias = 'Apollo' } = operationOptions;\n\n  let mapPropsToOptions = options as (props: any) => MutationOpts;\n  if (typeof mapPropsToOptions !== 'function') mapPropsToOptions = () => options as MutationOpts;\n\n  return (\n    WrappedComponent: React.ComponentType<TProps & TChildProps>,\n  ): React.ComponentClass<TProps> => {\n    const graphQLDisplayName = `${alias}(${getDisplayName(WrappedComponent)})`;\n    class GraphQL extends GraphQLBase<TProps, TChildProps> {\n      static displayName = graphQLDisplayName;\n      static WrappedComponent = WrappedComponent;\n      render() {\n        let props = this.props;\n        const opts = mapPropsToOptions(props);\n\n        if (operationOptions.withRef) {\n          this.withRef = true;\n          props = Object.assign({}, props, {\n            ref: this.setWrappedInstance,\n          });\n        }\n        if (!opts.variables && operation.variables.length > 0) {\n          opts.variables = calculateVariablesFromProps(\n            operation,\n            props,\n          );\n        }\n\n        return (\n          <Mutation {...opts} mutation={document} ignoreResults>\n            {(mutate, { data, ...r }) => {\n              // the HOC's historically hoisted the data from the execution result\n              // up onto the result since it was passed as a nested prop\n              // we massage the Mutation component's shape here to replicate that\n              // this matches the query HoC\n              const result = Object.assign(r, data || {});\n              const name = operationOptions.name || 'mutate';\n              const resultName = operationOptions.name ? `${name}Result` : 'result';\n              let childProps = { [name]: mutate, [resultName]: result };\n              if (operationOptions.props) {\n                const newResult: OptionProps<TProps, TData, TGraphQLVariables> = {\n                  [name]: mutate,\n                  [resultName]: result,\n                  ownProps: props,\n                };\n                childProps = operationOptions.props(newResult) as any;\n              }\n\n              return (\n                <WrappedComponent\n                  {...props as TProps}\n                  {...childProps as TChildProps}\n                />\n              );\n            }}\n          </Mutation>\n        );\n      }\n    }\n\n    // Make sure we preserve any custom statics on the original component.\n    return hoistNonReactStatics(GraphQL, WrappedComponent, {});\n  };\n}\n","import * as React from 'react';\nimport { DocumentNode } from 'graphql';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\n\nimport { parser } from './parser';\nimport { OperationOption, QueryOpts, OptionProps, DataProps } from './types';\nimport { default as Subscription } from './Subscriptions';\nimport {\n  getDisplayName,\n  GraphQLBase,\n  calculateVariablesFromProps,\n  defaultMapPropsToOptions,\n  defaultMapPropsToSkip,\n} from './hoc-utils';\n\nexport function withSubscription<\n  TProps extends TGraphQLVariables | {} = {},\n  TData = {},\n  TGraphQLVariables = {},\n  TChildProps = DataProps<TData, TGraphQLVariables>\n>(\n  document: DocumentNode,\n  operationOptions: OperationOption<TProps, TData, TGraphQLVariables, TChildProps> = {},\n) {\n  // this is memoized so if coming from `graphql` there is nearly no extra cost\n  const operation = parser(document);\n  // extract options\n  const {\n    options = defaultMapPropsToOptions,\n    skip = defaultMapPropsToSkip,\n    alias = 'Apollo',\n    shouldResubscribe,\n  } = operationOptions;\n\n  let mapPropsToOptions = options as (props: any) => QueryOpts;\n  if (typeof mapPropsToOptions !== 'function') mapPropsToOptions = () => options as QueryOpts;\n\n  let mapPropsToSkip = skip as (props: any) => boolean;\n  if (typeof mapPropsToSkip !== 'function') mapPropsToSkip = () => skip as any;\n\n  // allow for advanced referential equality checks\n  let lastResultProps: TChildProps | void;\n  return (\n    WrappedComponent: React.ComponentType<TProps & TChildProps>,\n  ): React.ComponentClass<TProps> => {\n    const graphQLDisplayName = `${alias}(${getDisplayName(WrappedComponent)})`;\n    class GraphQL extends GraphQLBase<TProps, TChildProps, { resubscribe: boolean }> {\n      static displayName = graphQLDisplayName;\n      static WrappedComponent = WrappedComponent;\n      constructor(props: TProps) {\n        super(props);\n        this.state = { resubscribe: false };\n      }\n      componentWillReceiveProps(nextProps: TProps) {\n        if (!shouldResubscribe) return;\n        this.setState({\n          resubscribe: shouldResubscribe(this.props, nextProps),\n        });\n      }\n\n      render() {\n        let props = this.props;\n        const shouldSkip = mapPropsToSkip(props);\n        const opts = shouldSkip ? Object.create(null) : mapPropsToOptions(props);\n\n        if (!shouldSkip && !opts.variables && operation.variables.length > 0) {\n          opts.variables = calculateVariablesFromProps(\n            operation,\n            props,\n          );\n        }\n        return (\n          <Subscription\n            {...opts}\n            displayName={graphQLDisplayName}\n            skip={shouldSkip}\n            subscription={document}\n            shouldResubscribe={this.state.resubscribe}\n          >\n            {({ data, ...r }) => {\n              if (operationOptions.withRef) {\n                this.withRef = true;\n                props = Object.assign({}, props, {\n                  ref: this.setWrappedInstance,\n                });\n              }\n              // if we have skipped, no reason to manage any reshaping\n              if (shouldSkip) {\n                return (\n                  <WrappedComponent\n                    {...props as TProps}\n                    {...{} as TChildProps}\n                  />\n                );\n              }\n\n              // the HOC's historically hoisted the data from the execution result\n              // up onto the result since it was passed as a nested prop\n              // we massage the Query components shape here to replicate that\n              const result = Object.assign(r, data || {});\n              const name = operationOptions.name || 'data';\n              let childProps = { [name]: result };\n              if (operationOptions.props) {\n                const newResult: OptionProps<TProps, TData, TGraphQLVariables> = {\n                  [name]: result,\n                  ownProps: props as TProps,\n                };\n                lastResultProps = operationOptions.props(newResult, lastResultProps);\n                childProps = lastResultProps;\n              }\n\n              return (\n                <WrappedComponent\n                  {...props as TProps}\n                  {...childProps as TChildProps}\n                />\n              );\n            }}\n          </Subscription>\n        );\n      }\n    }\n\n    // Make sure we preserve any custom statics on the original component.\n    return hoistNonReactStatics(GraphQL, WrappedComponent, {});\n  };\n}\n","import * as React from 'react';\nimport { DocumentNode } from 'graphql';\nimport { parser, DocumentType } from './parser';\nimport { OperationOption, DataProps, MutateProps } from './types';\n\nimport { withQuery } from './query-hoc';\nimport { withMutation } from './mutation-hoc';\nimport { withSubscription } from './subscription-hoc';\n\nexport function graphql<\n  TProps extends TGraphQLVariables | {} = {},\n  TData = {},\n  TGraphQLVariables = {},\n  TChildProps = Partial<DataProps<TData, TGraphQLVariables>> &\n    Partial<MutateProps<TData, TGraphQLVariables>>\n>(\n  document: DocumentNode,\n  operationOptions: OperationOption<TProps, TData, TGraphQLVariables, TChildProps> = {},\n) {\n  switch (parser(document).type) {\n    case DocumentType.Mutation:\n      return withMutation(document, operationOptions);\n    case DocumentType.Subscription:\n      return withSubscription(document, operationOptions);\n    // case DocumentType.Fragment:\n    //   throw new Error('fragments cannont currently be used on their own');\n    case DocumentType.Query:\n    default:\n      return withQuery(document, operationOptions);\n  }\n}\n","import * as React from 'react';\nimport { OperationOption } from './types';\nimport ApolloConsumer from './ApolloConsumer';\nimport { ApolloClient } from 'apollo-client';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\n\nimport { invariant } from 'ts-invariant';\n\nfunction getDisplayName<P>(WrappedComponent: React.ComponentType<P>) {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n\nexport type WithApolloClient<P> = P & { client: ApolloClient<any> };\n\nexport default function withApollo<TProps, TResult = any>(\n  WrappedComponent: React.ComponentType<WithApolloClient<TProps>>,\n  operationOptions: OperationOption<TProps, TResult> = {},\n): React.ComponentClass<TProps> {\n  const withDisplayName = `withApollo(${getDisplayName(WrappedComponent)})`;\n\n  class WithApollo extends React.Component<TProps> {\n    static displayName = withDisplayName;\n    static WrappedComponent = WrappedComponent;\n\n    // wrapped instance\n    private wrappedInstance: any;\n\n    constructor(props: TProps) {\n      super(props);\n      this.setWrappedInstance = this.setWrappedInstance.bind(this);\n    }\n\n    getWrappedInstance() {\n      invariant(\n        operationOptions.withRef,\n        `To access the wrapped instance, you need to specify ` + `{ withRef: true } in the options`,\n      );\n\n      return this.wrappedInstance;\n    }\n\n    setWrappedInstance(ref: React.ComponentType<WithApolloClient<TProps>>) {\n      this.wrappedInstance = ref;\n    }\n\n    render() {\n      return (\n        <ApolloConsumer>\n          {client => {\n            const props = Object.assign({}, this.props, {\n              client,\n              ref: operationOptions.withRef ? this.setWrappedInstance : undefined,\n            });\n            return <WrappedComponent {...props} />;\n          }}\n        </ApolloConsumer>\n      );\n    }\n  }\n\n  // Make sure we preserve any custom statics on the original component.\n  return hoistNonReactStatics(WithApollo, WrappedComponent, {});\n}\n","import * as React from 'react';\nimport * as PropTypes from 'prop-types';\nimport Query from './Query';\nimport { ObservableQuery } from 'apollo-client';\nimport { DocumentNode } from 'graphql';\n\ntype QueryInfo = {\n  seen: boolean;\n  observable: ObservableQuery<any, any> | null;\n}\n\nfunction makeDefaultQueryInfo(): QueryInfo {\n  return {\n    seen: false,\n    observable: null,\n  };\n}\n\nexport class RenderPromises {\n  // Map from Query component instances to pending fetchData promises.\n  private queryPromises = new Map<Query<any, any>, Promise<any>>();\n\n  // Two-layered map from (query document, stringified variables) to QueryInfo\n  // objects. These QueryInfo objects are intended to survive through the whole\n  // getMarkupFromTree process, whereas specific Query instances do not survive\n  // beyond a single call to renderToStaticMarkup.\n  private queryInfoTrie = new Map<DocumentNode, Map<string, QueryInfo>>();\n\n  // Registers the server side rendered observable.\n  public registerSSRObservable<TData, TVariables>(\n    queryInstance: Query<TData, TVariables>,\n    observable: ObservableQuery<any, TVariables>,\n  ) {\n    this.lookupQueryInfo(queryInstance).observable = observable;\n  }\n\n  // Get's the cached observable that matches the SSR Query instances query and variables.\n  public getSSRObservable<TData, TVariables>(queryInstance: Query<TData, TVariables>) {\n    return this.lookupQueryInfo(queryInstance).observable;\n  }\n\n  public addQueryPromise<TData, TVariables>(\n    queryInstance: Query<TData, TVariables>,\n    finish: () => React.ReactNode,\n  ): React.ReactNode {\n    const info = this.lookupQueryInfo(queryInstance);\n    if (!info.seen) {\n      this.queryPromises.set(\n        queryInstance,\n        new Promise(resolve => {\n          resolve(queryInstance.fetchData());\n        }),\n      );\n      // Render null to abandon this subtree for this rendering, so that we\n      // can wait for the data to arrive.\n      return null;\n    }\n    return finish();\n  }\n\n  public hasPromises() {\n    return this.queryPromises.size > 0;\n  }\n\n  public consumeAndAwaitPromises() {\n    const promises: Promise<any>[] = [];\n    this.queryPromises.forEach((promise, queryInstance) => {\n      // Make sure we never try to call fetchData for this query document and\n      // these variables again. Since the queryInstance objects change with\n      // every rendering, deduplicating them by query and variables is the\n      // best we can do. If a different Query component happens to have the\n      // same query document and variables, it will be immediately rendered\n      // by calling finish() in addQueryPromise, which could result in the\n      // rendering of an unwanted loading state, but that's not nearly as bad\n      // as getting stuck in an infinite rendering loop because we kept calling\n      // queryInstance.fetchData for the same Query component indefinitely.\n      this.lookupQueryInfo(queryInstance).seen = true;\n      promises.push(promise);\n    });\n    this.queryPromises.clear();\n    return Promise.all(promises);\n  }\n\n  private lookupQueryInfo<TData, TVariables>(\n    queryInstance: Query<TData, TVariables>,\n  ): QueryInfo {\n    const { queryInfoTrie } = this;\n    const { query, variables } = queryInstance.props;\n    const varMap = queryInfoTrie.get(query) || new Map<string, QueryInfo>();\n    if (!queryInfoTrie.has(query)) queryInfoTrie.set(query, varMap);\n    const variablesString = JSON.stringify(variables);\n    const info = varMap.get(variablesString) || makeDefaultQueryInfo();\n    if (!varMap.has(variablesString)) varMap.set(variablesString, info);\n    return info;\n  }\n}\n\nexport default function getDataFromTree(\n  tree: React.ReactNode,\n  context: { [key: string]: any } = {},\n) {\n  return getMarkupFromTree({\n    tree,\n    context,\n    // If you need to configure this renderFunction, call getMarkupFromTree\n    // directly instead of getDataFromTree.\n    renderFunction: require(\"react-dom/server\").renderToStaticMarkup,\n  });\n}\n\nexport type GetMarkupFromTreeOptions = {\n  tree: React.ReactNode;\n  context?: { [key: string]: any };\n  renderFunction?: (tree: React.ReactElement<any>) => string;\n};\n\nexport function getMarkupFromTree({\n  tree,\n  context = {},\n  // The rendering function is configurable! We use renderToStaticMarkup as\n  // the default, because it's a little less expensive than renderToString,\n  // and legacy usage of getDataFromTree ignores the return value anyway.\n  renderFunction = require(\"react-dom/server\").renderToStaticMarkup,\n}: GetMarkupFromTreeOptions): Promise<string> {\n  const renderPromises = new RenderPromises();\n\n  class RenderPromisesProvider extends React.Component {\n    static childContextTypes: { [key: string]: any } = {\n      renderPromises: PropTypes.object,\n    };\n\n    getChildContext() {\n      return { ...context, renderPromises };\n    }\n\n    render() {\n      // Always re-render from the rootElement, even though it might seem\n      // better to render the children of the component responsible for the\n      // promise, because it is not possible to reconstruct the full context\n      // of the original rendering (including all unknown context provider\n      // elements) for a subtree of the orginal component tree.\n      return tree;\n    }\n  }\n\n  Object.keys(context).forEach(key => {\n    RenderPromisesProvider.childContextTypes[key] = PropTypes.any;\n  });\n\n  function process(): Promise<string> | string {\n    const html = renderFunction(React.createElement(RenderPromisesProvider));\n    return renderPromises.hasPromises()\n      ? renderPromises.consumeAndAwaitPromises().then(process)\n      : html;\n  }\n\n  return Promise.resolve().then(process);\n}\n","import { ReactElement } from 'react';\nimport { getMarkupFromTree } from './getDataFromTree';\n\nexport function renderToStringWithData(component: ReactElement<any>): Promise<string> {\n  return getMarkupFromTree({\n    tree: component,\n    renderFunction: require(\"react-dom/server\").renderToString,\n  });\n}\n","export function compose(...funcs: Function[]) {\n  const functions = funcs.reverse();\n  return function (...args: any[]) {\n    const [firstFunction, ...restFunctions] = functions\n    let result = firstFunction.apply(null, args);\n    restFunctions.forEach((fnc) => {\n      result = fnc.call(null, result)\n    });\n    return result;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}