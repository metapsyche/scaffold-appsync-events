{"ast":null,"code":"import { GraphQLError } from '../../error';\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nexport function cycleErrorMessage(fragName, spreadNames) {\n  var via = spreadNames.length ? ' via ' + spreadNames.join(', ') : '';\n  return 'Cannot spread fragment \"' + fragName + '\" within itself' + via + '.';\n}\nexport function NoFragmentCycles(context) {\n  // Tracks already visited fragments to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  var visitedFrags = Object.create(null); // Array of AST nodes used to produce meaningful errors\n\n  var spreadPath = []; // Position in the spread path\n\n  var spreadPathIndexByName = Object.create(null);\n  return {\n    OperationDefinition: function OperationDefinition() {\n      return false;\n    },\n    FragmentDefinition: function FragmentDefinition(node) {\n      if (!visitedFrags[node.name.value]) {\n        detectCycleRecursive(node);\n      }\n\n      return false;\n    }\n  }; // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n\n  function detectCycleRecursive(fragment) {\n    var fragmentName = fragment.name.value;\n    visitedFrags[fragmentName] = true;\n    var spreadNodes = context.getFragmentSpreads(fragment.selectionSet);\n\n    if (spreadNodes.length === 0) {\n      return;\n    }\n\n    spreadPathIndexByName[fragmentName] = spreadPath.length;\n\n    for (var i = 0; i < spreadNodes.length; i++) {\n      var spreadNode = spreadNodes[i];\n      var spreadName = spreadNode.name.value;\n      var cycleIndex = spreadPathIndexByName[spreadName];\n\n      if (cycleIndex === undefined) {\n        spreadPath.push(spreadNode);\n\n        if (!visitedFrags[spreadName]) {\n          var spreadFragment = context.getFragment(spreadName);\n\n          if (spreadFragment) {\n            detectCycleRecursive(spreadFragment);\n          }\n        }\n\n        spreadPath.pop();\n      } else {\n        var cyclePath = spreadPath.slice(cycleIndex);\n        context.reportError(new GraphQLError(cycleErrorMessage(spreadName, cyclePath.map(function (s) {\n          return s.name.value;\n        })), cyclePath.concat(spreadNode)));\n      }\n    }\n\n    spreadPathIndexByName[fragmentName] = undefined;\n  }\n}","map":{"version":3,"names":["GraphQLError","cycleErrorMessage","fragName","spreadNames","via","length","join","NoFragmentCycles","context","visitedFrags","Object","create","spreadPath","spreadPathIndexByName","OperationDefinition","FragmentDefinition","node","name","value","detectCycleRecursive","fragment","fragmentName","spreadNodes","getFragmentSpreads","selectionSet","i","spreadNode","spreadName","cycleIndex","undefined","push","spreadFragment","getFragment","pop","cyclePath","slice","reportError","map","s","concat"],"sources":["/Users/roaldmaravillas/ro/github/scaffold-appsync-events/node_modules/aws-appsync/node_modules/graphql/module/validation/rules/NoFragmentCycles.js"],"sourcesContent":["\nimport { GraphQLError } from '../../error'; /**\n                                             * Copyright (c) 2015-present, Facebook, Inc.\n                                             *\n                                             * This source code is licensed under the MIT license found in the\n                                             * LICENSE file in the root directory of this source tree.\n                                             *\n                                             * \n                                             */\n\nexport function cycleErrorMessage(fragName, spreadNames) {\n  var via = spreadNames.length ? ' via ' + spreadNames.join(', ') : '';\n  return 'Cannot spread fragment \"' + fragName + '\" within itself' + via + '.';\n}\n\nexport function NoFragmentCycles(context) {\n  // Tracks already visited fragments to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  var visitedFrags = Object.create(null);\n\n  // Array of AST nodes used to produce meaningful errors\n  var spreadPath = [];\n\n  // Position in the spread path\n  var spreadPathIndexByName = Object.create(null);\n\n  return {\n    OperationDefinition: function OperationDefinition() {\n      return false;\n    },\n    FragmentDefinition: function FragmentDefinition(node) {\n      if (!visitedFrags[node.name.value]) {\n        detectCycleRecursive(node);\n      }\n      return false;\n    }\n  };\n\n  // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n  function detectCycleRecursive(fragment) {\n    var fragmentName = fragment.name.value;\n    visitedFrags[fragmentName] = true;\n\n    var spreadNodes = context.getFragmentSpreads(fragment.selectionSet);\n    if (spreadNodes.length === 0) {\n      return;\n    }\n\n    spreadPathIndexByName[fragmentName] = spreadPath.length;\n\n    for (var i = 0; i < spreadNodes.length; i++) {\n      var spreadNode = spreadNodes[i];\n      var spreadName = spreadNode.name.value;\n      var cycleIndex = spreadPathIndexByName[spreadName];\n\n      if (cycleIndex === undefined) {\n        spreadPath.push(spreadNode);\n        if (!visitedFrags[spreadName]) {\n          var spreadFragment = context.getFragment(spreadName);\n          if (spreadFragment) {\n            detectCycleRecursive(spreadFragment);\n          }\n        }\n        spreadPath.pop();\n      } else {\n        var cyclePath = spreadPath.slice(cycleIndex);\n        context.reportError(new GraphQLError(cycleErrorMessage(spreadName, cyclePath.map(function (s) {\n          return s.name.value;\n        })), cyclePath.concat(spreadNode)));\n      }\n    }\n\n    spreadPathIndexByName[fragmentName] = undefined;\n  }\n}"],"mappings":"AACA,SAASA,YAAT,QAA6B,aAA7B;AAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASC,iBAAT,CAA2BC,QAA3B,EAAqCC,WAArC,EAAkD;EACvD,IAAIC,GAAG,GAAGD,WAAW,CAACE,MAAZ,GAAqB,UAAUF,WAAW,CAACG,IAAZ,CAAiB,IAAjB,CAA/B,GAAwD,EAAlE;EACA,OAAO,6BAA6BJ,QAA7B,GAAwC,iBAAxC,GAA4DE,GAA5D,GAAkE,GAAzE;AACD;AAED,OAAO,SAASG,gBAAT,CAA0BC,OAA1B,EAAmC;EACxC;EACA;EACA,IAAIC,YAAY,GAAGC,MAAM,CAACC,MAAP,CAAc,IAAd,CAAnB,CAHwC,CAKxC;;EACA,IAAIC,UAAU,GAAG,EAAjB,CANwC,CAQxC;;EACA,IAAIC,qBAAqB,GAAGH,MAAM,CAACC,MAAP,CAAc,IAAd,CAA5B;EAEA,OAAO;IACLG,mBAAmB,EAAE,SAASA,mBAAT,GAA+B;MAClD,OAAO,KAAP;IACD,CAHI;IAILC,kBAAkB,EAAE,SAASA,kBAAT,CAA4BC,IAA5B,EAAkC;MACpD,IAAI,CAACP,YAAY,CAACO,IAAI,CAACC,IAAL,CAAUC,KAAX,CAAjB,EAAoC;QAClCC,oBAAoB,CAACH,IAAD,CAApB;MACD;;MACD,OAAO,KAAP;IACD;EATI,CAAP,CAXwC,CAuBxC;EACA;EACA;;EACA,SAASG,oBAAT,CAA8BC,QAA9B,EAAwC;IACtC,IAAIC,YAAY,GAAGD,QAAQ,CAACH,IAAT,CAAcC,KAAjC;IACAT,YAAY,CAACY,YAAD,CAAZ,GAA6B,IAA7B;IAEA,IAAIC,WAAW,GAAGd,OAAO,CAACe,kBAAR,CAA2BH,QAAQ,CAACI,YAApC,CAAlB;;IACA,IAAIF,WAAW,CAACjB,MAAZ,KAAuB,CAA3B,EAA8B;MAC5B;IACD;;IAEDQ,qBAAqB,CAACQ,YAAD,CAArB,GAAsCT,UAAU,CAACP,MAAjD;;IAEA,KAAK,IAAIoB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,WAAW,CAACjB,MAAhC,EAAwCoB,CAAC,EAAzC,EAA6C;MAC3C,IAAIC,UAAU,GAAGJ,WAAW,CAACG,CAAD,CAA5B;MACA,IAAIE,UAAU,GAAGD,UAAU,CAACT,IAAX,CAAgBC,KAAjC;MACA,IAAIU,UAAU,GAAGf,qBAAqB,CAACc,UAAD,CAAtC;;MAEA,IAAIC,UAAU,KAAKC,SAAnB,EAA8B;QAC5BjB,UAAU,CAACkB,IAAX,CAAgBJ,UAAhB;;QACA,IAAI,CAACjB,YAAY,CAACkB,UAAD,CAAjB,EAA+B;UAC7B,IAAII,cAAc,GAAGvB,OAAO,CAACwB,WAAR,CAAoBL,UAApB,CAArB;;UACA,IAAII,cAAJ,EAAoB;YAClBZ,oBAAoB,CAACY,cAAD,CAApB;UACD;QACF;;QACDnB,UAAU,CAACqB,GAAX;MACD,CATD,MASO;QACL,IAAIC,SAAS,GAAGtB,UAAU,CAACuB,KAAX,CAAiBP,UAAjB,CAAhB;QACApB,OAAO,CAAC4B,WAAR,CAAoB,IAAIpC,YAAJ,CAAiBC,iBAAiB,CAAC0B,UAAD,EAAaO,SAAS,CAACG,GAAV,CAAc,UAAUC,CAAV,EAAa;UAC5F,OAAOA,CAAC,CAACrB,IAAF,CAAOC,KAAd;QACD,CAFkE,CAAb,CAAlC,EAEfgB,SAAS,CAACK,MAAV,CAAiBb,UAAjB,CAFe,CAApB;MAGD;IACF;;IAEDb,qBAAqB,CAACQ,YAAD,CAArB,GAAsCQ,SAAtC;EACD;AACF"},"metadata":{},"sourceType":"module"}