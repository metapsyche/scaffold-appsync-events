{"ast":null,"code":"\"use strict\";\n\nvar Cache = require(\"./cache.js\").Cache;\n\nvar tuple = require(\"immutable-tuple\").tuple;\n\nvar Entry = require(\"./entry.js\").Entry;\n\nvar getLocal = require(\"./local.js\").get; // Exported so that custom makeCacheKey functions can easily reuse the\n// default implementation (with different arguments).\n\n\nexports.defaultMakeCacheKey = tuple;\n\nfunction normalizeOptions(options) {\n  options = options || Object.create(null);\n\n  if (typeof options.makeCacheKey !== \"function\") {\n    options.makeCacheKey = tuple;\n  }\n\n  if (typeof options.max !== \"number\") {\n    options.max = Math.pow(2, 16);\n  }\n\n  return options;\n}\n\nfunction wrap(fn, options) {\n  options = normalizeOptions(options); // If this wrapped function is disposable, then its creator does not\n  // care about its return value, and it should be removed from the cache\n  // immediately when it no longer has any parents that depend on it.\n\n  var disposable = !!options.disposable;\n  var cache = new Cache({\n    max: options.max,\n    dispose: function (key, entry) {\n      entry.dispose();\n    }\n  });\n\n  function reportOrphan(entry) {\n    if (disposable) {\n      // Triggers the entry.dispose() call above.\n      cache.delete(entry.key);\n      return true;\n    }\n  }\n\n  function optimistic() {\n    if (disposable && !getLocal().currentParentEntry) {\n      // If there's no current parent computation, and this wrapped\n      // function is disposable (meaning we don't care about entry.value,\n      // just dependency tracking), then we can short-cut everything else\n      // in this function, because entry.recompute() is going to recycle\n      // the entry object without recomputing anything, anyway.\n      return;\n    }\n\n    var key = options.makeCacheKey.apply(null, arguments);\n\n    if (!key) {\n      return fn.apply(null, arguments);\n    }\n\n    var args = [],\n        len = arguments.length;\n\n    while (len--) args[len] = arguments[len];\n\n    var entry = cache.get(key);\n\n    if (entry) {\n      entry.args = args;\n    } else {\n      cache.set(key, entry = Entry.acquire(fn, key, args));\n      entry.subscribe = options.subscribe;\n\n      if (disposable) {\n        entry.reportOrphan = reportOrphan;\n      }\n    }\n\n    var value = entry.recompute(); // Move this entry to the front of the least-recently used queue,\n    // since we just finished computing its value.\n\n    cache.set(key, entry); // Clean up any excess entries in the cache, but only if this entry\n    // has no parents, which means we're not in the middle of a larger\n    // computation that might be flummoxed by the cleaning.\n\n    if (entry.parents.size === 0) {\n      cache.clean();\n    } // If options.disposable is truthy, the caller of wrap is telling us\n    // they don't care about the result of entry.recompute(), so we should\n    // avoid returning the value, so it won't be accidentally used.\n\n\n    if (!disposable) {\n      return value;\n    }\n  }\n\n  optimistic.dirty = function () {\n    var key = options.makeCacheKey.apply(null, arguments);\n\n    if (!key) {\n      return;\n    }\n\n    if (!cache.has(key)) {\n      return;\n    }\n\n    cache.get(key).setDirty();\n  };\n\n  return optimistic;\n}\n\nexports.wrap = wrap;","map":{"version":3,"names":["Cache","require","tuple","Entry","getLocal","get","exports","defaultMakeCacheKey","normalizeOptions","options","Object","create","makeCacheKey","max","Math","pow","wrap","fn","disposable","cache","dispose","key","entry","reportOrphan","delete","optimistic","currentParentEntry","apply","arguments","args","len","length","set","acquire","subscribe","value","recompute","parents","size","clean","dirty","has","setDirty"],"sources":["/Users/roaldmaravillas/ro/sandbox/aws-mobile-appsync-events-starter-react/node_modules/optimism/lib/index.js"],"sourcesContent":["\"use strict\";\n\nvar Cache = require(\"./cache.js\").Cache;\nvar tuple = require(\"immutable-tuple\").tuple;\nvar Entry = require(\"./entry.js\").Entry;\nvar getLocal = require(\"./local.js\").get;\n\n// Exported so that custom makeCacheKey functions can easily reuse the\n// default implementation (with different arguments).\nexports.defaultMakeCacheKey = tuple;\n\nfunction normalizeOptions(options) {\n  options = options || Object.create(null);\n\n  if (typeof options.makeCacheKey !== \"function\") {\n    options.makeCacheKey = tuple;\n  }\n\n  if (typeof options.max !== \"number\") {\n    options.max = Math.pow(2, 16);\n  }\n\n  return options;\n}\n\nfunction wrap(fn, options) {\n  options = normalizeOptions(options);\n\n  // If this wrapped function is disposable, then its creator does not\n  // care about its return value, and it should be removed from the cache\n  // immediately when it no longer has any parents that depend on it.\n  var disposable = !! options.disposable;\n\n  var cache = new Cache({\n    max: options.max,\n    dispose: function (key, entry) {\n      entry.dispose();\n    }\n  });\n\n  function reportOrphan(entry) {\n    if (disposable) {\n      // Triggers the entry.dispose() call above.\n      cache.delete(entry.key);\n      return true;\n    }\n  }\n\n  function optimistic() {\n    if (disposable && ! getLocal().currentParentEntry) {\n      // If there's no current parent computation, and this wrapped\n      // function is disposable (meaning we don't care about entry.value,\n      // just dependency tracking), then we can short-cut everything else\n      // in this function, because entry.recompute() is going to recycle\n      // the entry object without recomputing anything, anyway.\n      return;\n    }\n\n    var key = options.makeCacheKey.apply(null, arguments);\n    if (! key) {\n      return fn.apply(null, arguments);\n    }\n\n    var args = [], len = arguments.length;\n    while (len--) args[len] = arguments[len];\n\n    var entry = cache.get(key);\n    if (entry) {\n      entry.args = args;\n    } else {\n      cache.set(key, entry = Entry.acquire(fn, key, args));\n      entry.subscribe = options.subscribe;\n      if (disposable) {\n        entry.reportOrphan = reportOrphan;\n      }\n    }\n\n    var value = entry.recompute();\n\n    // Move this entry to the front of the least-recently used queue,\n    // since we just finished computing its value.\n    cache.set(key, entry);\n\n    // Clean up any excess entries in the cache, but only if this entry\n    // has no parents, which means we're not in the middle of a larger\n    // computation that might be flummoxed by the cleaning.\n    if (entry.parents.size === 0) {\n      cache.clean();\n    }\n\n    // If options.disposable is truthy, the caller of wrap is telling us\n    // they don't care about the result of entry.recompute(), so we should\n    // avoid returning the value, so it won't be accidentally used.\n    if (! disposable) {\n      return value;\n    }\n  }\n\n  optimistic.dirty = function () {\n    var key = options.makeCacheKey.apply(null, arguments);\n    if (! key) {\n      return;\n    }\n\n    if (! cache.has(key)) {\n      return;\n    }\n\n    cache.get(key).setDirty();\n  };\n\n  return optimistic;\n}\n\nexports.wrap = wrap;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}