{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\nimport invariant from '../jsutils/invariant';\nimport { GraphQLError } from '../error';\nimport { visit, visitInParallel, visitWithTypeInfo } from '../language/visitor';\nimport { Kind } from '../language/kinds';\nimport { GraphQLSchema } from '../type/schema';\nimport { assertValidSchema } from '../type/validate';\nimport { TypeInfo } from '../utilities/TypeInfo';\nimport { specifiedRules } from './specifiedRules';\n/**\n * Implements the \"Validation\" section of the spec.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the document is valid.\n *\n * A list of specific validation rules may be provided. If not provided, the\n * default list of rules defined by the GraphQL specification will be used.\n *\n * Each validation rules is a function which returns a visitor\n * (see the language/visitor API). Visitor methods are expected to return\n * GraphQLErrors, or Arrays of GraphQLErrors when invalid.\n *\n * Optionally a custom TypeInfo instance may be provided. If not provided, one\n * will be created from the provided schema.\n */\n\nexport function validate(schema, ast, rules, typeInfo) {\n  !ast ? invariant(0, 'Must provide document') : void 0; // If the schema used for validation is invalid, throw an error.\n\n  assertValidSchema(schema);\n  return visitUsingRules(schema, typeInfo || new TypeInfo(schema), ast, rules || specifiedRules);\n}\n/**\n * This uses a specialized visitor which runs multiple visitors in parallel,\n * while maintaining the visitor skip and break API.\n *\n * @internal\n */\n\nfunction visitUsingRules(schema, typeInfo, documentAST, rules) {\n  var context = new ValidationContext(schema, documentAST, typeInfo);\n  var visitors = rules.map(function (rule) {\n    return rule(context);\n  }); // Visit the whole document with each instance of all provided rules.\n\n  visit(documentAST, visitWithTypeInfo(typeInfo, visitInParallel(visitors)));\n  return context.getErrors();\n}\n/**\n * An instance of this class is passed as the \"this\" context to all validators,\n * allowing access to commonly useful contextual information from within a\n * validation rule.\n */\n\n\nexport var ValidationContext = function () {\n  function ValidationContext(schema, ast, typeInfo) {\n    _classCallCheck(this, ValidationContext);\n\n    this._schema = schema;\n    this._ast = ast;\n    this._typeInfo = typeInfo;\n    this._errors = [];\n    this._fragmentSpreads = new Map();\n    this._recursivelyReferencedFragments = new Map();\n    this._variableUsages = new Map();\n    this._recursiveVariableUsages = new Map();\n  }\n\n  ValidationContext.prototype.reportError = function reportError(error) {\n    this._errors.push(error);\n  };\n\n  ValidationContext.prototype.getErrors = function getErrors() {\n    return this._errors;\n  };\n\n  ValidationContext.prototype.getSchema = function getSchema() {\n    return this._schema;\n  };\n\n  ValidationContext.prototype.getDocument = function getDocument() {\n    return this._ast;\n  };\n\n  ValidationContext.prototype.getFragment = function getFragment(name) {\n    var fragments = this._fragments;\n\n    if (!fragments) {\n      this._fragments = fragments = this.getDocument().definitions.reduce(function (frags, statement) {\n        if (statement.kind === Kind.FRAGMENT_DEFINITION) {\n          frags[statement.name.value] = statement;\n        }\n\n        return frags;\n      }, Object.create(null));\n    }\n\n    return fragments[name];\n  };\n\n  ValidationContext.prototype.getFragmentSpreads = function getFragmentSpreads(node) {\n    var spreads = this._fragmentSpreads.get(node);\n\n    if (!spreads) {\n      spreads = [];\n      var setsToVisit = [node];\n\n      while (setsToVisit.length !== 0) {\n        var set = setsToVisit.pop();\n\n        for (var i = 0; i < set.selections.length; i++) {\n          var selection = set.selections[i];\n\n          if (selection.kind === Kind.FRAGMENT_SPREAD) {\n            spreads.push(selection);\n          } else if (selection.selectionSet) {\n            setsToVisit.push(selection.selectionSet);\n          }\n        }\n      }\n\n      this._fragmentSpreads.set(node, spreads);\n    }\n\n    return spreads;\n  };\n\n  ValidationContext.prototype.getRecursivelyReferencedFragments = function getRecursivelyReferencedFragments(operation) {\n    var fragments = this._recursivelyReferencedFragments.get(operation);\n\n    if (!fragments) {\n      fragments = [];\n      var collectedNames = Object.create(null);\n      var nodesToVisit = [operation.selectionSet];\n\n      while (nodesToVisit.length !== 0) {\n        var _node = nodesToVisit.pop();\n\n        var spreads = this.getFragmentSpreads(_node);\n\n        for (var i = 0; i < spreads.length; i++) {\n          var fragName = spreads[i].name.value;\n\n          if (collectedNames[fragName] !== true) {\n            collectedNames[fragName] = true;\n            var fragment = this.getFragment(fragName);\n\n            if (fragment) {\n              fragments.push(fragment);\n              nodesToVisit.push(fragment.selectionSet);\n            }\n          }\n        }\n      }\n\n      this._recursivelyReferencedFragments.set(operation, fragments);\n    }\n\n    return fragments;\n  };\n\n  ValidationContext.prototype.getVariableUsages = function getVariableUsages(node) {\n    var usages = this._variableUsages.get(node);\n\n    if (!usages) {\n      var newUsages = [];\n      var typeInfo = new TypeInfo(this._schema);\n      visit(node, visitWithTypeInfo(typeInfo, {\n        VariableDefinition: function VariableDefinition() {\n          return false;\n        },\n        Variable: function Variable(variable) {\n          newUsages.push({\n            node: variable,\n            type: typeInfo.getInputType()\n          });\n        }\n      }));\n      usages = newUsages;\n\n      this._variableUsages.set(node, usages);\n    }\n\n    return usages;\n  };\n\n  ValidationContext.prototype.getRecursiveVariableUsages = function getRecursiveVariableUsages(operation) {\n    var usages = this._recursiveVariableUsages.get(operation);\n\n    if (!usages) {\n      usages = this.getVariableUsages(operation);\n      var fragments = this.getRecursivelyReferencedFragments(operation);\n\n      for (var i = 0; i < fragments.length; i++) {\n        Array.prototype.push.apply(usages, this.getVariableUsages(fragments[i]));\n      }\n\n      this._recursiveVariableUsages.set(operation, usages);\n    }\n\n    return usages;\n  };\n\n  ValidationContext.prototype.getType = function getType() {\n    return this._typeInfo.getType();\n  };\n\n  ValidationContext.prototype.getParentType = function getParentType() {\n    return this._typeInfo.getParentType();\n  };\n\n  ValidationContext.prototype.getInputType = function getInputType() {\n    return this._typeInfo.getInputType();\n  };\n\n  ValidationContext.prototype.getParentInputType = function getParentInputType() {\n    return this._typeInfo.getParentInputType();\n  };\n\n  ValidationContext.prototype.getFieldDef = function getFieldDef() {\n    return this._typeInfo.getFieldDef();\n  };\n\n  ValidationContext.prototype.getDirective = function getDirective() {\n    return this._typeInfo.getDirective();\n  };\n\n  ValidationContext.prototype.getArgument = function getArgument() {\n    return this._typeInfo.getArgument();\n  };\n\n  return ValidationContext;\n}();","map":{"version":3,"names":["_classCallCheck","instance","Constructor","TypeError","invariant","GraphQLError","visit","visitInParallel","visitWithTypeInfo","Kind","GraphQLSchema","assertValidSchema","TypeInfo","specifiedRules","validate","schema","ast","rules","typeInfo","visitUsingRules","documentAST","context","ValidationContext","visitors","map","rule","getErrors","_schema","_ast","_typeInfo","_errors","_fragmentSpreads","Map","_recursivelyReferencedFragments","_variableUsages","_recursiveVariableUsages","prototype","reportError","error","push","getSchema","getDocument","getFragment","name","fragments","_fragments","definitions","reduce","frags","statement","kind","FRAGMENT_DEFINITION","value","Object","create","getFragmentSpreads","node","spreads","get","setsToVisit","length","set","pop","i","selections","selection","FRAGMENT_SPREAD","selectionSet","getRecursivelyReferencedFragments","operation","collectedNames","nodesToVisit","_node","fragName","fragment","getVariableUsages","usages","newUsages","VariableDefinition","Variable","variable","type","getInputType","getRecursiveVariableUsages","Array","apply","getType","getParentType","getParentInputType","getFieldDef","getDirective","getArgument"],"sources":["/Users/roaldmaravillas/ro/sandbox/aws-mobile-appsync-events-starter-react/node_modules/aws-appsync/node_modules/graphql/module/validation/validate.js"],"sourcesContent":["function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nimport invariant from '../jsutils/invariant';\n\nimport { GraphQLError } from '../error';\nimport { visit, visitInParallel, visitWithTypeInfo } from '../language/visitor';\nimport { Kind } from '../language/kinds';\n\nimport { GraphQLSchema } from '../type/schema';\n\nimport { assertValidSchema } from '../type/validate';\nimport { TypeInfo } from '../utilities/TypeInfo';\nimport { specifiedRules } from './specifiedRules';\n\n/**\n * Implements the \"Validation\" section of the spec.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the document is valid.\n *\n * A list of specific validation rules may be provided. If not provided, the\n * default list of rules defined by the GraphQL specification will be used.\n *\n * Each validation rules is a function which returns a visitor\n * (see the language/visitor API). Visitor methods are expected to return\n * GraphQLErrors, or Arrays of GraphQLErrors when invalid.\n *\n * Optionally a custom TypeInfo instance may be provided. If not provided, one\n * will be created from the provided schema.\n */\nexport function validate(schema, ast, rules, typeInfo) {\n  !ast ? invariant(0, 'Must provide document') : void 0;\n  // If the schema used for validation is invalid, throw an error.\n  assertValidSchema(schema);\n  return visitUsingRules(schema, typeInfo || new TypeInfo(schema), ast, rules || specifiedRules);\n}\n\n/**\n * This uses a specialized visitor which runs multiple visitors in parallel,\n * while maintaining the visitor skip and break API.\n *\n * @internal\n */\nfunction visitUsingRules(schema, typeInfo, documentAST, rules) {\n  var context = new ValidationContext(schema, documentAST, typeInfo);\n  var visitors = rules.map(function (rule) {\n    return rule(context);\n  });\n  // Visit the whole document with each instance of all provided rules.\n  visit(documentAST, visitWithTypeInfo(typeInfo, visitInParallel(visitors)));\n  return context.getErrors();\n}\n\n/**\n * An instance of this class is passed as the \"this\" context to all validators,\n * allowing access to commonly useful contextual information from within a\n * validation rule.\n */\nexport var ValidationContext = function () {\n  function ValidationContext(schema, ast, typeInfo) {\n    _classCallCheck(this, ValidationContext);\n\n    this._schema = schema;\n    this._ast = ast;\n    this._typeInfo = typeInfo;\n    this._errors = [];\n    this._fragmentSpreads = new Map();\n    this._recursivelyReferencedFragments = new Map();\n    this._variableUsages = new Map();\n    this._recursiveVariableUsages = new Map();\n  }\n\n  ValidationContext.prototype.reportError = function reportError(error) {\n    this._errors.push(error);\n  };\n\n  ValidationContext.prototype.getErrors = function getErrors() {\n    return this._errors;\n  };\n\n  ValidationContext.prototype.getSchema = function getSchema() {\n    return this._schema;\n  };\n\n  ValidationContext.prototype.getDocument = function getDocument() {\n    return this._ast;\n  };\n\n  ValidationContext.prototype.getFragment = function getFragment(name) {\n    var fragments = this._fragments;\n    if (!fragments) {\n      this._fragments = fragments = this.getDocument().definitions.reduce(function (frags, statement) {\n        if (statement.kind === Kind.FRAGMENT_DEFINITION) {\n          frags[statement.name.value] = statement;\n        }\n        return frags;\n      }, Object.create(null));\n    }\n    return fragments[name];\n  };\n\n  ValidationContext.prototype.getFragmentSpreads = function getFragmentSpreads(node) {\n    var spreads = this._fragmentSpreads.get(node);\n    if (!spreads) {\n      spreads = [];\n      var setsToVisit = [node];\n      while (setsToVisit.length !== 0) {\n        var set = setsToVisit.pop();\n        for (var i = 0; i < set.selections.length; i++) {\n          var selection = set.selections[i];\n          if (selection.kind === Kind.FRAGMENT_SPREAD) {\n            spreads.push(selection);\n          } else if (selection.selectionSet) {\n            setsToVisit.push(selection.selectionSet);\n          }\n        }\n      }\n      this._fragmentSpreads.set(node, spreads);\n    }\n    return spreads;\n  };\n\n  ValidationContext.prototype.getRecursivelyReferencedFragments = function getRecursivelyReferencedFragments(operation) {\n    var fragments = this._recursivelyReferencedFragments.get(operation);\n    if (!fragments) {\n      fragments = [];\n      var collectedNames = Object.create(null);\n      var nodesToVisit = [operation.selectionSet];\n      while (nodesToVisit.length !== 0) {\n        var _node = nodesToVisit.pop();\n        var spreads = this.getFragmentSpreads(_node);\n        for (var i = 0; i < spreads.length; i++) {\n          var fragName = spreads[i].name.value;\n          if (collectedNames[fragName] !== true) {\n            collectedNames[fragName] = true;\n            var fragment = this.getFragment(fragName);\n            if (fragment) {\n              fragments.push(fragment);\n              nodesToVisit.push(fragment.selectionSet);\n            }\n          }\n        }\n      }\n      this._recursivelyReferencedFragments.set(operation, fragments);\n    }\n    return fragments;\n  };\n\n  ValidationContext.prototype.getVariableUsages = function getVariableUsages(node) {\n    var usages = this._variableUsages.get(node);\n    if (!usages) {\n      var newUsages = [];\n      var typeInfo = new TypeInfo(this._schema);\n      visit(node, visitWithTypeInfo(typeInfo, {\n        VariableDefinition: function VariableDefinition() {\n          return false;\n        },\n        Variable: function Variable(variable) {\n          newUsages.push({ node: variable, type: typeInfo.getInputType() });\n        }\n      }));\n      usages = newUsages;\n      this._variableUsages.set(node, usages);\n    }\n    return usages;\n  };\n\n  ValidationContext.prototype.getRecursiveVariableUsages = function getRecursiveVariableUsages(operation) {\n    var usages = this._recursiveVariableUsages.get(operation);\n    if (!usages) {\n      usages = this.getVariableUsages(operation);\n      var fragments = this.getRecursivelyReferencedFragments(operation);\n      for (var i = 0; i < fragments.length; i++) {\n        Array.prototype.push.apply(usages, this.getVariableUsages(fragments[i]));\n      }\n      this._recursiveVariableUsages.set(operation, usages);\n    }\n    return usages;\n  };\n\n  ValidationContext.prototype.getType = function getType() {\n    return this._typeInfo.getType();\n  };\n\n  ValidationContext.prototype.getParentType = function getParentType() {\n    return this._typeInfo.getParentType();\n  };\n\n  ValidationContext.prototype.getInputType = function getInputType() {\n    return this._typeInfo.getInputType();\n  };\n\n  ValidationContext.prototype.getParentInputType = function getParentInputType() {\n    return this._typeInfo.getParentInputType();\n  };\n\n  ValidationContext.prototype.getFieldDef = function getFieldDef() {\n    return this._typeInfo.getFieldDef();\n  };\n\n  ValidationContext.prototype.getDirective = function getDirective() {\n    return this._typeInfo.getDirective();\n  };\n\n  ValidationContext.prototype.getArgument = function getArgument() {\n    return this._typeInfo.getArgument();\n  };\n\n  return ValidationContext;\n}();"],"mappings":"AAAA,SAASA,eAAT,CAAyBC,QAAzB,EAAmCC,WAAnC,EAAgD;EAAE,IAAI,EAAED,QAAQ,YAAYC,WAAtB,CAAJ,EAAwC;IAAE,MAAM,IAAIC,SAAJ,CAAc,mCAAd,CAAN;EAA2D;AAAE;AAEzJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,OAAOC,SAAP,MAAsB,sBAAtB;AAEA,SAASC,YAAT,QAA6B,UAA7B;AACA,SAASC,KAAT,EAAgBC,eAAhB,EAAiCC,iBAAjC,QAA0D,qBAA1D;AACA,SAASC,IAAT,QAAqB,mBAArB;AAEA,SAASC,aAAT,QAA8B,gBAA9B;AAEA,SAASC,iBAAT,QAAkC,kBAAlC;AACA,SAASC,QAAT,QAAyB,uBAAzB;AACA,SAASC,cAAT,QAA+B,kBAA/B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,QAAT,CAAkBC,MAAlB,EAA0BC,GAA1B,EAA+BC,KAA/B,EAAsCC,QAAtC,EAAgD;EACrD,CAACF,GAAD,GAAOZ,SAAS,CAAC,CAAD,EAAI,uBAAJ,CAAhB,GAA+C,KAAK,CAApD,CADqD,CAErD;;EACAO,iBAAiB,CAACI,MAAD,CAAjB;EACA,OAAOI,eAAe,CAACJ,MAAD,EAASG,QAAQ,IAAI,IAAIN,QAAJ,CAAaG,MAAb,CAArB,EAA2CC,GAA3C,EAAgDC,KAAK,IAAIJ,cAAzD,CAAtB;AACD;AAED;AACA;AACA;AACA;AACA;AACA;;AACA,SAASM,eAAT,CAAyBJ,MAAzB,EAAiCG,QAAjC,EAA2CE,WAA3C,EAAwDH,KAAxD,EAA+D;EAC7D,IAAII,OAAO,GAAG,IAAIC,iBAAJ,CAAsBP,MAAtB,EAA8BK,WAA9B,EAA2CF,QAA3C,CAAd;EACA,IAAIK,QAAQ,GAAGN,KAAK,CAACO,GAAN,CAAU,UAAUC,IAAV,EAAgB;IACvC,OAAOA,IAAI,CAACJ,OAAD,CAAX;EACD,CAFc,CAAf,CAF6D,CAK7D;;EACAf,KAAK,CAACc,WAAD,EAAcZ,iBAAiB,CAACU,QAAD,EAAWX,eAAe,CAACgB,QAAD,CAA1B,CAA/B,CAAL;EACA,OAAOF,OAAO,CAACK,SAAR,EAAP;AACD;AAED;AACA;AACA;AACA;AACA;;;AACA,OAAO,IAAIJ,iBAAiB,GAAG,YAAY;EACzC,SAASA,iBAAT,CAA2BP,MAA3B,EAAmCC,GAAnC,EAAwCE,QAAxC,EAAkD;IAChDlB,eAAe,CAAC,IAAD,EAAOsB,iBAAP,CAAf;;IAEA,KAAKK,OAAL,GAAeZ,MAAf;IACA,KAAKa,IAAL,GAAYZ,GAAZ;IACA,KAAKa,SAAL,GAAiBX,QAAjB;IACA,KAAKY,OAAL,GAAe,EAAf;IACA,KAAKC,gBAAL,GAAwB,IAAIC,GAAJ,EAAxB;IACA,KAAKC,+BAAL,GAAuC,IAAID,GAAJ,EAAvC;IACA,KAAKE,eAAL,GAAuB,IAAIF,GAAJ,EAAvB;IACA,KAAKG,wBAAL,GAAgC,IAAIH,GAAJ,EAAhC;EACD;;EAEDV,iBAAiB,CAACc,SAAlB,CAA4BC,WAA5B,GAA0C,SAASA,WAAT,CAAqBC,KAArB,EAA4B;IACpE,KAAKR,OAAL,CAAaS,IAAb,CAAkBD,KAAlB;EACD,CAFD;;EAIAhB,iBAAiB,CAACc,SAAlB,CAA4BV,SAA5B,GAAwC,SAASA,SAAT,GAAqB;IAC3D,OAAO,KAAKI,OAAZ;EACD,CAFD;;EAIAR,iBAAiB,CAACc,SAAlB,CAA4BI,SAA5B,GAAwC,SAASA,SAAT,GAAqB;IAC3D,OAAO,KAAKb,OAAZ;EACD,CAFD;;EAIAL,iBAAiB,CAACc,SAAlB,CAA4BK,WAA5B,GAA0C,SAASA,WAAT,GAAuB;IAC/D,OAAO,KAAKb,IAAZ;EACD,CAFD;;EAIAN,iBAAiB,CAACc,SAAlB,CAA4BM,WAA5B,GAA0C,SAASA,WAAT,CAAqBC,IAArB,EAA2B;IACnE,IAAIC,SAAS,GAAG,KAAKC,UAArB;;IACA,IAAI,CAACD,SAAL,EAAgB;MACd,KAAKC,UAAL,GAAkBD,SAAS,GAAG,KAAKH,WAAL,GAAmBK,WAAnB,CAA+BC,MAA/B,CAAsC,UAAUC,KAAV,EAAiBC,SAAjB,EAA4B;QAC9F,IAAIA,SAAS,CAACC,IAAV,KAAmBzC,IAAI,CAAC0C,mBAA5B,EAAiD;UAC/CH,KAAK,CAACC,SAAS,CAACN,IAAV,CAAeS,KAAhB,CAAL,GAA8BH,SAA9B;QACD;;QACD,OAAOD,KAAP;MACD,CAL6B,EAK3BK,MAAM,CAACC,MAAP,CAAc,IAAd,CAL2B,CAA9B;IAMD;;IACD,OAAOV,SAAS,CAACD,IAAD,CAAhB;EACD,CAXD;;EAaArB,iBAAiB,CAACc,SAAlB,CAA4BmB,kBAA5B,GAAiD,SAASA,kBAAT,CAA4BC,IAA5B,EAAkC;IACjF,IAAIC,OAAO,GAAG,KAAK1B,gBAAL,CAAsB2B,GAAtB,CAA0BF,IAA1B,CAAd;;IACA,IAAI,CAACC,OAAL,EAAc;MACZA,OAAO,GAAG,EAAV;MACA,IAAIE,WAAW,GAAG,CAACH,IAAD,CAAlB;;MACA,OAAOG,WAAW,CAACC,MAAZ,KAAuB,CAA9B,EAAiC;QAC/B,IAAIC,GAAG,GAAGF,WAAW,CAACG,GAAZ,EAAV;;QACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,GAAG,CAACG,UAAJ,CAAeJ,MAAnC,EAA2CG,CAAC,EAA5C,EAAgD;UAC9C,IAAIE,SAAS,GAAGJ,GAAG,CAACG,UAAJ,CAAeD,CAAf,CAAhB;;UACA,IAAIE,SAAS,CAACf,IAAV,KAAmBzC,IAAI,CAACyD,eAA5B,EAA6C;YAC3CT,OAAO,CAAClB,IAAR,CAAa0B,SAAb;UACD,CAFD,MAEO,IAAIA,SAAS,CAACE,YAAd,EAA4B;YACjCR,WAAW,CAACpB,IAAZ,CAAiB0B,SAAS,CAACE,YAA3B;UACD;QACF;MACF;;MACD,KAAKpC,gBAAL,CAAsB8B,GAAtB,CAA0BL,IAA1B,EAAgCC,OAAhC;IACD;;IACD,OAAOA,OAAP;EACD,CAnBD;;EAqBAnC,iBAAiB,CAACc,SAAlB,CAA4BgC,iCAA5B,GAAgE,SAASA,iCAAT,CAA2CC,SAA3C,EAAsD;IACpH,IAAIzB,SAAS,GAAG,KAAKX,+BAAL,CAAqCyB,GAArC,CAAyCW,SAAzC,CAAhB;;IACA,IAAI,CAACzB,SAAL,EAAgB;MACdA,SAAS,GAAG,EAAZ;MACA,IAAI0B,cAAc,GAAGjB,MAAM,CAACC,MAAP,CAAc,IAAd,CAArB;MACA,IAAIiB,YAAY,GAAG,CAACF,SAAS,CAACF,YAAX,CAAnB;;MACA,OAAOI,YAAY,CAACX,MAAb,KAAwB,CAA/B,EAAkC;QAChC,IAAIY,KAAK,GAAGD,YAAY,CAACT,GAAb,EAAZ;;QACA,IAAIL,OAAO,GAAG,KAAKF,kBAAL,CAAwBiB,KAAxB,CAAd;;QACA,KAAK,IAAIT,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,OAAO,CAACG,MAA5B,EAAoCG,CAAC,EAArC,EAAyC;UACvC,IAAIU,QAAQ,GAAGhB,OAAO,CAACM,CAAD,CAAP,CAAWpB,IAAX,CAAgBS,KAA/B;;UACA,IAAIkB,cAAc,CAACG,QAAD,CAAd,KAA6B,IAAjC,EAAuC;YACrCH,cAAc,CAACG,QAAD,CAAd,GAA2B,IAA3B;YACA,IAAIC,QAAQ,GAAG,KAAKhC,WAAL,CAAiB+B,QAAjB,CAAf;;YACA,IAAIC,QAAJ,EAAc;cACZ9B,SAAS,CAACL,IAAV,CAAemC,QAAf;cACAH,YAAY,CAAChC,IAAb,CAAkBmC,QAAQ,CAACP,YAA3B;YACD;UACF;QACF;MACF;;MACD,KAAKlC,+BAAL,CAAqC4B,GAArC,CAAyCQ,SAAzC,EAAoDzB,SAApD;IACD;;IACD,OAAOA,SAAP;EACD,CAxBD;;EA0BAtB,iBAAiB,CAACc,SAAlB,CAA4BuC,iBAA5B,GAAgD,SAASA,iBAAT,CAA2BnB,IAA3B,EAAiC;IAC/E,IAAIoB,MAAM,GAAG,KAAK1C,eAAL,CAAqBwB,GAArB,CAAyBF,IAAzB,CAAb;;IACA,IAAI,CAACoB,MAAL,EAAa;MACX,IAAIC,SAAS,GAAG,EAAhB;MACA,IAAI3D,QAAQ,GAAG,IAAIN,QAAJ,CAAa,KAAKe,OAAlB,CAAf;MACArB,KAAK,CAACkD,IAAD,EAAOhD,iBAAiB,CAACU,QAAD,EAAW;QACtC4D,kBAAkB,EAAE,SAASA,kBAAT,GAA8B;UAChD,OAAO,KAAP;QACD,CAHqC;QAItCC,QAAQ,EAAE,SAASA,QAAT,CAAkBC,QAAlB,EAA4B;UACpCH,SAAS,CAACtC,IAAV,CAAe;YAAEiB,IAAI,EAAEwB,QAAR;YAAkBC,IAAI,EAAE/D,QAAQ,CAACgE,YAAT;UAAxB,CAAf;QACD;MANqC,CAAX,CAAxB,CAAL;MAQAN,MAAM,GAAGC,SAAT;;MACA,KAAK3C,eAAL,CAAqB2B,GAArB,CAAyBL,IAAzB,EAA+BoB,MAA/B;IACD;;IACD,OAAOA,MAAP;EACD,CAjBD;;EAmBAtD,iBAAiB,CAACc,SAAlB,CAA4B+C,0BAA5B,GAAyD,SAASA,0BAAT,CAAoCd,SAApC,EAA+C;IACtG,IAAIO,MAAM,GAAG,KAAKzC,wBAAL,CAA8BuB,GAA9B,CAAkCW,SAAlC,CAAb;;IACA,IAAI,CAACO,MAAL,EAAa;MACXA,MAAM,GAAG,KAAKD,iBAAL,CAAuBN,SAAvB,CAAT;MACA,IAAIzB,SAAS,GAAG,KAAKwB,iCAAL,CAAuCC,SAAvC,CAAhB;;MACA,KAAK,IAAIN,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGnB,SAAS,CAACgB,MAA9B,EAAsCG,CAAC,EAAvC,EAA2C;QACzCqB,KAAK,CAAChD,SAAN,CAAgBG,IAAhB,CAAqB8C,KAArB,CAA2BT,MAA3B,EAAmC,KAAKD,iBAAL,CAAuB/B,SAAS,CAACmB,CAAD,CAAhC,CAAnC;MACD;;MACD,KAAK5B,wBAAL,CAA8B0B,GAA9B,CAAkCQ,SAAlC,EAA6CO,MAA7C;IACD;;IACD,OAAOA,MAAP;EACD,CAXD;;EAaAtD,iBAAiB,CAACc,SAAlB,CAA4BkD,OAA5B,GAAsC,SAASA,OAAT,GAAmB;IACvD,OAAO,KAAKzD,SAAL,CAAeyD,OAAf,EAAP;EACD,CAFD;;EAIAhE,iBAAiB,CAACc,SAAlB,CAA4BmD,aAA5B,GAA4C,SAASA,aAAT,GAAyB;IACnE,OAAO,KAAK1D,SAAL,CAAe0D,aAAf,EAAP;EACD,CAFD;;EAIAjE,iBAAiB,CAACc,SAAlB,CAA4B8C,YAA5B,GAA2C,SAASA,YAAT,GAAwB;IACjE,OAAO,KAAKrD,SAAL,CAAeqD,YAAf,EAAP;EACD,CAFD;;EAIA5D,iBAAiB,CAACc,SAAlB,CAA4BoD,kBAA5B,GAAiD,SAASA,kBAAT,GAA8B;IAC7E,OAAO,KAAK3D,SAAL,CAAe2D,kBAAf,EAAP;EACD,CAFD;;EAIAlE,iBAAiB,CAACc,SAAlB,CAA4BqD,WAA5B,GAA0C,SAASA,WAAT,GAAuB;IAC/D,OAAO,KAAK5D,SAAL,CAAe4D,WAAf,EAAP;EACD,CAFD;;EAIAnE,iBAAiB,CAACc,SAAlB,CAA4BsD,YAA5B,GAA2C,SAASA,YAAT,GAAwB;IACjE,OAAO,KAAK7D,SAAL,CAAe6D,YAAf,EAAP;EACD,CAFD;;EAIApE,iBAAiB,CAACc,SAAlB,CAA4BuD,WAA5B,GAA0C,SAASA,WAAT,GAAuB;IAC/D,OAAO,KAAK9D,SAAL,CAAe8D,WAAf,EAAP;EACD,CAFD;;EAIA,OAAOrE,iBAAP;AACD,CAvJ8B,EAAxB"},"metadata":{},"sourceType":"module"}