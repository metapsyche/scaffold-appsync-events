{"ast":null,"code":"var AWS = require('../core');\n\nvar byteLength = AWS.util.string.byteLength;\nvar Buffer = AWS.util.Buffer;\n/**\n * The managed uploader allows for easy and efficient uploading of buffers,\n * blobs, or streams, using a configurable amount of concurrency to perform\n * multipart uploads where possible. This abstraction also enables uploading\n * streams of unknown size due to the use of multipart uploads.\n *\n * To construct a managed upload object, see the {constructor} function.\n *\n * ## Tracking upload progress\n *\n * The managed upload object can also track progress by attaching an\n * 'httpUploadProgress' listener to the upload manager. This event is similar\n * to {AWS.Request~httpUploadProgress} but groups all concurrent upload progress\n * into a single event. See {AWS.S3.ManagedUpload~httpUploadProgress} for more\n * information.\n *\n * ## Handling Multipart Cleanup\n *\n * By default, this class will automatically clean up any multipart uploads\n * when an individual part upload fails. This behavior can be disabled in order\n * to manually handle failures by setting the `leavePartsOnError` configuration\n * option to `true` when initializing the upload object.\n *\n * @!event httpUploadProgress(progress)\n *   Triggered when the uploader has uploaded more data.\n *   @note The `total` property may not be set if the stream being uploaded has\n *     not yet finished chunking. In this case the `total` will be undefined\n *     until the total stream size is known.\n *   @note This event will not be emitted in Node.js 0.8.x.\n *   @param progress [map] An object containing the `loaded` and `total` bytes\n *     of the request and the `key` of the S3 object. Note that `total` may be undefined until the payload\n *     size is known.\n *   @context (see AWS.Request~send)\n */\n\nAWS.S3.ManagedUpload = AWS.util.inherit({\n  /**\n   * Creates a managed upload object with a set of configuration options.\n   *\n   * @note A \"Body\" parameter is required to be set prior to calling {send}.\n   * @note In Node.js, sending \"Body\" as {https://nodejs.org/dist/latest/docs/api/stream.html#stream_object_mode object-mode stream}\n   *   may result in upload hangs. Using buffer stream is preferable.\n   * @option options params [map] a map of parameters to pass to the upload\n   *   requests. The \"Body\" parameter is required to be specified either on\n   *   the service or in the params option.\n   * @note ContentMD5 should not be provided when using the managed upload object.\n   *   Instead, setting \"computeChecksums\" to true will enable automatic ContentMD5 generation\n   *   by the managed upload object.\n   * @option options queueSize [Number] (4) the size of the concurrent queue\n   *   manager to upload parts in parallel. Set to 1 for synchronous uploading\n   *   of parts. Note that the uploader will buffer at most queueSize * partSize\n   *   bytes into memory at any given time.\n   * @option options partSize [Number] (5mb) the size in bytes for each\n   *   individual part to be uploaded. Adjust the part size to ensure the number\n   *   of parts does not exceed {maxTotalParts}. See {minPartSize} for the\n   *   minimum allowed part size.\n   * @option options leavePartsOnError [Boolean] (false) whether to abort the\n   *   multipart upload if an error occurs. Set to true if you want to handle\n   *   failures manually.\n   * @option options service [AWS.S3] an optional S3 service object to use for\n   *   requests. This object might have bound parameters used by the uploader.\n   * @option options tags [Array<map>] The tags to apply to the uploaded object.\n   *   Each tag should have a `Key` and `Value` keys.\n   * @example Creating a default uploader for a stream object\n   *   var upload = new AWS.S3.ManagedUpload({\n   *     params: {Bucket: 'bucket', Key: 'key', Body: stream}\n   *   });\n   * @example Creating an uploader with concurrency of 1 and partSize of 10mb\n   *   var upload = new AWS.S3.ManagedUpload({\n   *     partSize: 10 * 1024 * 1024, queueSize: 1,\n   *     params: {Bucket: 'bucket', Key: 'key', Body: stream}\n   *   });\n   * @example Creating an uploader with tags\n   *   var upload = new AWS.S3.ManagedUpload({\n   *     params: {Bucket: 'bucket', Key: 'key', Body: stream},\n   *     tags: [{Key: 'tag1', Value: 'value1'}, {Key: 'tag2', Value: 'value2'}]\n   *   });\n   * @see send\n   */\n  constructor: function ManagedUpload(options) {\n    var self = this;\n    AWS.SequentialExecutor.call(self);\n    self.body = null;\n    self.sliceFn = null;\n    self.callback = null;\n    self.parts = {};\n    self.completeInfo = [];\n\n    self.fillQueue = function () {\n      self.callback(new Error('Unsupported body payload ' + typeof self.body));\n    };\n\n    self.configure(options);\n  },\n\n  /**\n   * @api private\n   */\n  configure: function configure(options) {\n    options = options || {};\n    this.partSize = this.minPartSize;\n    if (options.queueSize) this.queueSize = options.queueSize;\n    if (options.partSize) this.partSize = options.partSize;\n    if (options.leavePartsOnError) this.leavePartsOnError = true;\n\n    if (options.tags) {\n      if (!Array.isArray(options.tags)) {\n        throw new Error('Tags must be specified as an array; ' + typeof options.tags + ' provided.');\n      }\n\n      this.tags = options.tags;\n    }\n\n    if (this.partSize < this.minPartSize) {\n      throw new Error('partSize must be greater than ' + this.minPartSize);\n    }\n\n    this.service = options.service;\n    this.bindServiceObject(options.params);\n    this.validateBody();\n    this.adjustTotalBytes();\n  },\n\n  /**\n   * @api private\n   */\n  leavePartsOnError: false,\n\n  /**\n   * @api private\n   */\n  queueSize: 4,\n\n  /**\n   * @api private\n   */\n  partSize: null,\n\n  /**\n   * @readonly\n   * @return [Number] the minimum number of bytes for an individual part\n   *   upload.\n   */\n  minPartSize: 1024 * 1024 * 5,\n\n  /**\n   * @readonly\n   * @return [Number] the maximum allowed number of parts in a multipart upload.\n   */\n  maxTotalParts: 10000,\n\n  /**\n   * Initiates the managed upload for the payload.\n   *\n   * @callback callback function(err, data)\n   *   @param err [Error] an error or null if no error occurred.\n   *   @param data [map] The response data from the successful upload:\n   *     * `Location` (String) the URL of the uploaded object\n   *     * `ETag` (String) the ETag of the uploaded object\n   *     * `Bucket` (String) the bucket to which the object was uploaded\n   *     * `Key` (String) the key to which the object was uploaded\n   * @example Sending a managed upload object\n   *   var params = {Bucket: 'bucket', Key: 'key', Body: stream};\n   *   var upload = new AWS.S3.ManagedUpload({params: params});\n   *   upload.send(function(err, data) {\n   *     console.log(err, data);\n   *   });\n   */\n  send: function (callback) {\n    var self = this;\n    self.failed = false;\n\n    self.callback = callback || function (err) {\n      if (err) throw err;\n    };\n\n    var runFill = true;\n\n    if (self.sliceFn) {\n      self.fillQueue = self.fillBuffer;\n    } else if (AWS.util.isNode()) {\n      var Stream = AWS.util.stream.Stream;\n\n      if (self.body instanceof Stream) {\n        runFill = false;\n        self.fillQueue = self.fillStream;\n        self.partBuffers = [];\n        self.body.on('error', function (err) {\n          self.cleanup(err);\n        }).on('readable', function () {\n          self.fillQueue();\n        }).on('end', function () {\n          self.isDoneChunking = true;\n          self.numParts = self.totalPartNumbers;\n          self.fillQueue.call(self);\n\n          if (self.isDoneChunking && self.totalPartNumbers >= 1 && self.doneParts === self.numParts) {\n            self.finishMultiPart();\n          }\n        });\n      }\n    }\n\n    if (runFill) self.fillQueue.call(self);\n  },\n\n  /**\n   * @!method  promise()\n   *   Returns a 'thenable' promise.\n   *\n   *   Two callbacks can be provided to the `then` method on the returned promise.\n   *   The first callback will be called if the promise is fulfilled, and the second\n   *   callback will be called if the promise is rejected.\n   *   @callback fulfilledCallback function(data)\n   *     Called if the promise is fulfilled.\n   *     @param data [map] The response data from the successful upload:\n   *       `Location` (String) the URL of the uploaded object\n   *       `ETag` (String) the ETag of the uploaded object\n   *       `Bucket` (String) the bucket to which the object was uploaded\n   *       `Key` (String) the key to which the object was uploaded\n   *   @callback rejectedCallback function(err)\n   *     Called if the promise is rejected.\n   *     @param err [Error] an error or null if no error occurred.\n   *   @return [Promise] A promise that represents the state of the upload request.\n   *   @example Sending an upload request using promises.\n   *     var upload = s3.upload({Bucket: 'bucket', Key: 'key', Body: stream});\n   *     var promise = upload.promise();\n   *     promise.then(function(data) { ... }, function(err) { ... });\n   */\n\n  /**\n   * Aborts a managed upload, including all concurrent upload requests.\n   * @note By default, calling this function will cleanup a multipart upload\n   *   if one was created. To leave the multipart upload around after aborting\n   *   a request, configure `leavePartsOnError` to `true` in the {constructor}.\n   * @note Calling {abort} in the browser environment will not abort any requests\n   *   that are already in flight. If a multipart upload was created, any parts\n   *   not yet uploaded will not be sent, and the multipart upload will be cleaned up.\n   * @example Aborting an upload\n   *   var params = {\n   *     Bucket: 'bucket', Key: 'key',\n   *     Body: Buffer.alloc(1024 * 1024 * 25) // 25MB payload\n   *   };\n   *   var upload = s3.upload(params);\n   *   upload.send(function (err, data) {\n   *     if (err) console.log(\"Error:\", err.code, err.message);\n   *     else console.log(data);\n   *   });\n   *\n   *   // abort request in 1 second\n   *   setTimeout(upload.abort.bind(upload), 1000);\n   */\n  abort: function () {\n    var self = this; //abort putObject request\n\n    if (self.isDoneChunking === true && self.totalPartNumbers === 1 && self.singlePart) {\n      self.singlePart.abort();\n    } else {\n      self.cleanup(AWS.util.error(new Error('Request aborted by user'), {\n        code: 'RequestAbortedError',\n        retryable: false\n      }));\n    }\n  },\n\n  /**\n   * @api private\n   */\n  validateBody: function validateBody() {\n    var self = this;\n    self.body = self.service.config.params.Body;\n\n    if (typeof self.body === 'string') {\n      self.body = AWS.util.buffer.toBuffer(self.body);\n    } else if (!self.body) {\n      throw new Error('params.Body is required');\n    }\n\n    self.sliceFn = AWS.util.arraySliceFn(self.body);\n  },\n\n  /**\n   * @api private\n   */\n  bindServiceObject: function bindServiceObject(params) {\n    params = params || {};\n    var self = this; // bind parameters to new service object\n\n    if (!self.service) {\n      self.service = new AWS.S3({\n        params: params\n      });\n    } else {\n      var service = self.service;\n      var config = AWS.util.copy(service.config);\n      config.signatureVersion = service.getSignatureVersion();\n      self.service = new service.constructor.__super__(config);\n      self.service.config.params = AWS.util.merge(self.service.config.params || {}, params);\n    }\n  },\n\n  /**\n   * @api private\n   */\n  adjustTotalBytes: function adjustTotalBytes() {\n    var self = this;\n\n    try {\n      // try to get totalBytes\n      self.totalBytes = byteLength(self.body);\n    } catch (e) {} // try to adjust partSize if we know payload length\n\n\n    if (self.totalBytes) {\n      var newPartSize = Math.ceil(self.totalBytes / self.maxTotalParts);\n      if (newPartSize > self.partSize) self.partSize = newPartSize;\n    } else {\n      self.totalBytes = undefined;\n    }\n  },\n\n  /**\n   * @api private\n   */\n  isDoneChunking: false,\n\n  /**\n   * @api private\n   */\n  partPos: 0,\n\n  /**\n   * @api private\n   */\n  totalChunkedBytes: 0,\n\n  /**\n   * @api private\n   */\n  totalUploadedBytes: 0,\n\n  /**\n   * @api private\n   */\n  totalBytes: undefined,\n\n  /**\n   * @api private\n   */\n  numParts: 0,\n\n  /**\n   * @api private\n   */\n  totalPartNumbers: 0,\n\n  /**\n   * @api private\n   */\n  activeParts: 0,\n\n  /**\n   * @api private\n   */\n  doneParts: 0,\n\n  /**\n   * @api private\n   */\n  parts: null,\n\n  /**\n   * @api private\n   */\n  completeInfo: null,\n\n  /**\n   * @api private\n   */\n  failed: false,\n\n  /**\n   * @api private\n   */\n  multipartReq: null,\n\n  /**\n   * @api private\n   */\n  partBuffers: null,\n\n  /**\n   * @api private\n   */\n  partBufferLength: 0,\n\n  /**\n   * @api private\n   */\n  fillBuffer: function fillBuffer() {\n    var self = this;\n    var bodyLen = byteLength(self.body);\n\n    if (bodyLen === 0) {\n      self.isDoneChunking = true;\n      self.numParts = 1;\n      self.nextChunk(self.body);\n      return;\n    }\n\n    while (self.activeParts < self.queueSize && self.partPos < bodyLen) {\n      var endPos = Math.min(self.partPos + self.partSize, bodyLen);\n      var buf = self.sliceFn.call(self.body, self.partPos, endPos);\n      self.partPos += self.partSize;\n\n      if (byteLength(buf) < self.partSize || self.partPos === bodyLen) {\n        self.isDoneChunking = true;\n        self.numParts = self.totalPartNumbers + 1;\n      }\n\n      self.nextChunk(buf);\n    }\n  },\n\n  /**\n   * @api private\n   */\n  fillStream: function fillStream() {\n    var self = this;\n    if (self.activeParts >= self.queueSize) return;\n    var buf = self.body.read(self.partSize - self.partBufferLength) || self.body.read();\n\n    if (buf) {\n      self.partBuffers.push(buf);\n      self.partBufferLength += buf.length;\n      self.totalChunkedBytes += buf.length;\n    }\n\n    if (self.partBufferLength >= self.partSize) {\n      // if we have single buffer we avoid copyfull concat\n      var pbuf = self.partBuffers.length === 1 ? self.partBuffers[0] : Buffer.concat(self.partBuffers);\n      self.partBuffers = [];\n      self.partBufferLength = 0; // if we have more than partSize, push the rest back on the queue\n\n      if (pbuf.length > self.partSize) {\n        var rest = pbuf.slice(self.partSize);\n        self.partBuffers.push(rest);\n        self.partBufferLength += rest.length;\n        pbuf = pbuf.slice(0, self.partSize);\n      }\n\n      self.nextChunk(pbuf);\n    }\n\n    if (self.isDoneChunking && !self.isDoneSending) {\n      // if we have single buffer we avoid copyfull concat\n      pbuf = self.partBuffers.length === 1 ? self.partBuffers[0] : Buffer.concat(self.partBuffers);\n      self.partBuffers = [];\n      self.partBufferLength = 0;\n      self.totalBytes = self.totalChunkedBytes;\n      self.isDoneSending = true;\n\n      if (self.numParts === 0 || pbuf.length > 0) {\n        self.numParts++;\n        self.nextChunk(pbuf);\n      }\n    }\n\n    self.body.read(0);\n  },\n\n  /**\n   * @api private\n   */\n  nextChunk: function nextChunk(chunk) {\n    var self = this;\n    if (self.failed) return null;\n    var partNumber = ++self.totalPartNumbers;\n\n    if (self.isDoneChunking && partNumber === 1) {\n      var params = {\n        Body: chunk\n      };\n\n      if (this.tags) {\n        params.Tagging = this.getTaggingHeader();\n      }\n\n      var req = self.service.putObject(params);\n      req._managedUpload = self;\n      req.on('httpUploadProgress', self.progress).send(self.finishSinglePart);\n      self.singlePart = req; //save the single part request\n\n      return null;\n    } else if (self.service.config.params.ContentMD5) {\n      var err = AWS.util.error(new Error('The Content-MD5 you specified is invalid for multi-part uploads.'), {\n        code: 'InvalidDigest',\n        retryable: false\n      });\n      self.cleanup(err);\n      return null;\n    }\n\n    if (self.completeInfo[partNumber] && self.completeInfo[partNumber].ETag !== null) {\n      return null; // Already uploaded this part.\n    }\n\n    self.activeParts++;\n\n    if (!self.service.config.params.UploadId) {\n      if (!self.multipartReq) {\n        // create multipart\n        self.multipartReq = self.service.createMultipartUpload();\n        self.multipartReq.on('success', function (resp) {\n          self.service.config.params.UploadId = resp.data.UploadId;\n          self.multipartReq = null;\n        });\n        self.queueChunks(chunk, partNumber);\n        self.multipartReq.on('error', function (err) {\n          self.cleanup(err);\n        });\n        self.multipartReq.send();\n      } else {\n        self.queueChunks(chunk, partNumber);\n      }\n    } else {\n      // multipart is created, just send\n      self.uploadPart(chunk, partNumber);\n    }\n  },\n\n  /**\n   * @api private\n   */\n  getTaggingHeader: function getTaggingHeader() {\n    var kvPairStrings = [];\n\n    for (var i = 0; i < this.tags.length; i++) {\n      kvPairStrings.push(AWS.util.uriEscape(this.tags[i].Key) + '=' + AWS.util.uriEscape(this.tags[i].Value));\n    }\n\n    return kvPairStrings.join('&');\n  },\n\n  /**\n   * @api private\n   */\n  uploadPart: function uploadPart(chunk, partNumber) {\n    var self = this;\n    var partParams = {\n      Body: chunk,\n      ContentLength: AWS.util.string.byteLength(chunk),\n      PartNumber: partNumber\n    };\n    var partInfo = {\n      ETag: null,\n      PartNumber: partNumber\n    };\n    self.completeInfo[partNumber] = partInfo;\n    var req = self.service.uploadPart(partParams);\n    self.parts[partNumber] = req;\n    req._lastUploadedBytes = 0;\n    req._managedUpload = self;\n    req.on('httpUploadProgress', self.progress);\n    req.send(function (err, data) {\n      delete self.parts[partParams.PartNumber];\n      self.activeParts--;\n\n      if (!err && (!data || !data.ETag)) {\n        var message = 'No access to ETag property on response.';\n\n        if (AWS.util.isBrowser()) {\n          message += ' Check CORS configuration to expose ETag header.';\n        }\n\n        err = AWS.util.error(new Error(message), {\n          code: 'ETagMissing',\n          retryable: false\n        });\n      }\n\n      if (err) return self.cleanup(err); //prevent sending part being returned twice (https://github.com/aws/aws-sdk-js/issues/2304)\n\n      if (self.completeInfo[partNumber] && self.completeInfo[partNumber].ETag !== null) return null;\n      partInfo.ETag = data.ETag;\n      self.doneParts++;\n\n      if (self.isDoneChunking && self.doneParts === self.numParts) {\n        self.finishMultiPart();\n      } else {\n        self.fillQueue.call(self);\n      }\n    });\n  },\n\n  /**\n   * @api private\n   */\n  queueChunks: function queueChunks(chunk, partNumber) {\n    var self = this;\n    self.multipartReq.on('success', function () {\n      self.uploadPart(chunk, partNumber);\n    });\n  },\n\n  /**\n   * @api private\n   */\n  cleanup: function cleanup(err) {\n    var self = this;\n    if (self.failed) return; // clean up stream\n\n    if (typeof self.body.removeAllListeners === 'function' && typeof self.body.resume === 'function') {\n      self.body.removeAllListeners('readable');\n      self.body.removeAllListeners('end');\n      self.body.resume();\n    } // cleanup multipartReq listeners\n\n\n    if (self.multipartReq) {\n      self.multipartReq.removeAllListeners('success');\n      self.multipartReq.removeAllListeners('error');\n      self.multipartReq.removeAllListeners('complete');\n      delete self.multipartReq;\n    }\n\n    if (self.service.config.params.UploadId && !self.leavePartsOnError) {\n      self.service.abortMultipartUpload().send();\n    } else if (self.leavePartsOnError) {\n      self.isDoneChunking = false;\n    }\n\n    AWS.util.each(self.parts, function (partNumber, part) {\n      part.removeAllListeners('complete');\n      part.abort();\n    });\n    self.activeParts = 0;\n    self.partPos = 0;\n    self.numParts = 0;\n    self.totalPartNumbers = 0;\n    self.parts = {};\n    self.failed = true;\n    self.callback(err);\n  },\n\n  /**\n   * @api private\n   */\n  finishMultiPart: function finishMultiPart() {\n    var self = this;\n    var completeParams = {\n      MultipartUpload: {\n        Parts: self.completeInfo.slice(1)\n      }\n    };\n    self.service.completeMultipartUpload(completeParams, function (err, data) {\n      if (err) {\n        return self.cleanup(err);\n      }\n\n      if (data && typeof data.Location === 'string') {\n        data.Location = data.Location.replace(/%2F/g, '/');\n      }\n\n      if (Array.isArray(self.tags)) {\n        for (var i = 0; i < self.tags.length; i++) {\n          self.tags[i].Value = String(self.tags[i].Value);\n        }\n\n        self.service.putObjectTagging({\n          Tagging: {\n            TagSet: self.tags\n          }\n        }, function (e, d) {\n          if (e) {\n            self.callback(e);\n          } else {\n            self.callback(e, data);\n          }\n        });\n      } else {\n        self.callback(err, data);\n      }\n    });\n  },\n\n  /**\n   * @api private\n   */\n  finishSinglePart: function finishSinglePart(err, data) {\n    var upload = this.request._managedUpload;\n    var httpReq = this.request.httpRequest;\n    var endpoint = httpReq.endpoint;\n    if (err) return upload.callback(err);\n    data.Location = [endpoint.protocol, '//', endpoint.host, httpReq.path].join('');\n    data.key = this.request.params.Key; // will stay undocumented\n\n    data.Key = this.request.params.Key;\n    data.Bucket = this.request.params.Bucket;\n    upload.callback(err, data);\n  },\n\n  /**\n   * @api private\n   */\n  progress: function progress(info) {\n    var upload = this._managedUpload;\n\n    if (this.operation === 'putObject') {\n      info.part = 1;\n      info.key = this.params.Key;\n    } else {\n      upload.totalUploadedBytes += info.loaded - this._lastUploadedBytes;\n      this._lastUploadedBytes = info.loaded;\n      info = {\n        loaded: upload.totalUploadedBytes,\n        total: upload.totalBytes,\n        part: this.params.PartNumber,\n        key: this.params.Key\n      };\n    }\n\n    upload.emit('httpUploadProgress', [info]);\n  }\n});\nAWS.util.mixin(AWS.S3.ManagedUpload, AWS.SequentialExecutor);\n/**\n * @api private\n */\n\nAWS.S3.ManagedUpload.addPromisesToClass = function addPromisesToClass(PromiseDependency) {\n  this.prototype.promise = AWS.util.promisifyMethod('send', PromiseDependency);\n};\n/**\n * @api private\n */\n\n\nAWS.S3.ManagedUpload.deletePromisesFromClass = function deletePromisesFromClass() {\n  delete this.prototype.promise;\n};\n\nAWS.util.addPromises(AWS.S3.ManagedUpload);\n/**\n * @api private\n */\n\nmodule.exports = AWS.S3.ManagedUpload;","map":{"version":3,"names":["AWS","require","byteLength","util","string","Buffer","S3","ManagedUpload","inherit","constructor","options","self","SequentialExecutor","call","body","sliceFn","callback","parts","completeInfo","fillQueue","Error","configure","partSize","minPartSize","queueSize","leavePartsOnError","tags","Array","isArray","service","bindServiceObject","params","validateBody","adjustTotalBytes","maxTotalParts","send","failed","err","runFill","fillBuffer","isNode","Stream","stream","fillStream","partBuffers","on","cleanup","isDoneChunking","numParts","totalPartNumbers","doneParts","finishMultiPart","abort","singlePart","error","code","retryable","config","Body","buffer","toBuffer","arraySliceFn","copy","signatureVersion","getSignatureVersion","__super__","merge","totalBytes","e","newPartSize","Math","ceil","undefined","partPos","totalChunkedBytes","totalUploadedBytes","activeParts","multipartReq","partBufferLength","bodyLen","nextChunk","endPos","min","buf","read","push","length","pbuf","concat","rest","slice","isDoneSending","chunk","partNumber","Tagging","getTaggingHeader","req","putObject","_managedUpload","progress","finishSinglePart","ContentMD5","ETag","UploadId","createMultipartUpload","resp","data","queueChunks","uploadPart","kvPairStrings","i","uriEscape","Key","Value","join","partParams","ContentLength","PartNumber","partInfo","_lastUploadedBytes","message","isBrowser","removeAllListeners","resume","abortMultipartUpload","each","part","completeParams","MultipartUpload","Parts","completeMultipartUpload","Location","replace","String","putObjectTagging","TagSet","d","upload","request","httpReq","httpRequest","endpoint","protocol","host","path","key","Bucket","info","operation","loaded","total","emit","mixin","addPromisesToClass","PromiseDependency","prototype","promise","promisifyMethod","deletePromisesFromClass","addPromises","module","exports"],"sources":["/Users/roaldmaravillas/ro/sandbox/aws-mobile-appsync-events-starter-react/node_modules/aws-sdk/lib/s3/managed_upload.js"],"sourcesContent":["var AWS = require('../core');\nvar byteLength = AWS.util.string.byteLength;\nvar Buffer = AWS.util.Buffer;\n\n/**\n * The managed uploader allows for easy and efficient uploading of buffers,\n * blobs, or streams, using a configurable amount of concurrency to perform\n * multipart uploads where possible. This abstraction also enables uploading\n * streams of unknown size due to the use of multipart uploads.\n *\n * To construct a managed upload object, see the {constructor} function.\n *\n * ## Tracking upload progress\n *\n * The managed upload object can also track progress by attaching an\n * 'httpUploadProgress' listener to the upload manager. This event is similar\n * to {AWS.Request~httpUploadProgress} but groups all concurrent upload progress\n * into a single event. See {AWS.S3.ManagedUpload~httpUploadProgress} for more\n * information.\n *\n * ## Handling Multipart Cleanup\n *\n * By default, this class will automatically clean up any multipart uploads\n * when an individual part upload fails. This behavior can be disabled in order\n * to manually handle failures by setting the `leavePartsOnError` configuration\n * option to `true` when initializing the upload object.\n *\n * @!event httpUploadProgress(progress)\n *   Triggered when the uploader has uploaded more data.\n *   @note The `total` property may not be set if the stream being uploaded has\n *     not yet finished chunking. In this case the `total` will be undefined\n *     until the total stream size is known.\n *   @note This event will not be emitted in Node.js 0.8.x.\n *   @param progress [map] An object containing the `loaded` and `total` bytes\n *     of the request and the `key` of the S3 object. Note that `total` may be undefined until the payload\n *     size is known.\n *   @context (see AWS.Request~send)\n */\nAWS.S3.ManagedUpload = AWS.util.inherit({\n  /**\n   * Creates a managed upload object with a set of configuration options.\n   *\n   * @note A \"Body\" parameter is required to be set prior to calling {send}.\n   * @note In Node.js, sending \"Body\" as {https://nodejs.org/dist/latest/docs/api/stream.html#stream_object_mode object-mode stream}\n   *   may result in upload hangs. Using buffer stream is preferable.\n   * @option options params [map] a map of parameters to pass to the upload\n   *   requests. The \"Body\" parameter is required to be specified either on\n   *   the service or in the params option.\n   * @note ContentMD5 should not be provided when using the managed upload object.\n   *   Instead, setting \"computeChecksums\" to true will enable automatic ContentMD5 generation\n   *   by the managed upload object.\n   * @option options queueSize [Number] (4) the size of the concurrent queue\n   *   manager to upload parts in parallel. Set to 1 for synchronous uploading\n   *   of parts. Note that the uploader will buffer at most queueSize * partSize\n   *   bytes into memory at any given time.\n   * @option options partSize [Number] (5mb) the size in bytes for each\n   *   individual part to be uploaded. Adjust the part size to ensure the number\n   *   of parts does not exceed {maxTotalParts}. See {minPartSize} for the\n   *   minimum allowed part size.\n   * @option options leavePartsOnError [Boolean] (false) whether to abort the\n   *   multipart upload if an error occurs. Set to true if you want to handle\n   *   failures manually.\n   * @option options service [AWS.S3] an optional S3 service object to use for\n   *   requests. This object might have bound parameters used by the uploader.\n   * @option options tags [Array<map>] The tags to apply to the uploaded object.\n   *   Each tag should have a `Key` and `Value` keys.\n   * @example Creating a default uploader for a stream object\n   *   var upload = new AWS.S3.ManagedUpload({\n   *     params: {Bucket: 'bucket', Key: 'key', Body: stream}\n   *   });\n   * @example Creating an uploader with concurrency of 1 and partSize of 10mb\n   *   var upload = new AWS.S3.ManagedUpload({\n   *     partSize: 10 * 1024 * 1024, queueSize: 1,\n   *     params: {Bucket: 'bucket', Key: 'key', Body: stream}\n   *   });\n   * @example Creating an uploader with tags\n   *   var upload = new AWS.S3.ManagedUpload({\n   *     params: {Bucket: 'bucket', Key: 'key', Body: stream},\n   *     tags: [{Key: 'tag1', Value: 'value1'}, {Key: 'tag2', Value: 'value2'}]\n   *   });\n   * @see send\n   */\n  constructor: function ManagedUpload(options) {\n    var self = this;\n    AWS.SequentialExecutor.call(self);\n    self.body = null;\n    self.sliceFn = null;\n    self.callback = null;\n    self.parts = {};\n    self.completeInfo = [];\n    self.fillQueue = function() {\n      self.callback(new Error('Unsupported body payload ' + typeof self.body));\n    };\n\n    self.configure(options);\n  },\n\n  /**\n   * @api private\n   */\n  configure: function configure(options) {\n    options = options || {};\n    this.partSize = this.minPartSize;\n\n    if (options.queueSize) this.queueSize = options.queueSize;\n    if (options.partSize) this.partSize = options.partSize;\n    if (options.leavePartsOnError) this.leavePartsOnError = true;\n    if (options.tags) {\n      if (!Array.isArray(options.tags)) {\n        throw new Error('Tags must be specified as an array; ' +\n          typeof options.tags + ' provided.');\n      }\n      this.tags = options.tags;\n    }\n\n    if (this.partSize < this.minPartSize) {\n      throw new Error('partSize must be greater than ' +\n                      this.minPartSize);\n    }\n\n    this.service = options.service;\n    this.bindServiceObject(options.params);\n    this.validateBody();\n    this.adjustTotalBytes();\n  },\n\n  /**\n   * @api private\n   */\n  leavePartsOnError: false,\n\n  /**\n   * @api private\n   */\n  queueSize: 4,\n\n  /**\n   * @api private\n   */\n  partSize: null,\n\n  /**\n   * @readonly\n   * @return [Number] the minimum number of bytes for an individual part\n   *   upload.\n   */\n  minPartSize: 1024 * 1024 * 5,\n\n  /**\n   * @readonly\n   * @return [Number] the maximum allowed number of parts in a multipart upload.\n   */\n  maxTotalParts: 10000,\n\n  /**\n   * Initiates the managed upload for the payload.\n   *\n   * @callback callback function(err, data)\n   *   @param err [Error] an error or null if no error occurred.\n   *   @param data [map] The response data from the successful upload:\n   *     * `Location` (String) the URL of the uploaded object\n   *     * `ETag` (String) the ETag of the uploaded object\n   *     * `Bucket` (String) the bucket to which the object was uploaded\n   *     * `Key` (String) the key to which the object was uploaded\n   * @example Sending a managed upload object\n   *   var params = {Bucket: 'bucket', Key: 'key', Body: stream};\n   *   var upload = new AWS.S3.ManagedUpload({params: params});\n   *   upload.send(function(err, data) {\n   *     console.log(err, data);\n   *   });\n   */\n  send: function(callback) {\n    var self = this;\n    self.failed = false;\n    self.callback = callback || function(err) { if (err) throw err; };\n\n    var runFill = true;\n    if (self.sliceFn) {\n      self.fillQueue = self.fillBuffer;\n    } else if (AWS.util.isNode()) {\n      var Stream = AWS.util.stream.Stream;\n      if (self.body instanceof Stream) {\n        runFill = false;\n        self.fillQueue = self.fillStream;\n        self.partBuffers = [];\n        self.body.\n          on('error', function(err) { self.cleanup(err); }).\n          on('readable', function() { self.fillQueue(); }).\n          on('end', function() {\n            self.isDoneChunking = true;\n            self.numParts = self.totalPartNumbers;\n            self.fillQueue.call(self);\n\n            if (self.isDoneChunking && self.totalPartNumbers >= 1 && self.doneParts === self.numParts) {\n              self.finishMultiPart();\n            }\n          });\n      }\n    }\n\n    if (runFill) self.fillQueue.call(self);\n  },\n\n  /**\n   * @!method  promise()\n   *   Returns a 'thenable' promise.\n   *\n   *   Two callbacks can be provided to the `then` method on the returned promise.\n   *   The first callback will be called if the promise is fulfilled, and the second\n   *   callback will be called if the promise is rejected.\n   *   @callback fulfilledCallback function(data)\n   *     Called if the promise is fulfilled.\n   *     @param data [map] The response data from the successful upload:\n   *       `Location` (String) the URL of the uploaded object\n   *       `ETag` (String) the ETag of the uploaded object\n   *       `Bucket` (String) the bucket to which the object was uploaded\n   *       `Key` (String) the key to which the object was uploaded\n   *   @callback rejectedCallback function(err)\n   *     Called if the promise is rejected.\n   *     @param err [Error] an error or null if no error occurred.\n   *   @return [Promise] A promise that represents the state of the upload request.\n   *   @example Sending an upload request using promises.\n   *     var upload = s3.upload({Bucket: 'bucket', Key: 'key', Body: stream});\n   *     var promise = upload.promise();\n   *     promise.then(function(data) { ... }, function(err) { ... });\n   */\n\n  /**\n   * Aborts a managed upload, including all concurrent upload requests.\n   * @note By default, calling this function will cleanup a multipart upload\n   *   if one was created. To leave the multipart upload around after aborting\n   *   a request, configure `leavePartsOnError` to `true` in the {constructor}.\n   * @note Calling {abort} in the browser environment will not abort any requests\n   *   that are already in flight. If a multipart upload was created, any parts\n   *   not yet uploaded will not be sent, and the multipart upload will be cleaned up.\n   * @example Aborting an upload\n   *   var params = {\n   *     Bucket: 'bucket', Key: 'key',\n   *     Body: Buffer.alloc(1024 * 1024 * 25) // 25MB payload\n   *   };\n   *   var upload = s3.upload(params);\n   *   upload.send(function (err, data) {\n   *     if (err) console.log(\"Error:\", err.code, err.message);\n   *     else console.log(data);\n   *   });\n   *\n   *   // abort request in 1 second\n   *   setTimeout(upload.abort.bind(upload), 1000);\n   */\n  abort: function() {\n    var self = this;\n    //abort putObject request\n    if (self.isDoneChunking === true && self.totalPartNumbers === 1 && self.singlePart) {\n      self.singlePart.abort();\n    } else {\n      self.cleanup(AWS.util.error(new Error('Request aborted by user'), {\n        code: 'RequestAbortedError', retryable: false\n      }));\n    }\n  },\n\n  /**\n   * @api private\n   */\n  validateBody: function validateBody() {\n    var self = this;\n    self.body = self.service.config.params.Body;\n    if (typeof self.body === 'string') {\n      self.body = AWS.util.buffer.toBuffer(self.body);\n    } else if (!self.body) {\n      throw new Error('params.Body is required');\n    }\n    self.sliceFn = AWS.util.arraySliceFn(self.body);\n  },\n\n  /**\n   * @api private\n   */\n  bindServiceObject: function bindServiceObject(params) {\n    params = params || {};\n    var self = this;\n    // bind parameters to new service object\n    if (!self.service) {\n      self.service = new AWS.S3({params: params});\n    } else {\n      var service = self.service;\n      var config = AWS.util.copy(service.config);\n      config.signatureVersion = service.getSignatureVersion();\n      self.service = new service.constructor.__super__(config);\n      self.service.config.params =\n        AWS.util.merge(self.service.config.params || {}, params);\n    }\n  },\n\n  /**\n   * @api private\n   */\n  adjustTotalBytes: function adjustTotalBytes() {\n    var self = this;\n    try { // try to get totalBytes\n      self.totalBytes = byteLength(self.body);\n    } catch (e) { }\n\n    // try to adjust partSize if we know payload length\n    if (self.totalBytes) {\n      var newPartSize = Math.ceil(self.totalBytes / self.maxTotalParts);\n      if (newPartSize > self.partSize) self.partSize = newPartSize;\n    } else {\n      self.totalBytes = undefined;\n    }\n  },\n\n  /**\n   * @api private\n   */\n  isDoneChunking: false,\n\n  /**\n   * @api private\n   */\n  partPos: 0,\n\n  /**\n   * @api private\n   */\n  totalChunkedBytes: 0,\n\n  /**\n   * @api private\n   */\n  totalUploadedBytes: 0,\n\n  /**\n   * @api private\n   */\n  totalBytes: undefined,\n\n  /**\n   * @api private\n   */\n  numParts: 0,\n\n  /**\n   * @api private\n   */\n  totalPartNumbers: 0,\n\n  /**\n   * @api private\n   */\n  activeParts: 0,\n\n  /**\n   * @api private\n   */\n  doneParts: 0,\n\n  /**\n   * @api private\n   */\n  parts: null,\n\n  /**\n   * @api private\n   */\n  completeInfo: null,\n\n  /**\n   * @api private\n   */\n  failed: false,\n\n  /**\n   * @api private\n   */\n  multipartReq: null,\n\n  /**\n   * @api private\n   */\n  partBuffers: null,\n\n  /**\n   * @api private\n   */\n  partBufferLength: 0,\n\n  /**\n   * @api private\n   */\n  fillBuffer: function fillBuffer() {\n    var self = this;\n    var bodyLen = byteLength(self.body);\n\n    if (bodyLen === 0) {\n      self.isDoneChunking = true;\n      self.numParts = 1;\n      self.nextChunk(self.body);\n      return;\n    }\n\n    while (self.activeParts < self.queueSize && self.partPos < bodyLen) {\n      var endPos = Math.min(self.partPos + self.partSize, bodyLen);\n      var buf = self.sliceFn.call(self.body, self.partPos, endPos);\n      self.partPos += self.partSize;\n\n      if (byteLength(buf) < self.partSize || self.partPos === bodyLen) {\n        self.isDoneChunking = true;\n        self.numParts = self.totalPartNumbers + 1;\n      }\n      self.nextChunk(buf);\n    }\n  },\n\n  /**\n   * @api private\n   */\n  fillStream: function fillStream() {\n    var self = this;\n    if (self.activeParts >= self.queueSize) return;\n\n    var buf = self.body.read(self.partSize - self.partBufferLength) ||\n              self.body.read();\n    if (buf) {\n      self.partBuffers.push(buf);\n      self.partBufferLength += buf.length;\n      self.totalChunkedBytes += buf.length;\n    }\n\n    if (self.partBufferLength >= self.partSize) {\n      // if we have single buffer we avoid copyfull concat\n      var pbuf = self.partBuffers.length === 1 ?\n        self.partBuffers[0] : Buffer.concat(self.partBuffers);\n      self.partBuffers = [];\n      self.partBufferLength = 0;\n\n      // if we have more than partSize, push the rest back on the queue\n      if (pbuf.length > self.partSize) {\n        var rest = pbuf.slice(self.partSize);\n        self.partBuffers.push(rest);\n        self.partBufferLength += rest.length;\n        pbuf = pbuf.slice(0, self.partSize);\n      }\n\n      self.nextChunk(pbuf);\n    }\n\n    if (self.isDoneChunking && !self.isDoneSending) {\n      // if we have single buffer we avoid copyfull concat\n      pbuf = self.partBuffers.length === 1 ?\n          self.partBuffers[0] : Buffer.concat(self.partBuffers);\n      self.partBuffers = [];\n      self.partBufferLength = 0;\n      self.totalBytes = self.totalChunkedBytes;\n      self.isDoneSending = true;\n\n      if (self.numParts === 0 || pbuf.length > 0) {\n        self.numParts++;\n        self.nextChunk(pbuf);\n      }\n    }\n\n    self.body.read(0);\n  },\n\n  /**\n   * @api private\n   */\n  nextChunk: function nextChunk(chunk) {\n    var self = this;\n    if (self.failed) return null;\n\n    var partNumber = ++self.totalPartNumbers;\n    if (self.isDoneChunking && partNumber === 1) {\n      var params = {Body: chunk};\n      if (this.tags) {\n        params.Tagging = this.getTaggingHeader();\n      }\n      var req = self.service.putObject(params);\n      req._managedUpload = self;\n      req.on('httpUploadProgress', self.progress).send(self.finishSinglePart);\n      self.singlePart = req; //save the single part request\n      return null;\n    } else if (self.service.config.params.ContentMD5) {\n      var err = AWS.util.error(new Error('The Content-MD5 you specified is invalid for multi-part uploads.'), {\n        code: 'InvalidDigest', retryable: false\n      });\n\n      self.cleanup(err);\n      return null;\n    }\n\n    if (self.completeInfo[partNumber] && self.completeInfo[partNumber].ETag !== null) {\n      return null; // Already uploaded this part.\n    }\n\n    self.activeParts++;\n    if (!self.service.config.params.UploadId) {\n\n      if (!self.multipartReq) { // create multipart\n        self.multipartReq = self.service.createMultipartUpload();\n        self.multipartReq.on('success', function(resp) {\n          self.service.config.params.UploadId = resp.data.UploadId;\n          self.multipartReq = null;\n        });\n        self.queueChunks(chunk, partNumber);\n        self.multipartReq.on('error', function(err) {\n          self.cleanup(err);\n        });\n        self.multipartReq.send();\n      } else {\n        self.queueChunks(chunk, partNumber);\n      }\n    } else { // multipart is created, just send\n      self.uploadPart(chunk, partNumber);\n    }\n  },\n\n  /**\n   * @api private\n   */\n  getTaggingHeader: function getTaggingHeader() {\n    var kvPairStrings = [];\n    for (var i = 0; i < this.tags.length; i++) {\n      kvPairStrings.push(AWS.util.uriEscape(this.tags[i].Key) + '=' +\n        AWS.util.uriEscape(this.tags[i].Value));\n    }\n\n    return kvPairStrings.join('&');\n  },\n\n  /**\n   * @api private\n   */\n  uploadPart: function uploadPart(chunk, partNumber) {\n    var self = this;\n\n    var partParams = {\n      Body: chunk,\n      ContentLength: AWS.util.string.byteLength(chunk),\n      PartNumber: partNumber\n    };\n\n    var partInfo = {ETag: null, PartNumber: partNumber};\n    self.completeInfo[partNumber] = partInfo;\n\n    var req = self.service.uploadPart(partParams);\n    self.parts[partNumber] = req;\n    req._lastUploadedBytes = 0;\n    req._managedUpload = self;\n    req.on('httpUploadProgress', self.progress);\n    req.send(function(err, data) {\n      delete self.parts[partParams.PartNumber];\n      self.activeParts--;\n\n      if (!err && (!data || !data.ETag)) {\n        var message = 'No access to ETag property on response.';\n        if (AWS.util.isBrowser()) {\n          message += ' Check CORS configuration to expose ETag header.';\n        }\n\n        err = AWS.util.error(new Error(message), {\n          code: 'ETagMissing', retryable: false\n        });\n      }\n      if (err) return self.cleanup(err);\n      //prevent sending part being returned twice (https://github.com/aws/aws-sdk-js/issues/2304)\n      if (self.completeInfo[partNumber] && self.completeInfo[partNumber].ETag !== null) return null;\n      partInfo.ETag = data.ETag;\n      self.doneParts++;\n      if (self.isDoneChunking && self.doneParts === self.numParts) {\n        self.finishMultiPart();\n      } else {\n        self.fillQueue.call(self);\n      }\n    });\n  },\n\n  /**\n   * @api private\n   */\n  queueChunks: function queueChunks(chunk, partNumber) {\n    var self = this;\n    self.multipartReq.on('success', function() {\n      self.uploadPart(chunk, partNumber);\n    });\n  },\n\n  /**\n   * @api private\n   */\n  cleanup: function cleanup(err) {\n    var self = this;\n    if (self.failed) return;\n\n    // clean up stream\n    if (typeof self.body.removeAllListeners === 'function' &&\n        typeof self.body.resume === 'function') {\n      self.body.removeAllListeners('readable');\n      self.body.removeAllListeners('end');\n      self.body.resume();\n    }\n\n    // cleanup multipartReq listeners\n    if (self.multipartReq) {\n      self.multipartReq.removeAllListeners('success');\n      self.multipartReq.removeAllListeners('error');\n      self.multipartReq.removeAllListeners('complete');\n      delete self.multipartReq;\n    }\n\n    if (self.service.config.params.UploadId && !self.leavePartsOnError) {\n      self.service.abortMultipartUpload().send();\n    } else if (self.leavePartsOnError) {\n      self.isDoneChunking = false;\n    }\n\n    AWS.util.each(self.parts, function(partNumber, part) {\n      part.removeAllListeners('complete');\n      part.abort();\n    });\n\n    self.activeParts = 0;\n    self.partPos = 0;\n    self.numParts = 0;\n    self.totalPartNumbers = 0;\n    self.parts = {};\n    self.failed = true;\n    self.callback(err);\n  },\n\n  /**\n   * @api private\n   */\n  finishMultiPart: function finishMultiPart() {\n    var self = this;\n    var completeParams = { MultipartUpload: { Parts: self.completeInfo.slice(1) } };\n    self.service.completeMultipartUpload(completeParams, function(err, data) {\n      if (err) {\n        return self.cleanup(err);\n      }\n\n      if (data && typeof data.Location === 'string') {\n        data.Location = data.Location.replace(/%2F/g, '/');\n      }\n\n      if (Array.isArray(self.tags)) {\n        for (var i = 0; i < self.tags.length; i++) {\n          self.tags[i].Value = String(self.tags[i].Value);\n        }\n        self.service.putObjectTagging(\n          {Tagging: {TagSet: self.tags}},\n          function(e, d) {\n            if (e) {\n              self.callback(e);\n            } else {\n              self.callback(e, data);\n            }\n          }\n        );\n      } else {\n        self.callback(err, data);\n      }\n    });\n  },\n\n  /**\n   * @api private\n   */\n  finishSinglePart: function finishSinglePart(err, data) {\n    var upload = this.request._managedUpload;\n    var httpReq = this.request.httpRequest;\n    var endpoint = httpReq.endpoint;\n    if (err) return upload.callback(err);\n    data.Location =\n      [endpoint.protocol, '//', endpoint.host, httpReq.path].join('');\n    data.key = this.request.params.Key; // will stay undocumented\n    data.Key = this.request.params.Key;\n    data.Bucket = this.request.params.Bucket;\n    upload.callback(err, data);\n  },\n\n  /**\n   * @api private\n   */\n  progress: function progress(info) {\n    var upload = this._managedUpload;\n    if (this.operation === 'putObject') {\n      info.part = 1;\n      info.key = this.params.Key;\n    } else {\n      upload.totalUploadedBytes += info.loaded - this._lastUploadedBytes;\n      this._lastUploadedBytes = info.loaded;\n      info = {\n        loaded: upload.totalUploadedBytes,\n        total: upload.totalBytes,\n        part: this.params.PartNumber,\n        key: this.params.Key\n      };\n    }\n    upload.emit('httpUploadProgress', [info]);\n  }\n});\n\nAWS.util.mixin(AWS.S3.ManagedUpload, AWS.SequentialExecutor);\n\n/**\n * @api private\n */\nAWS.S3.ManagedUpload.addPromisesToClass = function addPromisesToClass(PromiseDependency) {\n  this.prototype.promise = AWS.util.promisifyMethod('send', PromiseDependency);\n};\n\n/**\n * @api private\n */\nAWS.S3.ManagedUpload.deletePromisesFromClass = function deletePromisesFromClass() {\n  delete this.prototype.promise;\n};\n\nAWS.util.addPromises(AWS.S3.ManagedUpload);\n\n/**\n * @api private\n */\nmodule.exports = AWS.S3.ManagedUpload;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}