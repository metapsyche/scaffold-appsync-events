{"ast":null,"code":"/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport invariant from '../jsutils/invariant';\nimport keyMap from '../jsutils/keyMap';\nimport keyValMap from '../jsutils/keyValMap';\nimport { valueFromAST } from './valueFromAST';\nimport { parseValue } from '../language/parser';\nimport { GraphQLSchema } from '../type/schema';\nimport { DirectiveLocation } from '../language/directiveLocation';\nimport { isInputType, isOutputType, GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, assertNullableType, assertObjectType, assertInterfaceType } from '../type/definition';\nimport { GraphQLList, GraphQLNonNull } from '../type/wrappers';\nimport { GraphQLDirective } from '../type/directives';\nimport { introspectionTypes, TypeKind } from '../type/introspection';\nimport { specifiedScalarTypes } from '../type/scalars';\n/**\n * Build a GraphQLSchema for use by client tools.\n *\n * Given the result of a client running the introspection query, creates and\n * returns a GraphQLSchema instance which can be then used with all graphql-js\n * tools, but cannot be used to execute a query, as introspection does not\n * represent the \"resolver\", \"parse\" or \"serialize\" functions or any other\n * server-internal mechanisms.\n *\n * This function expects a complete introspection result. Don't forget to check\n * the \"errors\" field of a server response before calling this function.\n */\n\nexport function buildClientSchema(introspection, options) {\n  // Get the schema from the introspection result.\n  var schemaIntrospection = introspection.__schema; // Converts the list of types into a keyMap based on the type names.\n\n  var typeIntrospectionMap = keyMap(schemaIntrospection.types, function (type) {\n    return type.name;\n  }); // A cache to use to store the actual GraphQLType definition objects by name.\n  // Initialize to the GraphQL built in scalars. All functions below are inline\n  // so that this type def cache is within the scope of the closure.\n\n  var typeDefCache = keyMap(specifiedScalarTypes.concat(introspectionTypes), function (type) {\n    return type.name;\n  }); // Given a type reference in introspection, return the GraphQLType instance.\n  // preferring cached instances before building new instances.\n\n  function getType(typeRef) {\n    if (typeRef.kind === TypeKind.LIST) {\n      var itemRef = typeRef.ofType;\n\n      if (!itemRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      return GraphQLList(getType(itemRef));\n    }\n\n    if (typeRef.kind === TypeKind.NON_NULL) {\n      var nullableRef = typeRef.ofType;\n\n      if (!nullableRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      var nullableType = getType(nullableRef);\n      return GraphQLNonNull(assertNullableType(nullableType));\n    }\n\n    if (!typeRef.name) {\n      throw new Error('Unknown type reference: ' + JSON.stringify(typeRef));\n    }\n\n    return getNamedType(typeRef.name);\n  }\n\n  function getNamedType(typeName) {\n    if (typeDefCache[typeName]) {\n      return typeDefCache[typeName];\n    }\n\n    var typeIntrospection = typeIntrospectionMap[typeName];\n\n    if (!typeIntrospection) {\n      throw new Error('Invalid or incomplete schema, unknown type: ' + typeName + '. Ensure ' + 'that a full introspection query is used in order to build a ' + 'client schema.');\n    }\n\n    var typeDef = buildType(typeIntrospection);\n    typeDefCache[typeName] = typeDef;\n    return typeDef;\n  }\n\n  function getInputType(typeRef) {\n    var type = getType(typeRef);\n    !isInputType(type) ? invariant(0, 'Introspection must provide input type for arguments.') : void 0;\n    return type;\n  }\n\n  function getOutputType(typeRef) {\n    var type = getType(typeRef);\n    !isOutputType(type) ? invariant(0, 'Introspection must provide output type for fields.') : void 0;\n    return type;\n  }\n\n  function getObjectType(typeRef) {\n    var type = getType(typeRef);\n    return assertObjectType(type);\n  }\n\n  function getInterfaceType(typeRef) {\n    var type = getType(typeRef);\n    return assertInterfaceType(type);\n  } // Given a type's introspection result, construct the correct\n  // GraphQLType instance.\n\n\n  function buildType(type) {\n    if (type && type.name && type.kind) {\n      switch (type.kind) {\n        case TypeKind.SCALAR:\n          return buildScalarDef(type);\n\n        case TypeKind.OBJECT:\n          return buildObjectDef(type);\n\n        case TypeKind.INTERFACE:\n          return buildInterfaceDef(type);\n\n        case TypeKind.UNION:\n          return buildUnionDef(type);\n\n        case TypeKind.ENUM:\n          return buildEnumDef(type);\n\n        case TypeKind.INPUT_OBJECT:\n          return buildInputObjectDef(type);\n      }\n    }\n\n    throw new Error('Invalid or incomplete introspection result. Ensure that a full ' + 'introspection query is used in order to build a client schema:' + JSON.stringify(type));\n  }\n\n  function buildScalarDef(scalarIntrospection) {\n    return new GraphQLScalarType({\n      name: scalarIntrospection.name,\n      description: scalarIntrospection.description,\n      serialize: function serialize(value) {\n        return value;\n      }\n    });\n  }\n\n  function buildObjectDef(objectIntrospection) {\n    if (!objectIntrospection.interfaces) {\n      throw new Error('Introspection result missing interfaces: ' + JSON.stringify(objectIntrospection));\n    }\n\n    return new GraphQLObjectType({\n      name: objectIntrospection.name,\n      description: objectIntrospection.description,\n      interfaces: objectIntrospection.interfaces.map(getInterfaceType),\n      fields: function fields() {\n        return buildFieldDefMap(objectIntrospection);\n      }\n    });\n  }\n\n  function buildInterfaceDef(interfaceIntrospection) {\n    return new GraphQLInterfaceType({\n      name: interfaceIntrospection.name,\n      description: interfaceIntrospection.description,\n      fields: function fields() {\n        return buildFieldDefMap(interfaceIntrospection);\n      }\n    });\n  }\n\n  function buildUnionDef(unionIntrospection) {\n    if (!unionIntrospection.possibleTypes) {\n      throw new Error('Introspection result missing possibleTypes: ' + JSON.stringify(unionIntrospection));\n    }\n\n    return new GraphQLUnionType({\n      name: unionIntrospection.name,\n      description: unionIntrospection.description,\n      types: unionIntrospection.possibleTypes.map(getObjectType)\n    });\n  }\n\n  function buildEnumDef(enumIntrospection) {\n    if (!enumIntrospection.enumValues) {\n      throw new Error('Introspection result missing enumValues: ' + JSON.stringify(enumIntrospection));\n    }\n\n    return new GraphQLEnumType({\n      name: enumIntrospection.name,\n      description: enumIntrospection.description,\n      values: keyValMap(enumIntrospection.enumValues, function (valueIntrospection) {\n        return valueIntrospection.name;\n      }, function (valueIntrospection) {\n        return {\n          description: valueIntrospection.description,\n          deprecationReason: valueIntrospection.deprecationReason\n        };\n      })\n    });\n  }\n\n  function buildInputObjectDef(inputObjectIntrospection) {\n    if (!inputObjectIntrospection.inputFields) {\n      throw new Error('Introspection result missing inputFields: ' + JSON.stringify(inputObjectIntrospection));\n    }\n\n    return new GraphQLInputObjectType({\n      name: inputObjectIntrospection.name,\n      description: inputObjectIntrospection.description,\n      fields: function fields() {\n        return buildInputValueDefMap(inputObjectIntrospection.inputFields);\n      }\n    });\n  }\n\n  function buildFieldDefMap(typeIntrospection) {\n    if (!typeIntrospection.fields) {\n      throw new Error('Introspection result missing fields: ' + JSON.stringify(typeIntrospection));\n    }\n\n    return keyValMap(typeIntrospection.fields, function (fieldIntrospection) {\n      return fieldIntrospection.name;\n    }, function (fieldIntrospection) {\n      if (!fieldIntrospection.args) {\n        throw new Error('Introspection result missing field args: ' + JSON.stringify(fieldIntrospection));\n      }\n\n      return {\n        description: fieldIntrospection.description,\n        deprecationReason: fieldIntrospection.deprecationReason,\n        type: getOutputType(fieldIntrospection.type),\n        args: buildInputValueDefMap(fieldIntrospection.args)\n      };\n    });\n  }\n\n  function buildInputValueDefMap(inputValueIntrospections) {\n    return keyValMap(inputValueIntrospections, function (inputValue) {\n      return inputValue.name;\n    }, buildInputValue);\n  }\n\n  function buildInputValue(inputValueIntrospection) {\n    var type = getInputType(inputValueIntrospection.type);\n    var defaultValue = inputValueIntrospection.defaultValue ? valueFromAST(parseValue(inputValueIntrospection.defaultValue), type) : undefined;\n    return {\n      name: inputValueIntrospection.name,\n      description: inputValueIntrospection.description,\n      type: type,\n      defaultValue: defaultValue\n    };\n  }\n\n  function buildDirective(directiveIntrospection) {\n    // Support deprecated `on****` fields for building `locations`, as this\n    // is used by GraphiQL which may need to support outdated servers.\n    var locations = directiveIntrospection.locations ? directiveIntrospection.locations.slice() : [].concat(!directiveIntrospection.onField ? [] : [DirectiveLocation.FIELD], !directiveIntrospection.onOperation ? [] : [DirectiveLocation.QUERY, DirectiveLocation.MUTATION, DirectiveLocation.SUBSCRIPTION], !directiveIntrospection.onFragment ? [] : [DirectiveLocation.FRAGMENT_DEFINITION, DirectiveLocation.FRAGMENT_SPREAD, DirectiveLocation.INLINE_FRAGMENT]);\n\n    if (!directiveIntrospection.args) {\n      throw new Error('Introspection result missing directive args: ' + JSON.stringify(directiveIntrospection));\n    }\n\n    return new GraphQLDirective({\n      name: directiveIntrospection.name,\n      description: directiveIntrospection.description,\n      locations: locations,\n      args: buildInputValueDefMap(directiveIntrospection.args)\n    });\n  } // Iterate through all types, getting the type definition for each, ensuring\n  // that any type not directly referenced by a field will get created.\n\n\n  var types = schemaIntrospection.types.map(function (typeIntrospection) {\n    return getNamedType(typeIntrospection.name);\n  }); // Get the root Query, Mutation, and Subscription types.\n\n  var queryType = schemaIntrospection.queryType ? getObjectType(schemaIntrospection.queryType) : null;\n  var mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;\n  var subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null; // Get the directives supported by Introspection, assuming empty-set if\n  // directives were not queried for.\n\n  var directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : []; // Then produce and return a Schema with these types.\n\n  return new GraphQLSchema({\n    query: queryType,\n    mutation: mutationType,\n    subscription: subscriptionType,\n    types: types,\n    directives: directives,\n    assumeValid: options && options.assumeValid\n  });\n}","map":{"version":3,"names":["invariant","keyMap","keyValMap","valueFromAST","parseValue","GraphQLSchema","DirectiveLocation","isInputType","isOutputType","GraphQLScalarType","GraphQLObjectType","GraphQLInterfaceType","GraphQLUnionType","GraphQLEnumType","GraphQLInputObjectType","assertNullableType","assertObjectType","assertInterfaceType","GraphQLList","GraphQLNonNull","GraphQLDirective","introspectionTypes","TypeKind","specifiedScalarTypes","buildClientSchema","introspection","options","schemaIntrospection","__schema","typeIntrospectionMap","types","type","name","typeDefCache","concat","getType","typeRef","kind","LIST","itemRef","ofType","Error","NON_NULL","nullableRef","nullableType","JSON","stringify","getNamedType","typeName","typeIntrospection","typeDef","buildType","getInputType","getOutputType","getObjectType","getInterfaceType","SCALAR","buildScalarDef","OBJECT","buildObjectDef","INTERFACE","buildInterfaceDef","UNION","buildUnionDef","ENUM","buildEnumDef","INPUT_OBJECT","buildInputObjectDef","scalarIntrospection","description","serialize","value","objectIntrospection","interfaces","map","fields","buildFieldDefMap","interfaceIntrospection","unionIntrospection","possibleTypes","enumIntrospection","enumValues","values","valueIntrospection","deprecationReason","inputObjectIntrospection","inputFields","buildInputValueDefMap","fieldIntrospection","args","inputValueIntrospections","inputValue","buildInputValue","inputValueIntrospection","defaultValue","undefined","buildDirective","directiveIntrospection","locations","slice","onField","FIELD","onOperation","QUERY","MUTATION","SUBSCRIPTION","onFragment","FRAGMENT_DEFINITION","FRAGMENT_SPREAD","INLINE_FRAGMENT","queryType","mutationType","subscriptionType","directives","query","mutation","subscription","assumeValid"],"sources":["/Users/roaldmaravillas/ro/github/scaffold-appsync-events/node_modules/aws-appsync/node_modules/graphql/module/utilities/buildClientSchema.js"],"sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nimport invariant from '../jsutils/invariant';\nimport keyMap from '../jsutils/keyMap';\nimport keyValMap from '../jsutils/keyValMap';\nimport { valueFromAST } from './valueFromAST';\nimport { parseValue } from '../language/parser';\nimport { GraphQLSchema } from '../type/schema';\n\nimport { DirectiveLocation } from '../language/directiveLocation';\n\nimport { isInputType, isOutputType, GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, assertNullableType, assertObjectType, assertInterfaceType } from '../type/definition';\n\nimport { GraphQLList, GraphQLNonNull } from '../type/wrappers';\n\nimport { GraphQLDirective } from '../type/directives';\n\nimport { introspectionTypes, TypeKind } from '../type/introspection';\n\nimport { specifiedScalarTypes } from '../type/scalars';\n\n/**\n * Build a GraphQLSchema for use by client tools.\n *\n * Given the result of a client running the introspection query, creates and\n * returns a GraphQLSchema instance which can be then used with all graphql-js\n * tools, but cannot be used to execute a query, as introspection does not\n * represent the \"resolver\", \"parse\" or \"serialize\" functions or any other\n * server-internal mechanisms.\n *\n * This function expects a complete introspection result. Don't forget to check\n * the \"errors\" field of a server response before calling this function.\n */\nexport function buildClientSchema(introspection, options) {\n  // Get the schema from the introspection result.\n  var schemaIntrospection = introspection.__schema;\n\n  // Converts the list of types into a keyMap based on the type names.\n  var typeIntrospectionMap = keyMap(schemaIntrospection.types, function (type) {\n    return type.name;\n  });\n\n  // A cache to use to store the actual GraphQLType definition objects by name.\n  // Initialize to the GraphQL built in scalars. All functions below are inline\n  // so that this type def cache is within the scope of the closure.\n  var typeDefCache = keyMap(specifiedScalarTypes.concat(introspectionTypes), function (type) {\n    return type.name;\n  });\n\n  // Given a type reference in introspection, return the GraphQLType instance.\n  // preferring cached instances before building new instances.\n  function getType(typeRef) {\n    if (typeRef.kind === TypeKind.LIST) {\n      var itemRef = typeRef.ofType;\n      if (!itemRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n      return GraphQLList(getType(itemRef));\n    }\n    if (typeRef.kind === TypeKind.NON_NULL) {\n      var nullableRef = typeRef.ofType;\n      if (!nullableRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n      var nullableType = getType(nullableRef);\n      return GraphQLNonNull(assertNullableType(nullableType));\n    }\n    if (!typeRef.name) {\n      throw new Error('Unknown type reference: ' + JSON.stringify(typeRef));\n    }\n    return getNamedType(typeRef.name);\n  }\n\n  function getNamedType(typeName) {\n    if (typeDefCache[typeName]) {\n      return typeDefCache[typeName];\n    }\n    var typeIntrospection = typeIntrospectionMap[typeName];\n    if (!typeIntrospection) {\n      throw new Error('Invalid or incomplete schema, unknown type: ' + typeName + '. Ensure ' + 'that a full introspection query is used in order to build a ' + 'client schema.');\n    }\n    var typeDef = buildType(typeIntrospection);\n    typeDefCache[typeName] = typeDef;\n    return typeDef;\n  }\n\n  function getInputType(typeRef) {\n    var type = getType(typeRef);\n    !isInputType(type) ? invariant(0, 'Introspection must provide input type for arguments.') : void 0;\n    return type;\n  }\n\n  function getOutputType(typeRef) {\n    var type = getType(typeRef);\n    !isOutputType(type) ? invariant(0, 'Introspection must provide output type for fields.') : void 0;\n    return type;\n  }\n\n  function getObjectType(typeRef) {\n    var type = getType(typeRef);\n    return assertObjectType(type);\n  }\n\n  function getInterfaceType(typeRef) {\n    var type = getType(typeRef);\n    return assertInterfaceType(type);\n  }\n\n  // Given a type's introspection result, construct the correct\n  // GraphQLType instance.\n  function buildType(type) {\n    if (type && type.name && type.kind) {\n      switch (type.kind) {\n        case TypeKind.SCALAR:\n          return buildScalarDef(type);\n        case TypeKind.OBJECT:\n          return buildObjectDef(type);\n        case TypeKind.INTERFACE:\n          return buildInterfaceDef(type);\n        case TypeKind.UNION:\n          return buildUnionDef(type);\n        case TypeKind.ENUM:\n          return buildEnumDef(type);\n        case TypeKind.INPUT_OBJECT:\n          return buildInputObjectDef(type);\n      }\n    }\n    throw new Error('Invalid or incomplete introspection result. Ensure that a full ' + 'introspection query is used in order to build a client schema:' + JSON.stringify(type));\n  }\n\n  function buildScalarDef(scalarIntrospection) {\n    return new GraphQLScalarType({\n      name: scalarIntrospection.name,\n      description: scalarIntrospection.description,\n      serialize: function serialize(value) {\n        return value;\n      }\n    });\n  }\n\n  function buildObjectDef(objectIntrospection) {\n    if (!objectIntrospection.interfaces) {\n      throw new Error('Introspection result missing interfaces: ' + JSON.stringify(objectIntrospection));\n    }\n    return new GraphQLObjectType({\n      name: objectIntrospection.name,\n      description: objectIntrospection.description,\n      interfaces: objectIntrospection.interfaces.map(getInterfaceType),\n      fields: function fields() {\n        return buildFieldDefMap(objectIntrospection);\n      }\n    });\n  }\n\n  function buildInterfaceDef(interfaceIntrospection) {\n    return new GraphQLInterfaceType({\n      name: interfaceIntrospection.name,\n      description: interfaceIntrospection.description,\n      fields: function fields() {\n        return buildFieldDefMap(interfaceIntrospection);\n      }\n    });\n  }\n\n  function buildUnionDef(unionIntrospection) {\n    if (!unionIntrospection.possibleTypes) {\n      throw new Error('Introspection result missing possibleTypes: ' + JSON.stringify(unionIntrospection));\n    }\n    return new GraphQLUnionType({\n      name: unionIntrospection.name,\n      description: unionIntrospection.description,\n      types: unionIntrospection.possibleTypes.map(getObjectType)\n    });\n  }\n\n  function buildEnumDef(enumIntrospection) {\n    if (!enumIntrospection.enumValues) {\n      throw new Error('Introspection result missing enumValues: ' + JSON.stringify(enumIntrospection));\n    }\n    return new GraphQLEnumType({\n      name: enumIntrospection.name,\n      description: enumIntrospection.description,\n      values: keyValMap(enumIntrospection.enumValues, function (valueIntrospection) {\n        return valueIntrospection.name;\n      }, function (valueIntrospection) {\n        return {\n          description: valueIntrospection.description,\n          deprecationReason: valueIntrospection.deprecationReason\n        };\n      })\n    });\n  }\n\n  function buildInputObjectDef(inputObjectIntrospection) {\n    if (!inputObjectIntrospection.inputFields) {\n      throw new Error('Introspection result missing inputFields: ' + JSON.stringify(inputObjectIntrospection));\n    }\n    return new GraphQLInputObjectType({\n      name: inputObjectIntrospection.name,\n      description: inputObjectIntrospection.description,\n      fields: function fields() {\n        return buildInputValueDefMap(inputObjectIntrospection.inputFields);\n      }\n    });\n  }\n\n  function buildFieldDefMap(typeIntrospection) {\n    if (!typeIntrospection.fields) {\n      throw new Error('Introspection result missing fields: ' + JSON.stringify(typeIntrospection));\n    }\n    return keyValMap(typeIntrospection.fields, function (fieldIntrospection) {\n      return fieldIntrospection.name;\n    }, function (fieldIntrospection) {\n      if (!fieldIntrospection.args) {\n        throw new Error('Introspection result missing field args: ' + JSON.stringify(fieldIntrospection));\n      }\n      return {\n        description: fieldIntrospection.description,\n        deprecationReason: fieldIntrospection.deprecationReason,\n        type: getOutputType(fieldIntrospection.type),\n        args: buildInputValueDefMap(fieldIntrospection.args)\n      };\n    });\n  }\n\n  function buildInputValueDefMap(inputValueIntrospections) {\n    return keyValMap(inputValueIntrospections, function (inputValue) {\n      return inputValue.name;\n    }, buildInputValue);\n  }\n\n  function buildInputValue(inputValueIntrospection) {\n    var type = getInputType(inputValueIntrospection.type);\n    var defaultValue = inputValueIntrospection.defaultValue ? valueFromAST(parseValue(inputValueIntrospection.defaultValue), type) : undefined;\n    return {\n      name: inputValueIntrospection.name,\n      description: inputValueIntrospection.description,\n      type: type,\n      defaultValue: defaultValue\n    };\n  }\n\n  function buildDirective(directiveIntrospection) {\n    // Support deprecated `on****` fields for building `locations`, as this\n    // is used by GraphiQL which may need to support outdated servers.\n    var locations = directiveIntrospection.locations ? directiveIntrospection.locations.slice() : [].concat(!directiveIntrospection.onField ? [] : [DirectiveLocation.FIELD], !directiveIntrospection.onOperation ? [] : [DirectiveLocation.QUERY, DirectiveLocation.MUTATION, DirectiveLocation.SUBSCRIPTION], !directiveIntrospection.onFragment ? [] : [DirectiveLocation.FRAGMENT_DEFINITION, DirectiveLocation.FRAGMENT_SPREAD, DirectiveLocation.INLINE_FRAGMENT]);\n    if (!directiveIntrospection.args) {\n      throw new Error('Introspection result missing directive args: ' + JSON.stringify(directiveIntrospection));\n    }\n    return new GraphQLDirective({\n      name: directiveIntrospection.name,\n      description: directiveIntrospection.description,\n      locations: locations,\n      args: buildInputValueDefMap(directiveIntrospection.args)\n    });\n  }\n\n  // Iterate through all types, getting the type definition for each, ensuring\n  // that any type not directly referenced by a field will get created.\n  var types = schemaIntrospection.types.map(function (typeIntrospection) {\n    return getNamedType(typeIntrospection.name);\n  });\n\n  // Get the root Query, Mutation, and Subscription types.\n  var queryType = schemaIntrospection.queryType ? getObjectType(schemaIntrospection.queryType) : null;\n\n  var mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;\n\n  var subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null;\n\n  // Get the directives supported by Introspection, assuming empty-set if\n  // directives were not queried for.\n  var directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : [];\n\n  // Then produce and return a Schema with these types.\n  return new GraphQLSchema({\n    query: queryType,\n    mutation: mutationType,\n    subscription: subscriptionType,\n    types: types,\n    directives: directives,\n    assumeValid: options && options.assumeValid\n  });\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}