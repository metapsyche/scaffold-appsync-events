{"ast":null,"code":"import { visit } from 'graphql/language/visitor';\nimport { InvariantError, invariant } from 'ts-invariant';\nimport { __assign, __spreadArrays } from 'tslib';\nimport stringify from 'fast-json-stable-stringify';\nexport { equal as isEqual } from '@wry/equality';\n\nfunction isScalarValue(value) {\n  return ['StringValue', 'BooleanValue', 'EnumValue'].indexOf(value.kind) > -1;\n}\n\nfunction isNumberValue(value) {\n  return ['IntValue', 'FloatValue'].indexOf(value.kind) > -1;\n}\n\nfunction isStringValue(value) {\n  return value.kind === 'StringValue';\n}\n\nfunction isBooleanValue(value) {\n  return value.kind === 'BooleanValue';\n}\n\nfunction isIntValue(value) {\n  return value.kind === 'IntValue';\n}\n\nfunction isFloatValue(value) {\n  return value.kind === 'FloatValue';\n}\n\nfunction isVariable(value) {\n  return value.kind === 'Variable';\n}\n\nfunction isObjectValue(value) {\n  return value.kind === 'ObjectValue';\n}\n\nfunction isListValue(value) {\n  return value.kind === 'ListValue';\n}\n\nfunction isEnumValue(value) {\n  return value.kind === 'EnumValue';\n}\n\nfunction isNullValue(value) {\n  return value.kind === 'NullValue';\n}\n\nfunction valueToObjectRepresentation(argObj, name, value, variables) {\n  if (isIntValue(value) || isFloatValue(value)) {\n    argObj[name.value] = Number(value.value);\n  } else if (isBooleanValue(value) || isStringValue(value)) {\n    argObj[name.value] = value.value;\n  } else if (isObjectValue(value)) {\n    var nestedArgObj_1 = {};\n    value.fields.map(function (obj) {\n      return valueToObjectRepresentation(nestedArgObj_1, obj.name, obj.value, variables);\n    });\n    argObj[name.value] = nestedArgObj_1;\n  } else if (isVariable(value)) {\n    var variableValue = (variables || {})[value.name.value];\n    argObj[name.value] = variableValue;\n  } else if (isListValue(value)) {\n    argObj[name.value] = value.values.map(function (listValue) {\n      var nestedArgArrayObj = {};\n      valueToObjectRepresentation(nestedArgArrayObj, name, listValue, variables);\n      return nestedArgArrayObj[name.value];\n    });\n  } else if (isEnumValue(value)) {\n    argObj[name.value] = value.value;\n  } else if (isNullValue(value)) {\n    argObj[name.value] = null;\n  } else {\n    throw process.env.NODE_ENV === \"production\" ? new InvariantError(17) : new InvariantError(\"The inline argument \\\"\" + name.value + \"\\\" of kind \\\"\" + value.kind + \"\\\"\" + 'is not supported. Use variables instead of inline arguments to ' + 'overcome this limitation.');\n  }\n}\n\nfunction storeKeyNameFromField(field, variables) {\n  var directivesObj = null;\n\n  if (field.directives) {\n    directivesObj = {};\n    field.directives.forEach(function (directive) {\n      directivesObj[directive.name.value] = {};\n\n      if (directive.arguments) {\n        directive.arguments.forEach(function (_a) {\n          var name = _a.name,\n              value = _a.value;\n          return valueToObjectRepresentation(directivesObj[directive.name.value], name, value, variables);\n        });\n      }\n    });\n  }\n\n  var argObj = null;\n\n  if (field.arguments && field.arguments.length) {\n    argObj = {};\n    field.arguments.forEach(function (_a) {\n      var name = _a.name,\n          value = _a.value;\n      return valueToObjectRepresentation(argObj, name, value, variables);\n    });\n  }\n\n  return getStoreKeyName(field.name.value, argObj, directivesObj);\n}\n\nvar KNOWN_DIRECTIVES = ['connection', 'include', 'skip', 'client', 'rest', 'export'];\n\nfunction getStoreKeyName(fieldName, args, directives) {\n  if (directives && directives['connection'] && directives['connection']['key']) {\n    if (directives['connection']['filter'] && directives['connection']['filter'].length > 0) {\n      var filterKeys = directives['connection']['filter'] ? directives['connection']['filter'] : [];\n      filterKeys.sort();\n      var queryArgs_1 = args;\n      var filteredArgs_1 = {};\n      filterKeys.forEach(function (key) {\n        filteredArgs_1[key] = queryArgs_1[key];\n      });\n      return directives['connection']['key'] + \"(\" + JSON.stringify(filteredArgs_1) + \")\";\n    } else {\n      return directives['connection']['key'];\n    }\n  }\n\n  var completeFieldName = fieldName;\n\n  if (args) {\n    var stringifiedArgs = stringify(args);\n    completeFieldName += \"(\" + stringifiedArgs + \")\";\n  }\n\n  if (directives) {\n    Object.keys(directives).forEach(function (key) {\n      if (KNOWN_DIRECTIVES.indexOf(key) !== -1) return;\n\n      if (directives[key] && Object.keys(directives[key]).length) {\n        completeFieldName += \"@\" + key + \"(\" + JSON.stringify(directives[key]) + \")\";\n      } else {\n        completeFieldName += \"@\" + key;\n      }\n    });\n  }\n\n  return completeFieldName;\n}\n\nfunction argumentsObjectFromField(field, variables) {\n  if (field.arguments && field.arguments.length) {\n    var argObj_1 = {};\n    field.arguments.forEach(function (_a) {\n      var name = _a.name,\n          value = _a.value;\n      return valueToObjectRepresentation(argObj_1, name, value, variables);\n    });\n    return argObj_1;\n  }\n\n  return null;\n}\n\nfunction resultKeyNameFromField(field) {\n  return field.alias ? field.alias.value : field.name.value;\n}\n\nfunction isField(selection) {\n  return selection.kind === 'Field';\n}\n\nfunction isInlineFragment(selection) {\n  return selection.kind === 'InlineFragment';\n}\n\nfunction isIdValue(idObject) {\n  return idObject && idObject.type === 'id' && typeof idObject.generated === 'boolean';\n}\n\nfunction toIdValue(idConfig, generated) {\n  if (generated === void 0) {\n    generated = false;\n  }\n\n  return __assign({\n    type: 'id',\n    generated: generated\n  }, typeof idConfig === 'string' ? {\n    id: idConfig,\n    typename: undefined\n  } : idConfig);\n}\n\nfunction isJsonValue(jsonObject) {\n  return jsonObject != null && typeof jsonObject === 'object' && jsonObject.type === 'json';\n}\n\nfunction defaultValueFromVariable(node) {\n  throw process.env.NODE_ENV === \"production\" ? new InvariantError(18) : new InvariantError(\"Variable nodes are not supported by valueFromNode\");\n}\n\nfunction valueFromNode(node, onVariable) {\n  if (onVariable === void 0) {\n    onVariable = defaultValueFromVariable;\n  }\n\n  switch (node.kind) {\n    case 'Variable':\n      return onVariable(node);\n\n    case 'NullValue':\n      return null;\n\n    case 'IntValue':\n      return parseInt(node.value, 10);\n\n    case 'FloatValue':\n      return parseFloat(node.value);\n\n    case 'ListValue':\n      return node.values.map(function (v) {\n        return valueFromNode(v, onVariable);\n      });\n\n    case 'ObjectValue':\n      {\n        var value = {};\n\n        for (var _i = 0, _a = node.fields; _i < _a.length; _i++) {\n          var field = _a[_i];\n          value[field.name.value] = valueFromNode(field.value, onVariable);\n        }\n\n        return value;\n      }\n\n    default:\n      return node.value;\n  }\n}\n\nfunction getDirectiveInfoFromField(field, variables) {\n  if (field.directives && field.directives.length) {\n    var directiveObj_1 = {};\n    field.directives.forEach(function (directive) {\n      directiveObj_1[directive.name.value] = argumentsObjectFromField(directive, variables);\n    });\n    return directiveObj_1;\n  }\n\n  return null;\n}\n\nfunction shouldInclude(selection, variables) {\n  if (variables === void 0) {\n    variables = {};\n  }\n\n  return getInclusionDirectives(selection.directives).every(function (_a) {\n    var directive = _a.directive,\n        ifArgument = _a.ifArgument;\n    var evaledValue = false;\n\n    if (ifArgument.value.kind === 'Variable') {\n      evaledValue = variables[ifArgument.value.name.value];\n      process.env.NODE_ENV === \"production\" ? invariant(evaledValue !== void 0, 13) : invariant(evaledValue !== void 0, \"Invalid variable referenced in @\" + directive.name.value + \" directive.\");\n    } else {\n      evaledValue = ifArgument.value.value;\n    }\n\n    return directive.name.value === 'skip' ? !evaledValue : evaledValue;\n  });\n}\n\nfunction getDirectiveNames(doc) {\n  var names = [];\n  visit(doc, {\n    Directive: function (node) {\n      names.push(node.name.value);\n    }\n  });\n  return names;\n}\n\nfunction hasDirectives(names, doc) {\n  return getDirectiveNames(doc).some(function (name) {\n    return names.indexOf(name) > -1;\n  });\n}\n\nfunction hasClientExports(document) {\n  return document && hasDirectives(['client'], document) && hasDirectives(['export'], document);\n}\n\nfunction isInclusionDirective(_a) {\n  var value = _a.name.value;\n  return value === 'skip' || value === 'include';\n}\n\nfunction getInclusionDirectives(directives) {\n  return directives ? directives.filter(isInclusionDirective).map(function (directive) {\n    var directiveArguments = directive.arguments;\n    var directiveName = directive.name.value;\n    process.env.NODE_ENV === \"production\" ? invariant(directiveArguments && directiveArguments.length === 1, 14) : invariant(directiveArguments && directiveArguments.length === 1, \"Incorrect number of arguments for the @\" + directiveName + \" directive.\");\n    var ifArgument = directiveArguments[0];\n    process.env.NODE_ENV === \"production\" ? invariant(ifArgument.name && ifArgument.name.value === 'if', 15) : invariant(ifArgument.name && ifArgument.name.value === 'if', \"Invalid argument for the @\" + directiveName + \" directive.\");\n    var ifValue = ifArgument.value;\n    process.env.NODE_ENV === \"production\" ? invariant(ifValue && (ifValue.kind === 'Variable' || ifValue.kind === 'BooleanValue'), 16) : invariant(ifValue && (ifValue.kind === 'Variable' || ifValue.kind === 'BooleanValue'), \"Argument for the @\" + directiveName + \" directive must be a variable or a boolean value.\");\n    return {\n      directive: directive,\n      ifArgument: ifArgument\n    };\n  }) : [];\n}\n\nfunction getFragmentQueryDocument(document, fragmentName) {\n  var actualFragmentName = fragmentName;\n  var fragments = [];\n  document.definitions.forEach(function (definition) {\n    if (definition.kind === 'OperationDefinition') {\n      throw process.env.NODE_ENV === \"production\" ? new InvariantError(11) : new InvariantError(\"Found a \" + definition.operation + \" operation\" + (definition.name ? \" named '\" + definition.name.value + \"'\" : '') + \". \" + 'No operations are allowed when using a fragment as a query. Only fragments are allowed.');\n    }\n\n    if (definition.kind === 'FragmentDefinition') {\n      fragments.push(definition);\n    }\n  });\n\n  if (typeof actualFragmentName === 'undefined') {\n    process.env.NODE_ENV === \"production\" ? invariant(fragments.length === 1, 12) : invariant(fragments.length === 1, \"Found \" + fragments.length + \" fragments. `fragmentName` must be provided when there is not exactly 1 fragment.\");\n    actualFragmentName = fragments[0].name.value;\n  }\n\n  var query = __assign(__assign({}, document), {\n    definitions: __spreadArrays([{\n      kind: 'OperationDefinition',\n      operation: 'query',\n      selectionSet: {\n        kind: 'SelectionSet',\n        selections: [{\n          kind: 'FragmentSpread',\n          name: {\n            kind: 'Name',\n            value: actualFragmentName\n          }\n        }]\n      }\n    }], document.definitions)\n  });\n\n  return query;\n}\n\nfunction assign(target) {\n  var sources = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    sources[_i - 1] = arguments[_i];\n  }\n\n  sources.forEach(function (source) {\n    if (typeof source === 'undefined' || source === null) {\n      return;\n    }\n\n    Object.keys(source).forEach(function (key) {\n      target[key] = source[key];\n    });\n  });\n  return target;\n}\n\nfunction getMutationDefinition(doc) {\n  checkDocument(doc);\n  var mutationDef = doc.definitions.filter(function (definition) {\n    return definition.kind === 'OperationDefinition' && definition.operation === 'mutation';\n  })[0];\n  process.env.NODE_ENV === \"production\" ? invariant(mutationDef, 1) : invariant(mutationDef, 'Must contain a mutation definition.');\n  return mutationDef;\n}\n\nfunction checkDocument(doc) {\n  process.env.NODE_ENV === \"production\" ? invariant(doc && doc.kind === 'Document', 2) : invariant(doc && doc.kind === 'Document', \"Expecting a parsed GraphQL document. Perhaps you need to wrap the query string in a \\\"gql\\\" tag? http://docs.apollostack.com/apollo-client/core.html#gql\");\n  var operations = doc.definitions.filter(function (d) {\n    return d.kind !== 'FragmentDefinition';\n  }).map(function (definition) {\n    if (definition.kind !== 'OperationDefinition') {\n      throw process.env.NODE_ENV === \"production\" ? new InvariantError(3) : new InvariantError(\"Schema type definitions not allowed in queries. Found: \\\"\" + definition.kind + \"\\\"\");\n    }\n\n    return definition;\n  });\n  process.env.NODE_ENV === \"production\" ? invariant(operations.length <= 1, 4) : invariant(operations.length <= 1, \"Ambiguous GraphQL document: contains \" + operations.length + \" operations\");\n  return doc;\n}\n\nfunction getOperationDefinition(doc) {\n  checkDocument(doc);\n  return doc.definitions.filter(function (definition) {\n    return definition.kind === 'OperationDefinition';\n  })[0];\n}\n\nfunction getOperationDefinitionOrDie(document) {\n  var def = getOperationDefinition(document);\n  process.env.NODE_ENV === \"production\" ? invariant(def, 5) : invariant(def, \"GraphQL document is missing an operation\");\n  return def;\n}\n\nfunction getOperationName(doc) {\n  return doc.definitions.filter(function (definition) {\n    return definition.kind === 'OperationDefinition' && definition.name;\n  }).map(function (x) {\n    return x.name.value;\n  })[0] || null;\n}\n\nfunction getFragmentDefinitions(doc) {\n  return doc.definitions.filter(function (definition) {\n    return definition.kind === 'FragmentDefinition';\n  });\n}\n\nfunction getQueryDefinition(doc) {\n  var queryDef = getOperationDefinition(doc);\n  process.env.NODE_ENV === \"production\" ? invariant(queryDef && queryDef.operation === 'query', 6) : invariant(queryDef && queryDef.operation === 'query', 'Must contain a query definition.');\n  return queryDef;\n}\n\nfunction getFragmentDefinition(doc) {\n  process.env.NODE_ENV === \"production\" ? invariant(doc.kind === 'Document', 7) : invariant(doc.kind === 'Document', \"Expecting a parsed GraphQL document. Perhaps you need to wrap the query string in a \\\"gql\\\" tag? http://docs.apollostack.com/apollo-client/core.html#gql\");\n  process.env.NODE_ENV === \"production\" ? invariant(doc.definitions.length <= 1, 8) : invariant(doc.definitions.length <= 1, 'Fragment must have exactly one definition.');\n  var fragmentDef = doc.definitions[0];\n  process.env.NODE_ENV === \"production\" ? invariant(fragmentDef.kind === 'FragmentDefinition', 9) : invariant(fragmentDef.kind === 'FragmentDefinition', 'Must be a fragment definition.');\n  return fragmentDef;\n}\n\nfunction getMainDefinition(queryDoc) {\n  checkDocument(queryDoc);\n  var fragmentDefinition;\n\n  for (var _i = 0, _a = queryDoc.definitions; _i < _a.length; _i++) {\n    var definition = _a[_i];\n\n    if (definition.kind === 'OperationDefinition') {\n      var operation = definition.operation;\n\n      if (operation === 'query' || operation === 'mutation' || operation === 'subscription') {\n        return definition;\n      }\n    }\n\n    if (definition.kind === 'FragmentDefinition' && !fragmentDefinition) {\n      fragmentDefinition = definition;\n    }\n  }\n\n  if (fragmentDefinition) {\n    return fragmentDefinition;\n  }\n\n  throw process.env.NODE_ENV === \"production\" ? new InvariantError(10) : new InvariantError('Expected a parsed GraphQL query with a query, mutation, subscription, or a fragment.');\n}\n\nfunction createFragmentMap(fragments) {\n  if (fragments === void 0) {\n    fragments = [];\n  }\n\n  var symTable = {};\n  fragments.forEach(function (fragment) {\n    symTable[fragment.name.value] = fragment;\n  });\n  return symTable;\n}\n\nfunction getDefaultValues(definition) {\n  if (definition && definition.variableDefinitions && definition.variableDefinitions.length) {\n    var defaultValues = definition.variableDefinitions.filter(function (_a) {\n      var defaultValue = _a.defaultValue;\n      return defaultValue;\n    }).map(function (_a) {\n      var variable = _a.variable,\n          defaultValue = _a.defaultValue;\n      var defaultValueObj = {};\n      valueToObjectRepresentation(defaultValueObj, variable.name, defaultValue);\n      return defaultValueObj;\n    });\n    return assign.apply(void 0, __spreadArrays([{}], defaultValues));\n  }\n\n  return {};\n}\n\nfunction variablesInOperation(operation) {\n  var names = new Set();\n\n  if (operation.variableDefinitions) {\n    for (var _i = 0, _a = operation.variableDefinitions; _i < _a.length; _i++) {\n      var definition = _a[_i];\n      names.add(definition.variable.name.value);\n    }\n  }\n\n  return names;\n}\n\nfunction filterInPlace(array, test, context) {\n  var target = 0;\n  array.forEach(function (elem, i) {\n    if (test.call(this, elem, i, array)) {\n      array[target++] = elem;\n    }\n  }, context);\n  array.length = target;\n  return array;\n}\n\nvar TYPENAME_FIELD = {\n  kind: 'Field',\n  name: {\n    kind: 'Name',\n    value: '__typename'\n  }\n};\n\nfunction isEmpty(op, fragments) {\n  return op.selectionSet.selections.every(function (selection) {\n    return selection.kind === 'FragmentSpread' && isEmpty(fragments[selection.name.value], fragments);\n  });\n}\n\nfunction nullIfDocIsEmpty(doc) {\n  return isEmpty(getOperationDefinition(doc) || getFragmentDefinition(doc), createFragmentMap(getFragmentDefinitions(doc))) ? null : doc;\n}\n\nfunction getDirectiveMatcher(directives) {\n  return function directiveMatcher(directive) {\n    return directives.some(function (dir) {\n      return dir.name && dir.name === directive.name.value || dir.test && dir.test(directive);\n    });\n  };\n}\n\nfunction removeDirectivesFromDocument(directives, doc) {\n  var variablesInUse = Object.create(null);\n  var variablesToRemove = [];\n  var fragmentSpreadsInUse = Object.create(null);\n  var fragmentSpreadsToRemove = [];\n  var modifiedDoc = nullIfDocIsEmpty(visit(doc, {\n    Variable: {\n      enter: function (node, _key, parent) {\n        if (parent.kind !== 'VariableDefinition') {\n          variablesInUse[node.name.value] = true;\n        }\n      }\n    },\n    Field: {\n      enter: function (node) {\n        if (directives && node.directives) {\n          var shouldRemoveField = directives.some(function (directive) {\n            return directive.remove;\n          });\n\n          if (shouldRemoveField && node.directives && node.directives.some(getDirectiveMatcher(directives))) {\n            if (node.arguments) {\n              node.arguments.forEach(function (arg) {\n                if (arg.value.kind === 'Variable') {\n                  variablesToRemove.push({\n                    name: arg.value.name.value\n                  });\n                }\n              });\n            }\n\n            if (node.selectionSet) {\n              getAllFragmentSpreadsFromSelectionSet(node.selectionSet).forEach(function (frag) {\n                fragmentSpreadsToRemove.push({\n                  name: frag.name.value\n                });\n              });\n            }\n\n            return null;\n          }\n        }\n      }\n    },\n    FragmentSpread: {\n      enter: function (node) {\n        fragmentSpreadsInUse[node.name.value] = true;\n      }\n    },\n    Directive: {\n      enter: function (node) {\n        if (getDirectiveMatcher(directives)(node)) {\n          return null;\n        }\n      }\n    }\n  }));\n\n  if (modifiedDoc && filterInPlace(variablesToRemove, function (v) {\n    return !variablesInUse[v.name];\n  }).length) {\n    modifiedDoc = removeArgumentsFromDocument(variablesToRemove, modifiedDoc);\n  }\n\n  if (modifiedDoc && filterInPlace(fragmentSpreadsToRemove, function (fs) {\n    return !fragmentSpreadsInUse[fs.name];\n  }).length) {\n    modifiedDoc = removeFragmentSpreadFromDocument(fragmentSpreadsToRemove, modifiedDoc);\n  }\n\n  return modifiedDoc;\n}\n\nfunction addTypenameToDocument(doc) {\n  return visit(checkDocument(doc), {\n    SelectionSet: {\n      enter: function (node, _key, parent) {\n        if (parent && parent.kind === 'OperationDefinition') {\n          return;\n        }\n\n        var selections = node.selections;\n\n        if (!selections) {\n          return;\n        }\n\n        var skip = selections.some(function (selection) {\n          return isField(selection) && (selection.name.value === '__typename' || selection.name.value.lastIndexOf('__', 0) === 0);\n        });\n\n        if (skip) {\n          return;\n        }\n\n        var field = parent;\n\n        if (isField(field) && field.directives && field.directives.some(function (d) {\n          return d.name.value === 'export';\n        })) {\n          return;\n        }\n\n        return __assign(__assign({}, node), {\n          selections: __spreadArrays(selections, [TYPENAME_FIELD])\n        });\n      }\n    }\n  });\n}\n\nvar connectionRemoveConfig = {\n  test: function (directive) {\n    var willRemove = directive.name.value === 'connection';\n\n    if (willRemove) {\n      if (!directive.arguments || !directive.arguments.some(function (arg) {\n        return arg.name.value === 'key';\n      })) {\n        process.env.NODE_ENV === \"production\" || invariant.warn('Removing an @connection directive even though it does not have a key. ' + 'You may want to use the key parameter to specify a store key.');\n      }\n    }\n\n    return willRemove;\n  }\n};\n\nfunction removeConnectionDirectiveFromDocument(doc) {\n  return removeDirectivesFromDocument([connectionRemoveConfig], checkDocument(doc));\n}\n\nfunction hasDirectivesInSelectionSet(directives, selectionSet, nestedCheck) {\n  if (nestedCheck === void 0) {\n    nestedCheck = true;\n  }\n\n  return selectionSet && selectionSet.selections && selectionSet.selections.some(function (selection) {\n    return hasDirectivesInSelection(directives, selection, nestedCheck);\n  });\n}\n\nfunction hasDirectivesInSelection(directives, selection, nestedCheck) {\n  if (nestedCheck === void 0) {\n    nestedCheck = true;\n  }\n\n  if (!isField(selection)) {\n    return true;\n  }\n\n  if (!selection.directives) {\n    return false;\n  }\n\n  return selection.directives.some(getDirectiveMatcher(directives)) || nestedCheck && hasDirectivesInSelectionSet(directives, selection.selectionSet, nestedCheck);\n}\n\nfunction getDirectivesFromDocument(directives, doc) {\n  checkDocument(doc);\n  var parentPath;\n  return nullIfDocIsEmpty(visit(doc, {\n    SelectionSet: {\n      enter: function (node, _key, _parent, path) {\n        var currentPath = path.join('-');\n\n        if (!parentPath || currentPath === parentPath || !currentPath.startsWith(parentPath)) {\n          if (node.selections) {\n            var selectionsWithDirectives = node.selections.filter(function (selection) {\n              return hasDirectivesInSelection(directives, selection);\n            });\n\n            if (hasDirectivesInSelectionSet(directives, node, false)) {\n              parentPath = currentPath;\n            }\n\n            return __assign(__assign({}, node), {\n              selections: selectionsWithDirectives\n            });\n          } else {\n            return null;\n          }\n        }\n      }\n    }\n  }));\n}\n\nfunction getArgumentMatcher(config) {\n  return function argumentMatcher(argument) {\n    return config.some(function (aConfig) {\n      return argument.value && argument.value.kind === 'Variable' && argument.value.name && (aConfig.name === argument.value.name.value || aConfig.test && aConfig.test(argument));\n    });\n  };\n}\n\nfunction removeArgumentsFromDocument(config, doc) {\n  var argMatcher = getArgumentMatcher(config);\n  return nullIfDocIsEmpty(visit(doc, {\n    OperationDefinition: {\n      enter: function (node) {\n        return __assign(__assign({}, node), {\n          variableDefinitions: node.variableDefinitions.filter(function (varDef) {\n            return !config.some(function (arg) {\n              return arg.name === varDef.variable.name.value;\n            });\n          })\n        });\n      }\n    },\n    Field: {\n      enter: function (node) {\n        var shouldRemoveField = config.some(function (argConfig) {\n          return argConfig.remove;\n        });\n\n        if (shouldRemoveField) {\n          var argMatchCount_1 = 0;\n          node.arguments.forEach(function (arg) {\n            if (argMatcher(arg)) {\n              argMatchCount_1 += 1;\n            }\n          });\n\n          if (argMatchCount_1 === 1) {\n            return null;\n          }\n        }\n      }\n    },\n    Argument: {\n      enter: function (node) {\n        if (argMatcher(node)) {\n          return null;\n        }\n      }\n    }\n  }));\n}\n\nfunction removeFragmentSpreadFromDocument(config, doc) {\n  function enter(node) {\n    if (config.some(function (def) {\n      return def.name === node.name.value;\n    })) {\n      return null;\n    }\n  }\n\n  return nullIfDocIsEmpty(visit(doc, {\n    FragmentSpread: {\n      enter: enter\n    },\n    FragmentDefinition: {\n      enter: enter\n    }\n  }));\n}\n\nfunction getAllFragmentSpreadsFromSelectionSet(selectionSet) {\n  var allFragments = [];\n  selectionSet.selections.forEach(function (selection) {\n    if ((isField(selection) || isInlineFragment(selection)) && selection.selectionSet) {\n      getAllFragmentSpreadsFromSelectionSet(selection.selectionSet).forEach(function (frag) {\n        return allFragments.push(frag);\n      });\n    } else if (selection.kind === 'FragmentSpread') {\n      allFragments.push(selection);\n    }\n  });\n  return allFragments;\n}\n\nfunction buildQueryFromSelectionSet(document) {\n  var definition = getMainDefinition(document);\n  var definitionOperation = definition.operation;\n\n  if (definitionOperation === 'query') {\n    return document;\n  }\n\n  var modifiedDoc = visit(document, {\n    OperationDefinition: {\n      enter: function (node) {\n        return __assign(__assign({}, node), {\n          operation: 'query'\n        });\n      }\n    }\n  });\n  return modifiedDoc;\n}\n\nfunction removeClientSetsFromDocument(document) {\n  checkDocument(document);\n  var modifiedDoc = removeDirectivesFromDocument([{\n    test: function (directive) {\n      return directive.name.value === 'client';\n    },\n    remove: true\n  }], document);\n\n  if (modifiedDoc) {\n    modifiedDoc = visit(modifiedDoc, {\n      FragmentDefinition: {\n        enter: function (node) {\n          if (node.selectionSet) {\n            var isTypenameOnly = node.selectionSet.selections.every(function (selection) {\n              return isField(selection) && selection.name.value === '__typename';\n            });\n\n            if (isTypenameOnly) {\n              return null;\n            }\n          }\n        }\n      }\n    });\n  }\n\n  return modifiedDoc;\n}\n\nvar canUseWeakMap = typeof WeakMap === 'function' && !(typeof navigator === 'object' && navigator.product === 'ReactNative');\nvar toString = Object.prototype.toString;\n\nfunction cloneDeep(value) {\n  return cloneDeepHelper(value, new Map());\n}\n\nfunction cloneDeepHelper(val, seen) {\n  switch (toString.call(val)) {\n    case \"[object Array]\":\n      {\n        if (seen.has(val)) return seen.get(val);\n        var copy_1 = val.slice(0);\n        seen.set(val, copy_1);\n        copy_1.forEach(function (child, i) {\n          copy_1[i] = cloneDeepHelper(child, seen);\n        });\n        return copy_1;\n      }\n\n    case \"[object Object]\":\n      {\n        if (seen.has(val)) return seen.get(val);\n        var copy_2 = Object.create(Object.getPrototypeOf(val));\n        seen.set(val, copy_2);\n        Object.keys(val).forEach(function (key) {\n          copy_2[key] = cloneDeepHelper(val[key], seen);\n        });\n        return copy_2;\n      }\n\n    default:\n      return val;\n  }\n}\n\nfunction getEnv() {\n  if (typeof process !== 'undefined' && process.env.NODE_ENV) {\n    return process.env.NODE_ENV;\n  }\n\n  return 'development';\n}\n\nfunction isEnv(env) {\n  return getEnv() === env;\n}\n\nfunction isProduction() {\n  return isEnv('production') === true;\n}\n\nfunction isDevelopment() {\n  return isEnv('development') === true;\n}\n\nfunction isTest() {\n  return isEnv('test') === true;\n}\n\nfunction tryFunctionOrLogError(f) {\n  try {\n    return f();\n  } catch (e) {\n    if (console.error) {\n      console.error(e);\n    }\n  }\n}\n\nfunction graphQLResultHasError(result) {\n  return result.errors && result.errors.length;\n}\n\nfunction deepFreeze(o) {\n  Object.freeze(o);\n  Object.getOwnPropertyNames(o).forEach(function (prop) {\n    if (o[prop] !== null && (typeof o[prop] === 'object' || typeof o[prop] === 'function') && !Object.isFrozen(o[prop])) {\n      deepFreeze(o[prop]);\n    }\n  });\n  return o;\n}\n\nfunction maybeDeepFreeze(obj) {\n  if (isDevelopment() || isTest()) {\n    var symbolIsPolyfilled = typeof Symbol === 'function' && typeof Symbol('') === 'string';\n\n    if (!symbolIsPolyfilled) {\n      return deepFreeze(obj);\n    }\n  }\n\n  return obj;\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction mergeDeep() {\n  var sources = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    sources[_i] = arguments[_i];\n  }\n\n  return mergeDeepArray(sources);\n}\n\nfunction mergeDeepArray(sources) {\n  var target = sources[0] || {};\n  var count = sources.length;\n\n  if (count > 1) {\n    var pastCopies = [];\n    target = shallowCopyForMerge(target, pastCopies);\n\n    for (var i = 1; i < count; ++i) {\n      target = mergeHelper(target, sources[i], pastCopies);\n    }\n  }\n\n  return target;\n}\n\nfunction isObject(obj) {\n  return obj !== null && typeof obj === 'object';\n}\n\nfunction mergeHelper(target, source, pastCopies) {\n  if (isObject(source) && isObject(target)) {\n    if (Object.isExtensible && !Object.isExtensible(target)) {\n      target = shallowCopyForMerge(target, pastCopies);\n    }\n\n    Object.keys(source).forEach(function (sourceKey) {\n      var sourceValue = source[sourceKey];\n\n      if (hasOwnProperty.call(target, sourceKey)) {\n        var targetValue = target[sourceKey];\n\n        if (sourceValue !== targetValue) {\n          target[sourceKey] = mergeHelper(shallowCopyForMerge(targetValue, pastCopies), sourceValue, pastCopies);\n        }\n      } else {\n        target[sourceKey] = sourceValue;\n      }\n    });\n    return target;\n  }\n\n  return source;\n}\n\nfunction shallowCopyForMerge(value, pastCopies) {\n  if (value !== null && typeof value === 'object' && pastCopies.indexOf(value) < 0) {\n    if (Array.isArray(value)) {\n      value = value.slice(0);\n    } else {\n      value = __assign({\n        __proto__: Object.getPrototypeOf(value)\n      }, value);\n    }\n\n    pastCopies.push(value);\n  }\n\n  return value;\n}\n\nvar haveWarned = Object.create({});\n\nfunction warnOnceInDevelopment(msg, type) {\n  if (type === void 0) {\n    type = 'warn';\n  }\n\n  if (!isProduction() && !haveWarned[msg]) {\n    if (!isTest()) {\n      haveWarned[msg] = true;\n    }\n\n    if (type === 'error') {\n      console.error(msg);\n    } else {\n      console.warn(msg);\n    }\n  }\n}\n\nfunction stripSymbols(data) {\n  return JSON.parse(JSON.stringify(data));\n}\n\nexport { addTypenameToDocument, argumentsObjectFromField, assign, buildQueryFromSelectionSet, canUseWeakMap, checkDocument, cloneDeep, createFragmentMap, getDefaultValues, getDirectiveInfoFromField, getDirectiveNames, getDirectivesFromDocument, getEnv, getFragmentDefinition, getFragmentDefinitions, getFragmentQueryDocument, getInclusionDirectives, getMainDefinition, getMutationDefinition, getOperationDefinition, getOperationDefinitionOrDie, getOperationName, getQueryDefinition, getStoreKeyName, graphQLResultHasError, hasClientExports, hasDirectives, isDevelopment, isEnv, isField, isIdValue, isInlineFragment, isJsonValue, isNumberValue, isProduction, isScalarValue, isTest, maybeDeepFreeze, mergeDeep, mergeDeepArray, removeArgumentsFromDocument, removeClientSetsFromDocument, removeConnectionDirectiveFromDocument, removeDirectivesFromDocument, removeFragmentSpreadFromDocument, resultKeyNameFromField, shouldInclude, storeKeyNameFromField, stripSymbols, toIdValue, tryFunctionOrLogError, valueFromNode, valueToObjectRepresentation, variablesInOperation, warnOnceInDevelopment };","map":{"version":3,"sources":["../src/storeUtils.ts","../src/directives.ts","../src/fragments.ts","../src/util/assign.ts","../src/getFromAST.ts","../src/util/filterInPlace.ts","../src/transform.ts","../src/util/canUse.ts","../src/util/cloneDeep.ts","../src/util/environment.ts","../src/util/errorHandling.ts","../src/util/maybeDeepFreeze.ts","../src/util/mergeDeep.ts","../src/util/warnOnce.ts","../src/util/stripSymbols.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  DirectiveNode,\n  FieldNode,\n  IntValueNode,\n  FloatValueNode,\n  StringValueNode,\n  BooleanValueNode,\n  ObjectValueNode,\n  ListValueNode,\n  EnumValueNode,\n  NullValueNode,\n  VariableNode,\n  InlineFragmentNode,\n  ValueNode,\n  SelectionNode,\n  NameNode,\n} from 'graphql';\n\nimport stringify from 'fast-json-stable-stringify';\nimport { InvariantError } from 'ts-invariant';\n\nexport interface IdValue {\n  type: 'id';\n  id: string;\n  generated: boolean;\n  typename: string | undefined;\n}\n\nexport interface JsonValue {\n  type: 'json';\n  json: any;\n}\n\nexport type ListValue = Array<null | IdValue>;\n\nexport type StoreValue =\n  | number\n  | string\n  | string[]\n  | IdValue\n  | ListValue\n  | JsonValue\n  | null\n  | undefined\n  | void\n  | Object;\n\nexport type ScalarValue = StringValueNode | BooleanValueNode | EnumValueNode;\n\nexport function isScalarValue(value: ValueNode): value is ScalarValue {\n  return ['StringValue', 'BooleanValue', 'EnumValue'].indexOf(value.kind) > -1;\n}\n\nexport type NumberValue = IntValueNode | FloatValueNode;\n\nexport function isNumberValue(value: ValueNode): value is NumberValue {\n  return ['IntValue', 'FloatValue'].indexOf(value.kind) > -1;\n}\n\nfunction isStringValue(value: ValueNode): value is StringValueNode {\n  return value.kind === 'StringValue';\n}\n\nfunction isBooleanValue(value: ValueNode): value is BooleanValueNode {\n  return value.kind === 'BooleanValue';\n}\n\nfunction isIntValue(value: ValueNode): value is IntValueNode {\n  return value.kind === 'IntValue';\n}\n\nfunction isFloatValue(value: ValueNode): value is FloatValueNode {\n  return value.kind === 'FloatValue';\n}\n\nfunction isVariable(value: ValueNode): value is VariableNode {\n  return value.kind === 'Variable';\n}\n\nfunction isObjectValue(value: ValueNode): value is ObjectValueNode {\n  return value.kind === 'ObjectValue';\n}\n\nfunction isListValue(value: ValueNode): value is ListValueNode {\n  return value.kind === 'ListValue';\n}\n\nfunction isEnumValue(value: ValueNode): value is EnumValueNode {\n  return value.kind === 'EnumValue';\n}\n\nfunction isNullValue(value: ValueNode): value is NullValueNode {\n  return value.kind === 'NullValue';\n}\n\nexport function valueToObjectRepresentation(\n  argObj: any,\n  name: NameNode,\n  value: ValueNode,\n  variables?: Object,\n) {\n  if (isIntValue(value) || isFloatValue(value)) {\n    argObj[name.value] = Number(value.value);\n  } else if (isBooleanValue(value) || isStringValue(value)) {\n    argObj[name.value] = value.value;\n  } else if (isObjectValue(value)) {\n    const nestedArgObj = {};\n    value.fields.map(obj =>\n      valueToObjectRepresentation(nestedArgObj, obj.name, obj.value, variables),\n    );\n    argObj[name.value] = nestedArgObj;\n  } else if (isVariable(value)) {\n    const variableValue = (variables || ({} as any))[value.name.value];\n    argObj[name.value] = variableValue;\n  } else if (isListValue(value)) {\n    argObj[name.value] = value.values.map(listValue => {\n      const nestedArgArrayObj = {};\n      valueToObjectRepresentation(\n        nestedArgArrayObj,\n        name,\n        listValue,\n        variables,\n      );\n      return (nestedArgArrayObj as any)[name.value];\n    });\n  } else if (isEnumValue(value)) {\n    argObj[name.value] = (value as EnumValueNode).value;\n  } else if (isNullValue(value)) {\n    argObj[name.value] = null;\n  } else {\n    throw new InvariantError(\n      `The inline argument \"${name.value}\" of kind \"${(value as any).kind}\"` +\n        'is not supported. Use variables instead of inline arguments to ' +\n        'overcome this limitation.',\n    );\n  }\n}\n\nexport function storeKeyNameFromField(\n  field: FieldNode,\n  variables?: Object,\n): string {\n  let directivesObj: any = null;\n  if (field.directives) {\n    directivesObj = {};\n    field.directives.forEach(directive => {\n      directivesObj[directive.name.value] = {};\n\n      if (directive.arguments) {\n        directive.arguments.forEach(({ name, value }) =>\n          valueToObjectRepresentation(\n            directivesObj[directive.name.value],\n            name,\n            value,\n            variables,\n          ),\n        );\n      }\n    });\n  }\n\n  let argObj: any = null;\n  if (field.arguments && field.arguments.length) {\n    argObj = {};\n    field.arguments.forEach(({ name, value }) =>\n      valueToObjectRepresentation(argObj, name, value, variables),\n    );\n  }\n\n  return getStoreKeyName(field.name.value, argObj, directivesObj);\n}\n\nexport type Directives = {\n  [directiveName: string]: {\n    [argName: string]: any;\n  };\n};\n\nconst KNOWN_DIRECTIVES: string[] = [\n  'connection',\n  'include',\n  'skip',\n  'client',\n  'rest',\n  'export',\n];\n\nexport function getStoreKeyName(\n  fieldName: string,\n  args?: Object,\n  directives?: Directives,\n): string {\n  if (\n    directives &&\n    directives['connection'] &&\n    directives['connection']['key']\n  ) {\n    if (\n      directives['connection']['filter'] &&\n      (directives['connection']['filter'] as string[]).length > 0\n    ) {\n      const filterKeys = directives['connection']['filter']\n        ? (directives['connection']['filter'] as string[])\n        : [];\n      filterKeys.sort();\n\n      const queryArgs = args as { [key: string]: any };\n      const filteredArgs = {} as { [key: string]: any };\n      filterKeys.forEach(key => {\n        filteredArgs[key] = queryArgs[key];\n      });\n\n      return `${directives['connection']['key']}(${JSON.stringify(\n        filteredArgs,\n      )})`;\n    } else {\n      return directives['connection']['key'];\n    }\n  }\n\n  let completeFieldName: string = fieldName;\n\n  if (args) {\n    // We can't use `JSON.stringify` here since it's non-deterministic,\n    // and can lead to different store key names being created even though\n    // the `args` object used during creation has the same properties/values.\n    const stringifiedArgs: string = stringify(args);\n    completeFieldName += `(${stringifiedArgs})`;\n  }\n\n  if (directives) {\n    Object.keys(directives).forEach(key => {\n      if (KNOWN_DIRECTIVES.indexOf(key) !== -1) return;\n      if (directives[key] && Object.keys(directives[key]).length) {\n        completeFieldName += `@${key}(${JSON.stringify(directives[key])})`;\n      } else {\n        completeFieldName += `@${key}`;\n      }\n    });\n  }\n\n  return completeFieldName;\n}\n\nexport function argumentsObjectFromField(\n  field: FieldNode | DirectiveNode,\n  variables: Object,\n): Object {\n  if (field.arguments && field.arguments.length) {\n    const argObj: Object = {};\n    field.arguments.forEach(({ name, value }) =>\n      valueToObjectRepresentation(argObj, name, value, variables),\n    );\n    return argObj;\n  }\n\n  return null;\n}\n\nexport function resultKeyNameFromField(field: FieldNode): string {\n  return field.alias ? field.alias.value : field.name.value;\n}\n\nexport function isField(selection: SelectionNode): selection is FieldNode {\n  return selection.kind === 'Field';\n}\n\nexport function isInlineFragment(\n  selection: SelectionNode,\n): selection is InlineFragmentNode {\n  return selection.kind === 'InlineFragment';\n}\n\nexport function isIdValue(idObject: StoreValue): idObject is IdValue {\n  return idObject &&\n    (idObject as IdValue | JsonValue).type === 'id' &&\n    typeof (idObject as IdValue).generated === 'boolean';\n}\n\nexport type IdConfig = {\n  id: string;\n  typename: string | undefined;\n};\n\nexport function toIdValue(\n  idConfig: string | IdConfig,\n  generated = false,\n): IdValue {\n  return {\n    type: 'id',\n    generated,\n    ...(typeof idConfig === 'string'\n      ? { id: idConfig, typename: undefined }\n      : idConfig),\n  };\n}\n\nexport function isJsonValue(jsonObject: StoreValue): jsonObject is JsonValue {\n  return (\n    jsonObject != null &&\n    typeof jsonObject === 'object' &&\n    (jsonObject as IdValue | JsonValue).type === 'json'\n  );\n}\n\nfunction defaultValueFromVariable(node: VariableNode) {\n  throw new InvariantError(`Variable nodes are not supported by valueFromNode`);\n}\n\nexport type VariableValue = (node: VariableNode) => any;\n\n/**\n * Evaluate a ValueNode and yield its value in its natural JS form.\n */\nexport function valueFromNode(\n  node: ValueNode,\n  onVariable: VariableValue = defaultValueFromVariable,\n): any {\n  switch (node.kind) {\n    case 'Variable':\n      return onVariable(node);\n    case 'NullValue':\n      return null;\n    case 'IntValue':\n      return parseInt(node.value, 10);\n    case 'FloatValue':\n      return parseFloat(node.value);\n    case 'ListValue':\n      return node.values.map(v => valueFromNode(v, onVariable));\n    case 'ObjectValue': {\n      const value: { [key: string]: any } = {};\n      for (const field of node.fields) {\n        value[field.name.value] = valueFromNode(field.value, onVariable);\n      }\n      return value;\n    }\n    default:\n      return node.value;\n  }\n}\n","// Provides the methods that allow QueryManager to handle the `skip` and\n// `include` directives within GraphQL.\nimport {\n  FieldNode,\n  SelectionNode,\n  VariableNode,\n  BooleanValueNode,\n  DirectiveNode,\n  DocumentNode,\n  ArgumentNode,\n  ValueNode,\n} from 'graphql';\n\nimport { visit } from 'graphql/language/visitor';\n\nimport { invariant } from 'ts-invariant';\n\nimport { argumentsObjectFromField } from './storeUtils';\n\nexport type DirectiveInfo = {\n  [fieldName: string]: { [argName: string]: any };\n};\n\nexport function getDirectiveInfoFromField(\n  field: FieldNode,\n  variables: Object,\n): DirectiveInfo {\n  if (field.directives && field.directives.length) {\n    const directiveObj: DirectiveInfo = {};\n    field.directives.forEach((directive: DirectiveNode) => {\n      directiveObj[directive.name.value] = argumentsObjectFromField(\n        directive,\n        variables,\n      );\n    });\n    return directiveObj;\n  }\n  return null;\n}\n\nexport function shouldInclude(\n  selection: SelectionNode,\n  variables: { [name: string]: any } = {},\n): boolean {\n  return getInclusionDirectives(\n    selection.directives,\n  ).every(({ directive, ifArgument }) => {\n    let evaledValue: boolean = false;\n    if (ifArgument.value.kind === 'Variable') {\n      evaledValue = variables[(ifArgument.value as VariableNode).name.value];\n      invariant(\n        evaledValue !== void 0,\n        `Invalid variable referenced in @${directive.name.value} directive.`,\n      );\n    } else {\n      evaledValue = (ifArgument.value as BooleanValueNode).value;\n    }\n    return directive.name.value === 'skip' ? !evaledValue : evaledValue;\n  });\n}\n\nexport function getDirectiveNames(doc: DocumentNode) {\n  const names: string[] = [];\n\n  visit(doc, {\n    Directive(node) {\n      names.push(node.name.value);\n    },\n  });\n\n  return names;\n}\n\nexport function hasDirectives(names: string[], doc: DocumentNode) {\n  return getDirectiveNames(doc).some(\n    (name: string) => names.indexOf(name) > -1,\n  );\n}\n\nexport function hasClientExports(document: DocumentNode) {\n  return (\n    document &&\n    hasDirectives(['client'], document) &&\n    hasDirectives(['export'], document)\n  );\n}\n\nexport type InclusionDirectives = Array<{\n  directive: DirectiveNode;\n  ifArgument: ArgumentNode;\n}>;\n\nfunction isInclusionDirective({ name: { value } }: DirectiveNode): boolean {\n  return value === 'skip' || value === 'include';\n}\n\nexport function getInclusionDirectives(\n  directives: ReadonlyArray<DirectiveNode>,\n): InclusionDirectives {\n  return directives ? directives.filter(isInclusionDirective).map(directive => {\n    const directiveArguments = directive.arguments;\n    const directiveName = directive.name.value;\n\n    invariant(\n      directiveArguments && directiveArguments.length === 1,\n      `Incorrect number of arguments for the @${directiveName} directive.`,\n    );\n\n    const ifArgument = directiveArguments[0];\n    invariant(\n      ifArgument.name && ifArgument.name.value === 'if',\n      `Invalid argument for the @${directiveName} directive.`,\n    );\n\n    const ifValue: ValueNode = ifArgument.value;\n\n    // means it has to be a variable value if this is a valid @skip or @include directive\n    invariant(\n      ifValue &&\n        (ifValue.kind === 'Variable' || ifValue.kind === 'BooleanValue'),\n      `Argument for the @${directiveName} directive must be a variable or a boolean value.`,\n    );\n\n    return { directive, ifArgument };\n  }) : [];\n}\n\n","import { DocumentNode, FragmentDefinitionNode } from 'graphql';\nimport { invariant, InvariantError } from 'ts-invariant';\n\n/**\n * Returns a query document which adds a single query operation that only\n * spreads the target fragment inside of it.\n *\n * So for example a document of:\n *\n * ```graphql\n * fragment foo on Foo { a b c }\n * ```\n *\n * Turns into:\n *\n * ```graphql\n * { ...foo }\n *\n * fragment foo on Foo { a b c }\n * ```\n *\n * The target fragment will either be the only fragment in the document, or a\n * fragment specified by the provided `fragmentName`. If there is more than one\n * fragment, but a `fragmentName` was not defined then an error will be thrown.\n */\nexport function getFragmentQueryDocument(\n  document: DocumentNode,\n  fragmentName?: string,\n): DocumentNode {\n  let actualFragmentName = fragmentName;\n\n  // Build an array of all our fragment definitions that will be used for\n  // validations. We also do some validations on the other definitions in the\n  // document while building this list.\n  const fragments: Array<FragmentDefinitionNode> = [];\n  document.definitions.forEach(definition => {\n    // Throw an error if we encounter an operation definition because we will\n    // define our own operation definition later on.\n    if (definition.kind === 'OperationDefinition') {\n      throw new InvariantError(\n        `Found a ${definition.operation} operation${\n          definition.name ? ` named '${definition.name.value}'` : ''\n        }. ` +\n          'No operations are allowed when using a fragment as a query. Only fragments are allowed.',\n      );\n    }\n    // Add our definition to the fragments array if it is a fragment\n    // definition.\n    if (definition.kind === 'FragmentDefinition') {\n      fragments.push(definition);\n    }\n  });\n\n  // If the user did not give us a fragment name then let us try to get a\n  // name from a single fragment in the definition.\n  if (typeof actualFragmentName === 'undefined') {\n    invariant(\n      fragments.length === 1,\n      `Found ${\n        fragments.length\n      } fragments. \\`fragmentName\\` must be provided when there is not exactly 1 fragment.`,\n    );\n    actualFragmentName = fragments[0].name.value;\n  }\n\n  // Generate a query document with an operation that simply spreads the\n  // fragment inside of it.\n  const query: DocumentNode = {\n    ...document,\n    definitions: [\n      {\n        kind: 'OperationDefinition',\n        operation: 'query',\n        selectionSet: {\n          kind: 'SelectionSet',\n          selections: [\n            {\n              kind: 'FragmentSpread',\n              name: {\n                kind: 'Name',\n                value: actualFragmentName,\n              },\n            },\n          ],\n        },\n      },\n      ...document.definitions,\n    ],\n  };\n\n  return query;\n}\n","/**\n * Adds the properties of one or more source objects to a target object. Works exactly like\n * `Object.assign`, but as a utility to maintain support for IE 11.\n *\n * @see https://github.com/apollostack/apollo-client/pull/1009\n */\nexport function assign<A, B>(a: A, b: B): A & B;\nexport function assign<A, B, C>(a: A, b: B, c: C): A & B & C;\nexport function assign<A, B, C, D>(a: A, b: B, c: C, d: D): A & B & C & D;\nexport function assign<A, B, C, D, E>(\n  a: A,\n  b: B,\n  c: C,\n  d: D,\n  e: E,\n): A & B & C & D & E;\nexport function assign(target: any, ...sources: Array<any>): any;\nexport function assign(\n  target: { [key: string]: any },\n  ...sources: Array<{ [key: string]: any }>\n): { [key: string]: any } {\n  sources.forEach(source => {\n    if (typeof source === 'undefined' || source === null) {\n      return;\n    }\n    Object.keys(source).forEach(key => {\n      target[key] = source[key];\n    });\n  });\n  return target;\n}\n","import {\n  DocumentNode,\n  OperationDefinitionNode,\n  FragmentDefinitionNode,\n  ValueNode,\n} from 'graphql';\n\nimport { invariant, InvariantError } from 'ts-invariant';\n\nimport { assign } from './util/assign';\n\nimport { valueToObjectRepresentation, JsonValue } from './storeUtils';\n\nexport function getMutationDefinition(\n  doc: DocumentNode,\n): OperationDefinitionNode {\n  checkDocument(doc);\n\n  let mutationDef: OperationDefinitionNode | null = doc.definitions.filter(\n    definition =>\n      definition.kind === 'OperationDefinition' &&\n      definition.operation === 'mutation',\n  )[0] as OperationDefinitionNode;\n\n  invariant(mutationDef, 'Must contain a mutation definition.');\n\n  return mutationDef;\n}\n\n// Checks the document for errors and throws an exception if there is an error.\nexport function checkDocument(doc: DocumentNode) {\n  invariant(\n    doc && doc.kind === 'Document',\n    `Expecting a parsed GraphQL document. Perhaps you need to wrap the query \\\nstring in a \"gql\" tag? http://docs.apollostack.com/apollo-client/core.html#gql`,\n  );\n\n  const operations = doc.definitions\n    .filter(d => d.kind !== 'FragmentDefinition')\n    .map(definition => {\n      if (definition.kind !== 'OperationDefinition') {\n        throw new InvariantError(\n          `Schema type definitions not allowed in queries. Found: \"${\n            definition.kind\n          }\"`,\n        );\n      }\n      return definition;\n    });\n\n  invariant(\n    operations.length <= 1,\n    `Ambiguous GraphQL document: contains ${operations.length} operations`,\n  );\n\n  return doc;\n}\n\nexport function getOperationDefinition(\n  doc: DocumentNode,\n): OperationDefinitionNode | undefined {\n  checkDocument(doc);\n  return doc.definitions.filter(\n    definition => definition.kind === 'OperationDefinition',\n  )[0] as OperationDefinitionNode;\n}\n\nexport function getOperationDefinitionOrDie(\n  document: DocumentNode,\n): OperationDefinitionNode {\n  const def = getOperationDefinition(document);\n  invariant(def, `GraphQL document is missing an operation`);\n  return def;\n}\n\nexport function getOperationName(doc: DocumentNode): string | null {\n  return (\n    doc.definitions\n      .filter(\n        definition =>\n          definition.kind === 'OperationDefinition' && definition.name,\n      )\n      .map((x: OperationDefinitionNode) => x.name.value)[0] || null\n  );\n}\n\n// Returns the FragmentDefinitions from a particular document as an array\nexport function getFragmentDefinitions(\n  doc: DocumentNode,\n): FragmentDefinitionNode[] {\n  return doc.definitions.filter(\n    definition => definition.kind === 'FragmentDefinition',\n  ) as FragmentDefinitionNode[];\n}\n\nexport function getQueryDefinition(doc: DocumentNode): OperationDefinitionNode {\n  const queryDef = getOperationDefinition(doc) as OperationDefinitionNode;\n\n  invariant(\n    queryDef && queryDef.operation === 'query',\n    'Must contain a query definition.',\n  );\n\n  return queryDef;\n}\n\nexport function getFragmentDefinition(\n  doc: DocumentNode,\n): FragmentDefinitionNode {\n  invariant(\n    doc.kind === 'Document',\n    `Expecting a parsed GraphQL document. Perhaps you need to wrap the query \\\nstring in a \"gql\" tag? http://docs.apollostack.com/apollo-client/core.html#gql`,\n  );\n\n  invariant(\n    doc.definitions.length <= 1,\n    'Fragment must have exactly one definition.',\n  );\n\n  const fragmentDef = doc.definitions[0] as FragmentDefinitionNode;\n\n  invariant(\n    fragmentDef.kind === 'FragmentDefinition',\n    'Must be a fragment definition.',\n  );\n\n  return fragmentDef as FragmentDefinitionNode;\n}\n\n/**\n * Returns the first operation definition found in this document.\n * If no operation definition is found, the first fragment definition will be returned.\n * If no definitions are found, an error will be thrown.\n */\nexport function getMainDefinition(\n  queryDoc: DocumentNode,\n): OperationDefinitionNode | FragmentDefinitionNode {\n  checkDocument(queryDoc);\n\n  let fragmentDefinition;\n\n  for (let definition of queryDoc.definitions) {\n    if (definition.kind === 'OperationDefinition') {\n      const operation = (definition as OperationDefinitionNode).operation;\n      if (\n        operation === 'query' ||\n        operation === 'mutation' ||\n        operation === 'subscription'\n      ) {\n        return definition as OperationDefinitionNode;\n      }\n    }\n    if (definition.kind === 'FragmentDefinition' && !fragmentDefinition) {\n      // we do this because we want to allow multiple fragment definitions\n      // to precede an operation definition.\n      fragmentDefinition = definition as FragmentDefinitionNode;\n    }\n  }\n\n  if (fragmentDefinition) {\n    return fragmentDefinition;\n  }\n\n  throw new InvariantError(\n    'Expected a parsed GraphQL query with a query, mutation, subscription, or a fragment.',\n  );\n}\n\n/**\n * This is an interface that describes a map from fragment names to fragment definitions.\n */\nexport interface FragmentMap {\n  [fragmentName: string]: FragmentDefinitionNode;\n}\n\n// Utility function that takes a list of fragment definitions and makes a hash out of them\n// that maps the name of the fragment to the fragment definition.\nexport function createFragmentMap(\n  fragments: FragmentDefinitionNode[] = [],\n): FragmentMap {\n  const symTable: FragmentMap = {};\n  fragments.forEach(fragment => {\n    symTable[fragment.name.value] = fragment;\n  });\n\n  return symTable;\n}\n\nexport function getDefaultValues(\n  definition: OperationDefinitionNode | undefined,\n): { [key: string]: JsonValue } {\n  if (\n    definition &&\n    definition.variableDefinitions &&\n    definition.variableDefinitions.length\n  ) {\n    const defaultValues = definition.variableDefinitions\n      .filter(({ defaultValue }) => defaultValue)\n      .map(\n        ({ variable, defaultValue }): { [key: string]: JsonValue } => {\n          const defaultValueObj: { [key: string]: JsonValue } = {};\n          valueToObjectRepresentation(\n            defaultValueObj,\n            variable.name,\n            defaultValue as ValueNode,\n          );\n\n          return defaultValueObj;\n        },\n      );\n\n    return assign({}, ...defaultValues);\n  }\n\n  return {};\n}\n\n/**\n * Returns the names of all variables declared by the operation.\n */\nexport function variablesInOperation(\n  operation: OperationDefinitionNode,\n): Set<string> {\n  const names = new Set<string>();\n  if (operation.variableDefinitions) {\n    for (const definition of operation.variableDefinitions) {\n      names.add(definition.variable.name.value);\n    }\n  }\n\n  return names;\n}\n","export function filterInPlace<T>(\n  array: T[],\n  test: (elem: T) => boolean,\n  context?: any,\n): T[] {\n  let target = 0;\n  array.forEach(function (elem, i) {\n    if (test.call(this, elem, i, array)) {\n      array[target++] = elem;\n    }\n  }, context);\n  array.length = target;\n  return array;\n}\n","import {\n  DocumentNode,\n  SelectionNode,\n  SelectionSetNode,\n  OperationDefinitionNode,\n  FieldNode,\n  DirectiveNode,\n  FragmentDefinitionNode,\n  ArgumentNode,\n  FragmentSpreadNode,\n  VariableDefinitionNode,\n  VariableNode,\n} from 'graphql';\nimport { visit } from 'graphql/language/visitor';\n\nimport {\n  checkDocument,\n  getOperationDefinition,\n  getFragmentDefinition,\n  getFragmentDefinitions,\n  createFragmentMap,\n  FragmentMap,\n  getMainDefinition,\n} from './getFromAST';\nimport { filterInPlace } from './util/filterInPlace';\nimport { invariant } from 'ts-invariant';\nimport { isField, isInlineFragment } from './storeUtils';\n\nexport type RemoveNodeConfig<N> = {\n  name?: string;\n  test?: (node: N) => boolean;\n  remove?: boolean;\n};\n\nexport type GetNodeConfig<N> = {\n  name?: string;\n  test?: (node: N) => boolean;\n};\n\nexport type RemoveDirectiveConfig = RemoveNodeConfig<DirectiveNode>;\nexport type GetDirectiveConfig = GetNodeConfig<DirectiveNode>;\nexport type RemoveArgumentsConfig = RemoveNodeConfig<ArgumentNode>;\nexport type GetFragmentSpreadConfig = GetNodeConfig<FragmentSpreadNode>;\nexport type RemoveFragmentSpreadConfig = RemoveNodeConfig<FragmentSpreadNode>;\nexport type RemoveFragmentDefinitionConfig = RemoveNodeConfig<\n  FragmentDefinitionNode\n>;\nexport type RemoveVariableDefinitionConfig = RemoveNodeConfig<\n  VariableDefinitionNode\n>;\n\nconst TYPENAME_FIELD: FieldNode = {\n  kind: 'Field',\n  name: {\n    kind: 'Name',\n    value: '__typename',\n  },\n};\n\nfunction isEmpty(\n  op: OperationDefinitionNode | FragmentDefinitionNode,\n  fragments: FragmentMap,\n): boolean {\n  return op.selectionSet.selections.every(\n    selection =>\n      selection.kind === 'FragmentSpread' &&\n      isEmpty(fragments[selection.name.value], fragments),\n  );\n}\n\nfunction nullIfDocIsEmpty(doc: DocumentNode) {\n  return isEmpty(\n    getOperationDefinition(doc) || getFragmentDefinition(doc),\n    createFragmentMap(getFragmentDefinitions(doc)),\n  )\n    ? null\n    : doc;\n}\n\nfunction getDirectiveMatcher(\n  directives: (RemoveDirectiveConfig | GetDirectiveConfig)[],\n) {\n  return function directiveMatcher(directive: DirectiveNode) {\n    return directives.some(\n      dir =>\n        (dir.name && dir.name === directive.name.value) ||\n        (dir.test && dir.test(directive)),\n    );\n  };\n}\n\nexport function removeDirectivesFromDocument(\n  directives: RemoveDirectiveConfig[],\n  doc: DocumentNode,\n): DocumentNode | null {\n  const variablesInUse: Record<string, boolean> = Object.create(null);\n  let variablesToRemove: RemoveArgumentsConfig[] = [];\n\n  const fragmentSpreadsInUse: Record<string, boolean> = Object.create(null);\n  let fragmentSpreadsToRemove: RemoveFragmentSpreadConfig[] = [];\n\n  let modifiedDoc = nullIfDocIsEmpty(\n    visit(doc, {\n      Variable: {\n        enter(node, _key, parent) {\n          // Store each variable that's referenced as part of an argument\n          // (excluding operation definition variables), so we know which\n          // variables are being used. If we later want to remove a variable\n          // we'll fist check to see if it's being used, before continuing with\n          // the removal.\n          if (\n            (parent as VariableDefinitionNode).kind !== 'VariableDefinition'\n          ) {\n            variablesInUse[node.name.value] = true;\n          }\n        },\n      },\n\n      Field: {\n        enter(node) {\n          if (directives && node.directives) {\n            // If `remove` is set to true for a directive, and a directive match\n            // is found for a field, remove the field as well.\n            const shouldRemoveField = directives.some(\n              directive => directive.remove,\n            );\n\n            if (\n              shouldRemoveField &&\n              node.directives &&\n              node.directives.some(getDirectiveMatcher(directives))\n            ) {\n              if (node.arguments) {\n                // Store field argument variables so they can be removed\n                // from the operation definition.\n                node.arguments.forEach(arg => {\n                  if (arg.value.kind === 'Variable') {\n                    variablesToRemove.push({\n                      name: (arg.value as VariableNode).name.value,\n                    });\n                  }\n                });\n              }\n\n              if (node.selectionSet) {\n                // Store fragment spread names so they can be removed from the\n                // docuemnt.\n                getAllFragmentSpreadsFromSelectionSet(node.selectionSet).forEach(\n                  frag => {\n                    fragmentSpreadsToRemove.push({\n                      name: frag.name.value,\n                    });\n                  },\n                );\n              }\n\n              // Remove the field.\n              return null;\n            }\n          }\n        },\n      },\n\n      FragmentSpread: {\n        enter(node) {\n          // Keep track of referenced fragment spreads. This is used to\n          // determine if top level fragment definitions should be removed.\n          fragmentSpreadsInUse[node.name.value] = true;\n        },\n      },\n\n      Directive: {\n        enter(node) {\n          // If a matching directive is found, remove it.\n          if (getDirectiveMatcher(directives)(node)) {\n            return null;\n          }\n        },\n      },\n    }),\n  );\n\n  // If we've removed fields with arguments, make sure the associated\n  // variables are also removed from the rest of the document, as long as they\n  // aren't being used elsewhere.\n  if (\n    modifiedDoc &&\n    filterInPlace(variablesToRemove, v => !variablesInUse[v.name]).length\n  ) {\n    modifiedDoc = removeArgumentsFromDocument(variablesToRemove, modifiedDoc);\n  }\n\n  // If we've removed selection sets with fragment spreads, make sure the\n  // associated fragment definitions are also removed from the rest of the\n  // document, as long as they aren't being used elsewhere.\n  if (\n    modifiedDoc &&\n    filterInPlace(fragmentSpreadsToRemove, fs => !fragmentSpreadsInUse[fs.name])\n      .length\n  ) {\n    modifiedDoc = removeFragmentSpreadFromDocument(\n      fragmentSpreadsToRemove,\n      modifiedDoc,\n    );\n  }\n\n  return modifiedDoc;\n}\n\nexport function addTypenameToDocument(doc: DocumentNode): DocumentNode {\n  return visit(checkDocument(doc), {\n    SelectionSet: {\n      enter(node, _key, parent) {\n        // Don't add __typename to OperationDefinitions.\n        if (\n          parent &&\n          (parent as OperationDefinitionNode).kind === 'OperationDefinition'\n        ) {\n          return;\n        }\n\n        // No changes if no selections.\n        const { selections } = node;\n        if (!selections) {\n          return;\n        }\n\n        // If selections already have a __typename, or are part of an\n        // introspection query, do nothing.\n        const skip = selections.some(selection => {\n          return (\n            isField(selection) &&\n            (selection.name.value === '__typename' ||\n              selection.name.value.lastIndexOf('__', 0) === 0)\n          );\n        });\n        if (skip) {\n          return;\n        }\n\n        // If this SelectionSet is @export-ed as an input variable, it should\n        // not have a __typename field (see issue #4691).\n        const field = parent as FieldNode;\n        if (\n          isField(field) &&\n          field.directives &&\n          field.directives.some(d => d.name.value === 'export')\n        ) {\n          return;\n        }\n\n        // Create and return a new SelectionSet with a __typename Field.\n        return {\n          ...node,\n          selections: [...selections, TYPENAME_FIELD],\n        };\n      },\n    },\n  });\n}\n\nconst connectionRemoveConfig = {\n  test: (directive: DirectiveNode) => {\n    const willRemove = directive.name.value === 'connection';\n    if (willRemove) {\n      if (\n        !directive.arguments ||\n        !directive.arguments.some(arg => arg.name.value === 'key')\n      ) {\n        invariant.warn(\n          'Removing an @connection directive even though it does not have a key. ' +\n            'You may want to use the key parameter to specify a store key.',\n        );\n      }\n    }\n\n    return willRemove;\n  },\n};\n\nexport function removeConnectionDirectiveFromDocument(doc: DocumentNode) {\n  return removeDirectivesFromDocument(\n    [connectionRemoveConfig],\n    checkDocument(doc),\n  );\n}\n\nfunction hasDirectivesInSelectionSet(\n  directives: GetDirectiveConfig[],\n  selectionSet: SelectionSetNode,\n  nestedCheck = true,\n): boolean {\n  return (\n    selectionSet &&\n    selectionSet.selections &&\n    selectionSet.selections.some(selection =>\n      hasDirectivesInSelection(directives, selection, nestedCheck),\n    )\n  );\n}\n\nfunction hasDirectivesInSelection(\n  directives: GetDirectiveConfig[],\n  selection: SelectionNode,\n  nestedCheck = true,\n): boolean {\n  if (!isField(selection)) {\n    return true;\n  }\n\n  if (!selection.directives) {\n    return false;\n  }\n\n  return (\n    selection.directives.some(getDirectiveMatcher(directives)) ||\n    (nestedCheck &&\n      hasDirectivesInSelectionSet(\n        directives,\n        selection.selectionSet,\n        nestedCheck,\n      ))\n  );\n}\n\nexport function getDirectivesFromDocument(\n  directives: GetDirectiveConfig[],\n  doc: DocumentNode,\n): DocumentNode {\n  checkDocument(doc);\n\n  let parentPath: string;\n\n  return nullIfDocIsEmpty(\n    visit(doc, {\n      SelectionSet: {\n        enter(node, _key, _parent, path) {\n          const currentPath = path.join('-');\n\n          if (\n            !parentPath ||\n            currentPath === parentPath ||\n            !currentPath.startsWith(parentPath)\n          ) {\n            if (node.selections) {\n              const selectionsWithDirectives = node.selections.filter(\n                selection => hasDirectivesInSelection(directives, selection),\n              );\n\n              if (hasDirectivesInSelectionSet(directives, node, false)) {\n                parentPath = currentPath;\n              }\n\n              return {\n                ...node,\n                selections: selectionsWithDirectives,\n              };\n            } else {\n              return null;\n            }\n          }\n        },\n      },\n    }),\n  );\n}\n\nfunction getArgumentMatcher(config: RemoveArgumentsConfig[]) {\n  return function argumentMatcher(argument: ArgumentNode) {\n    return config.some(\n      (aConfig: RemoveArgumentsConfig) =>\n        argument.value &&\n        argument.value.kind === 'Variable' &&\n        argument.value.name &&\n        (aConfig.name === argument.value.name.value ||\n          (aConfig.test && aConfig.test(argument))),\n    );\n  };\n}\n\nexport function removeArgumentsFromDocument(\n  config: RemoveArgumentsConfig[],\n  doc: DocumentNode,\n): DocumentNode {\n  const argMatcher = getArgumentMatcher(config);\n\n  return nullIfDocIsEmpty(\n    visit(doc, {\n      OperationDefinition: {\n        enter(node) {\n          return {\n            ...node,\n            // Remove matching top level variables definitions.\n            variableDefinitions: node.variableDefinitions.filter(\n              varDef =>\n                !config.some(arg => arg.name === varDef.variable.name.value),\n            ),\n          };\n        },\n      },\n\n      Field: {\n        enter(node) {\n          // If `remove` is set to true for an argument, and an argument match\n          // is found for a field, remove the field as well.\n          const shouldRemoveField = config.some(argConfig => argConfig.remove);\n\n          if (shouldRemoveField) {\n            let argMatchCount = 0;\n            node.arguments.forEach(arg => {\n              if (argMatcher(arg)) {\n                argMatchCount += 1;\n              }\n            });\n            if (argMatchCount === 1) {\n              return null;\n            }\n          }\n        },\n      },\n\n      Argument: {\n        enter(node) {\n          // Remove all matching arguments.\n          if (argMatcher(node)) {\n            return null;\n          }\n        },\n      },\n    }),\n  );\n}\n\nexport function removeFragmentSpreadFromDocument(\n  config: RemoveFragmentSpreadConfig[],\n  doc: DocumentNode,\n): DocumentNode {\n  function enter(\n    node: FragmentSpreadNode | FragmentDefinitionNode,\n  ): null | void {\n    if (config.some(def => def.name === node.name.value)) {\n      return null;\n    }\n  }\n\n  return nullIfDocIsEmpty(\n    visit(doc, {\n      FragmentSpread: { enter },\n      FragmentDefinition: { enter },\n    }),\n  );\n}\n\nfunction getAllFragmentSpreadsFromSelectionSet(\n  selectionSet: SelectionSetNode,\n): FragmentSpreadNode[] {\n  const allFragments: FragmentSpreadNode[] = [];\n\n  selectionSet.selections.forEach(selection => {\n    if (\n      (isField(selection) || isInlineFragment(selection)) &&\n      selection.selectionSet\n    ) {\n      getAllFragmentSpreadsFromSelectionSet(selection.selectionSet).forEach(\n        frag => allFragments.push(frag),\n      );\n    } else if (selection.kind === 'FragmentSpread') {\n      allFragments.push(selection);\n    }\n  });\n\n  return allFragments;\n}\n\n// If the incoming document is a query, return it as is. Otherwise, build a\n// new document containing a query operation based on the selection set\n// of the previous main operation.\nexport function buildQueryFromSelectionSet(\n  document: DocumentNode,\n): DocumentNode {\n  const definition = getMainDefinition(document);\n  const definitionOperation = (<OperationDefinitionNode>definition).operation;\n\n  if (definitionOperation === 'query') {\n    // Already a query, so return the existing document.\n    return document;\n  }\n\n  // Build a new query using the selection set of the main operation.\n  const modifiedDoc = visit(document, {\n    OperationDefinition: {\n      enter(node) {\n        return {\n          ...node,\n          operation: 'query',\n        };\n      },\n    },\n  });\n  return modifiedDoc;\n}\n\n// Remove fields / selection sets that include an @client directive.\nexport function removeClientSetsFromDocument(\n  document: DocumentNode,\n): DocumentNode | null {\n  checkDocument(document);\n\n  let modifiedDoc = removeDirectivesFromDocument(\n    [\n      {\n        test: (directive: DirectiveNode) => directive.name.value === 'client',\n        remove: true,\n      },\n    ],\n    document,\n  );\n\n  // After a fragment definition has had its @client related document\n  // sets removed, if the only field it has left is a __typename field,\n  // remove the entire fragment operation to prevent it from being fired\n  // on the server.\n  if (modifiedDoc) {\n    modifiedDoc = visit(modifiedDoc, {\n      FragmentDefinition: {\n        enter(node) {\n          if (node.selectionSet) {\n            const isTypenameOnly = node.selectionSet.selections.every(\n              selection =>\n                isField(selection) && selection.name.value === '__typename',\n            );\n            if (isTypenameOnly) {\n              return null;\n            }\n          }\n        },\n      },\n    });\n  }\n\n  return modifiedDoc;\n}\n","export const canUseWeakMap = typeof WeakMap === 'function' && !(\n  typeof navigator === 'object' &&\n  navigator.product === 'ReactNative'\n);\n","const { toString } = Object.prototype;\n\n/**\n * Deeply clones a value to create a new instance.\n */\nexport function cloneDeep<T>(value: T): T {\n  return cloneDeepHelper(value, new Map());\n}\n\nfunction cloneDeepHelper<T>(val: T, seen: Map<any, any>): T {\n  switch (toString.call(val)) {\n  case \"[object Array]\": {\n    if (seen.has(val)) return seen.get(val);\n    const copy: T & any[] = (val as any).slice(0);\n    seen.set(val, copy);\n    copy.forEach(function (child, i) {\n      copy[i] = cloneDeepHelper(child, seen);\n    });\n    return copy;\n  }\n\n  case \"[object Object]\": {\n    if (seen.has(val)) return seen.get(val);\n    // High fidelity polyfills of Object.create and Object.getPrototypeOf are\n    // possible in all JS environments, so we will assume they exist/work.\n    const copy = Object.create(Object.getPrototypeOf(val));\n    seen.set(val, copy);\n    Object.keys(val).forEach(key => {\n      copy[key] = cloneDeepHelper((val as any)[key], seen);\n    });\n    return copy;\n  }\n\n  default:\n    return val;\n  }\n}\n","export function getEnv(): string | undefined {\n  if (typeof process !== 'undefined' && process.env.NODE_ENV) {\n    return process.env.NODE_ENV;\n  }\n\n  // default environment\n  return 'development';\n}\n\nexport function isEnv(env: string): boolean {\n  return getEnv() === env;\n}\n\nexport function isProduction(): boolean {\n  return isEnv('production') === true;\n}\n\nexport function isDevelopment(): boolean {\n  return isEnv('development') === true;\n}\n\nexport function isTest(): boolean {\n  return isEnv('test') === true;\n}\n","import { ExecutionResult } from 'graphql';\n\nexport function tryFunctionOrLogError(f: Function) {\n  try {\n    return f();\n  } catch (e) {\n    if (console.error) {\n      console.error(e);\n    }\n  }\n}\n\nexport function graphQLResultHasError(result: ExecutionResult) {\n  return result.errors && result.errors.length;\n}\n","import { isDevelopment, isTest } from './environment';\n\n// Taken (mostly) from https://github.com/substack/deep-freeze to avoid\n// import hassles with rollup.\nfunction deepFreeze(o: any) {\n  Object.freeze(o);\n\n  Object.getOwnPropertyNames(o).forEach(function(prop) {\n    if (\n      o[prop] !== null &&\n      (typeof o[prop] === 'object' || typeof o[prop] === 'function') &&\n      !Object.isFrozen(o[prop])\n    ) {\n      deepFreeze(o[prop]);\n    }\n  });\n\n  return o;\n}\n\nexport function maybeDeepFreeze(obj: any) {\n  if (isDevelopment() || isTest()) {\n    // Polyfilled Symbols potentially cause infinite / very deep recursion while deep freezing\n    // which is known to crash IE11 (https://github.com/apollographql/apollo-client/issues/3043).\n    const symbolIsPolyfilled =\n      typeof Symbol === 'function' && typeof Symbol('') === 'string';\n\n    if (!symbolIsPolyfilled) {\n      return deepFreeze(obj);\n    }\n  }\n  return obj;\n}\n","const { hasOwnProperty } = Object.prototype;\n\n// These mergeDeep and mergeDeepArray utilities merge any number of objects\n// together, sharing as much memory as possible with the source objects, while\n// remaining careful to avoid modifying any source objects.\n\n// Logically, the return type of mergeDeep should be the intersection of\n// all the argument types. The binary call signature is by far the most\n// common, but we support 0- through 5-ary as well. After that, the\n// resulting type is just the inferred array element type. Note to nerds:\n// there is a more clever way of doing this that converts the tuple type\n// first to a union type (easy enough: T[number]) and then converts the\n// union to an intersection type using distributive conditional type\n// inference, but that approach has several fatal flaws (boolean becomes\n// true & false, and the inferred type ends up as unknown in many cases),\n// in addition to being nearly impossible to explain/understand.\nexport type TupleToIntersection<T extends any[]> =\n  T extends [infer A] ? A :\n  T extends [infer A, infer B] ? A & B :\n  T extends [infer A, infer B, infer C] ? A & B & C :\n  T extends [infer A, infer B, infer C, infer D] ? A & B & C & D :\n  T extends [infer A, infer B, infer C, infer D, infer E] ? A & B & C & D & E :\n  T extends (infer U)[] ? U : any;\n\nexport function mergeDeep<T extends any[]>(\n  ...sources: T\n): TupleToIntersection<T> {\n  return mergeDeepArray(sources);\n}\n\n// In almost any situation where you could succeed in getting the\n// TypeScript compiler to infer a tuple type for the sources array, you\n// could just use mergeDeep instead of mergeDeepArray, so instead of\n// trying to convert T[] to an intersection type we just infer the array\n// element type, which works perfectly when the sources array has a\n// consistent element type.\nexport function mergeDeepArray<T>(sources: T[]): T {\n  let target = sources[0] || {} as T;\n  const count = sources.length;\n  if (count > 1) {\n    const pastCopies: any[] = [];\n    target = shallowCopyForMerge(target, pastCopies);\n    for (let i = 1; i < count; ++i) {\n      target = mergeHelper(target, sources[i], pastCopies);\n    }\n  }\n  return target;\n}\n\nfunction isObject(obj: any): obj is Record<string | number, any> {\n  return obj !== null && typeof obj === 'object';\n}\n\nfunction mergeHelper(\n  target: any,\n  source: any,\n  pastCopies: any[],\n) {\n  if (isObject(source) && isObject(target)) {\n    // In case the target has been frozen, make an extensible copy so that\n    // we can merge properties into the copy.\n    if (Object.isExtensible && !Object.isExtensible(target)) {\n      target = shallowCopyForMerge(target, pastCopies);\n    }\n\n    Object.keys(source).forEach(sourceKey => {\n      const sourceValue = source[sourceKey];\n      if (hasOwnProperty.call(target, sourceKey)) {\n        const targetValue = target[sourceKey];\n        if (sourceValue !== targetValue) {\n          // When there is a key collision, we need to make a shallow copy of\n          // target[sourceKey] so the merge does not modify any source objects.\n          // To avoid making unnecessary copies, we use a simple array to track\n          // past copies, since it's safe to modify copies created earlier in\n          // the merge. We use an array for pastCopies instead of a Map or Set,\n          // since the number of copies should be relatively small, and some\n          // Map/Set polyfills modify their keys.\n          target[sourceKey] = mergeHelper(\n            shallowCopyForMerge(targetValue, pastCopies),\n            sourceValue,\n            pastCopies,\n          );\n        }\n      } else {\n        // If there is no collision, the target can safely share memory with\n        // the source, and the recursion can terminate here.\n        target[sourceKey] = sourceValue;\n      }\n    });\n\n    return target;\n  }\n\n  // If source (or target) is not an object, let source replace target.\n  return source;\n}\n\nfunction shallowCopyForMerge<T>(value: T, pastCopies: any[]): T {\n  if (\n    value !== null &&\n    typeof value === 'object' &&\n    pastCopies.indexOf(value) < 0\n  ) {\n    if (Array.isArray(value)) {\n      value = (value as any).slice(0);\n    } else {\n      value = {\n        __proto__: Object.getPrototypeOf(value),\n        ...value,\n      };\n    }\n    pastCopies.push(value);\n  }\n  return value;\n}\n","import { isProduction, isTest } from './environment';\n\nconst haveWarned = Object.create({});\n\n/**\n * Print a warning only once in development.\n * In production no warnings are printed.\n * In test all warnings are printed.\n *\n * @param msg The warning message\n * @param type warn or error (will call console.warn or console.error)\n */\nexport function warnOnceInDevelopment(msg: string, type = 'warn') {\n  if (!isProduction() && !haveWarned[msg]) {\n    if (!isTest()) {\n      haveWarned[msg] = true;\n    }\n    if (type === 'error') {\n      console.error(msg);\n    } else {\n      console.warn(msg);\n    }\n  }\n}\n","/**\n * In order to make assertions easier, this function strips `symbol`'s from\n * the incoming data.\n *\n * This can be handy when running tests against `apollo-client` for example,\n * since it adds `symbol`'s to the data in the store. Jest's `toEqual`\n * function now covers `symbol`'s (https://github.com/facebook/jest/pull/3437),\n * which means all test data used in a `toEqual` comparison would also have to\n * include `symbol`'s, to pass. By stripping `symbol`'s from the cache data\n * we can compare against more simplified test data.\n */\nexport function stripSymbols<T>(data: T): T {\n  return JSON.parse(JSON.stringify(data));\n}\n"]},"metadata":{},"sourceType":"module"}