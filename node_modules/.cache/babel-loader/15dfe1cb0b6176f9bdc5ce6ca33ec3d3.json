{"ast":null,"code":"/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport invariant from '../jsutils/invariant';\nimport keyMap from '../jsutils/keyMap';\nimport { ASTDefinitionBuilder } from './buildASTSchema';\nimport { GraphQLError } from '../error/GraphQLError';\nimport { isSchema, GraphQLSchema } from '../type/schema';\nimport { isObjectType, isInterfaceType, isUnionType, isListType, isNonNullType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType } from '../type/definition';\nimport { GraphQLList, GraphQLNonNull } from '../type/wrappers';\nimport { GraphQLDirective } from '../type/directives';\nimport { Kind } from '../language/kinds';\n/**\n * Produces a new schema given an existing schema and a document which may\n * contain GraphQL type extensions and definitions. The original schema will\n * remain unaltered.\n *\n * Because a schema represents a graph of references, a schema cannot be\n * extended without effectively making an entire copy. We do not know until it's\n * too late if subgraphs remain unchanged.\n *\n * This algorithm copies the provided schema, applying extensions while\n * producing the copy. The original schema remains unaltered.\n *\n * Accepts options as a third argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\n\nexport function extendSchema(schema, documentAST, options) {\n  !isSchema(schema) ? invariant(0, 'Must provide valid GraphQLSchema') : void 0;\n  !(documentAST && documentAST.kind === Kind.DOCUMENT) ? invariant(0, 'Must provide valid Document AST') : void 0; // Collect the type definitions and extensions found in the document.\n\n  var typeDefinitionMap = Object.create(null);\n  var typeExtensionsMap = Object.create(null); // New directives and types are separate because a directives and types can\n  // have the same name. For example, a type named \"skip\".\n\n  var directiveDefinitions = [];\n\n  for (var i = 0; i < documentAST.definitions.length; i++) {\n    var def = documentAST.definitions[i];\n\n    switch (def.kind) {\n      case Kind.OBJECT_TYPE_DEFINITION:\n      case Kind.INTERFACE_TYPE_DEFINITION:\n      case Kind.ENUM_TYPE_DEFINITION:\n      case Kind.UNION_TYPE_DEFINITION:\n      case Kind.SCALAR_TYPE_DEFINITION:\n      case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n        // Sanity check that none of the defined types conflict with the\n        // schema's existing types.\n        var typeName = def.name.value;\n\n        if (schema.getType(typeName)) {\n          throw new GraphQLError('Type \"' + typeName + '\" already exists in the schema. It cannot also ' + 'be defined in this type definition.', [def]);\n        }\n\n        typeDefinitionMap[typeName] = def;\n        break;\n\n      case Kind.OBJECT_TYPE_EXTENSION:\n        // Sanity check that this type extension exists within the\n        // schema's existing types.\n        var extendedTypeName = def.name.value;\n        var existingType = schema.getType(extendedTypeName);\n\n        if (!existingType) {\n          throw new GraphQLError('Cannot extend type \"' + extendedTypeName + '\" because it does not ' + 'exist in the existing schema.', [def]);\n        }\n\n        if (!isObjectType(existingType)) {\n          throw new GraphQLError('Cannot extend non-object type \"' + extendedTypeName + '\".', [def]);\n        }\n\n        var extensions = typeExtensionsMap[extendedTypeName];\n\n        if (extensions) {\n          extensions.push(def);\n        } else {\n          extensions = [def];\n        }\n\n        typeExtensionsMap[extendedTypeName] = extensions;\n        break;\n\n      case Kind.DIRECTIVE_DEFINITION:\n        var directiveName = def.name.value;\n        var existingDirective = schema.getDirective(directiveName);\n\n        if (existingDirective) {\n          throw new GraphQLError('Directive \"' + directiveName + '\" already exists in the schema. It ' + 'cannot be redefined.', [def]);\n        }\n\n        directiveDefinitions.push(def);\n        break;\n\n      case Kind.SCALAR_TYPE_EXTENSION:\n      case Kind.INTERFACE_TYPE_EXTENSION:\n      case Kind.UNION_TYPE_EXTENSION:\n      case Kind.ENUM_TYPE_EXTENSION:\n      case Kind.INPUT_OBJECT_TYPE_EXTENSION:\n        throw new Error('The ' + def.kind + ' kind is not yet supported by extendSchema().');\n    }\n  } // If this document contains no new types, extensions, or directives then\n  // return the same unmodified GraphQLSchema instance.\n\n\n  if (Object.keys(typeExtensionsMap).length === 0 && Object.keys(typeDefinitionMap).length === 0 && directiveDefinitions.length === 0) {\n    return schema;\n  }\n\n  var definitionBuilder = new ASTDefinitionBuilder(typeDefinitionMap, options, function (typeName, node) {\n    var existingType = schema.getType(typeName);\n\n    if (existingType) {\n      return extendType(existingType);\n    }\n\n    if (node) {\n      throw new GraphQLError('Unknown type: \"' + typeName + '\". Ensure that this type exists ' + 'either in the original schema, or is added in a type definition.', [node]);\n    }\n\n    throw GraphQLError('Missing type from schema');\n  }); // Get the root Query, Mutation, and Subscription object types.\n  // Note: While this could make early assertions to get the correctly\n  // typed values below, that would throw immediately while type system\n  // validation with validateSchema() will produce more actionable results.\n\n  var existingQueryType = schema.getQueryType();\n  var queryType = existingQueryType ? definitionBuilder.buildType(existingQueryType.name) : null;\n  var existingMutationType = schema.getMutationType();\n  var mutationType = existingMutationType ? definitionBuilder.buildType(existingMutationType.name) : null;\n  var existingSubscriptionType = schema.getSubscriptionType();\n  var subscriptionType = existingSubscriptionType ? definitionBuilder.buildType(existingSubscriptionType.name) : null; // Iterate through all types, getting the type definition for each, ensuring\n  // that any type not directly referenced by a field will get created.\n\n  var typeMap = schema.getTypeMap();\n  var types = Object.keys(typeMap).map(function (typeName) {\n    return definitionBuilder.buildType(typeName);\n  }); // Do the same with new types, appending to the list of defined types.\n\n  Object.keys(typeDefinitionMap).forEach(function (typeName) {\n    types.push(definitionBuilder.buildType(typeName));\n  }); // Then produce and return a Schema with these types.\n\n  return new GraphQLSchema({\n    query: queryType,\n    mutation: mutationType,\n    subscription: subscriptionType,\n    types: types,\n    directives: getMergedDirectives(),\n    astNode: schema.astNode,\n    allowedLegacyNames: schema.__allowedLegacyNames && schema.__allowedLegacyNames.slice()\n  }); // Below are functions used for producing this schema that have closed over\n  // this scope and have access to the schema, cache, and newly defined types.\n\n  function getMergedDirectives() {\n    var existingDirectives = schema.getDirectives();\n    !existingDirectives ? invariant(0, 'schema must have default directives') : void 0;\n    var newDirectives = directiveDefinitions.map(function (directiveNode) {\n      return definitionBuilder.buildDirective(directiveNode);\n    });\n    return existingDirectives.concat(newDirectives);\n  }\n\n  function getTypeFromDef(typeDef) {\n    var type = definitionBuilder.buildType(typeDef.name);\n    return type;\n  } // Given a type's introspection result, construct the correct\n  // GraphQLType instance.\n\n\n  function extendType(type) {\n    if (isObjectType(type)) {\n      return extendObjectType(type);\n    }\n\n    if (isInterfaceType(type)) {\n      return extendInterfaceType(type);\n    }\n\n    if (isUnionType(type)) {\n      return extendUnionType(type);\n    }\n\n    return type;\n  }\n\n  function extendObjectType(type) {\n    var name = type.name;\n    var extensionASTNodes = typeExtensionsMap[name] ? type.extensionASTNodes ? type.extensionASTNodes.concat(typeExtensionsMap[name]) : typeExtensionsMap[name] : type.extensionASTNodes;\n    return new GraphQLObjectType({\n      name: name,\n      description: type.description,\n      interfaces: function interfaces() {\n        return extendImplementedInterfaces(type);\n      },\n      fields: function fields() {\n        return extendFieldMap(type);\n      },\n      astNode: type.astNode,\n      extensionASTNodes: extensionASTNodes,\n      isTypeOf: type.isTypeOf\n    });\n  }\n\n  function extendInterfaceType(type) {\n    return new GraphQLInterfaceType({\n      name: type.name,\n      description: type.description,\n      fields: function fields() {\n        return extendFieldMap(type);\n      },\n      astNode: type.astNode,\n      resolveType: type.resolveType\n    });\n  }\n\n  function extendUnionType(type) {\n    return new GraphQLUnionType({\n      name: type.name,\n      description: type.description,\n      types: type.getTypes().map(getTypeFromDef),\n      astNode: type.astNode,\n      resolveType: type.resolveType\n    });\n  }\n\n  function extendImplementedInterfaces(type) {\n    var interfaces = type.getInterfaces().map(getTypeFromDef); // If there are any extensions to the interfaces, apply those here.\n\n    var extensions = typeExtensionsMap[type.name];\n\n    if (extensions) {\n      extensions.forEach(function (extension) {\n        extension.interfaces.forEach(function (namedType) {\n          // Note: While this could make early assertions to get the correctly\n          // typed values, that would throw immediately while type system\n          // validation with validateSchema() will produce more actionable results.\n          interfaces.push(definitionBuilder.buildType(namedType));\n        });\n      });\n    }\n\n    return interfaces;\n  }\n\n  function extendFieldMap(type) {\n    var newFieldMap = Object.create(null);\n    var oldFieldMap = type.getFields();\n    Object.keys(oldFieldMap).forEach(function (fieldName) {\n      var field = oldFieldMap[fieldName];\n      newFieldMap[fieldName] = {\n        description: field.description,\n        deprecationReason: field.deprecationReason,\n        type: extendFieldType(field.type),\n        args: keyMap(field.args, function (arg) {\n          return arg.name;\n        }),\n        astNode: field.astNode,\n        resolve: field.resolve\n      };\n    }); // If there are any extensions to the fields, apply those here.\n\n    var extensions = typeExtensionsMap[type.name];\n\n    if (extensions) {\n      extensions.forEach(function (extension) {\n        extension.fields.forEach(function (field) {\n          var fieldName = field.name.value;\n\n          if (oldFieldMap[fieldName]) {\n            throw new GraphQLError('Field \"' + type.name + '.' + fieldName + '\" already exists in the ' + 'schema. It cannot also be defined in this type extension.', [field]);\n          }\n\n          newFieldMap[fieldName] = definitionBuilder.buildField(field);\n        });\n      });\n    }\n\n    return newFieldMap;\n  }\n\n  function extendFieldType(typeDef) {\n    if (isListType(typeDef)) {\n      return GraphQLList(extendFieldType(typeDef.ofType));\n    }\n\n    if (isNonNullType(typeDef)) {\n      return GraphQLNonNull(extendFieldType(typeDef.ofType));\n    }\n\n    return getTypeFromDef(typeDef);\n  }\n}","map":{"version":3,"names":["invariant","keyMap","ASTDefinitionBuilder","GraphQLError","isSchema","GraphQLSchema","isObjectType","isInterfaceType","isUnionType","isListType","isNonNullType","GraphQLObjectType","GraphQLInterfaceType","GraphQLUnionType","GraphQLList","GraphQLNonNull","GraphQLDirective","Kind","extendSchema","schema","documentAST","options","kind","DOCUMENT","typeDefinitionMap","Object","create","typeExtensionsMap","directiveDefinitions","i","definitions","length","def","OBJECT_TYPE_DEFINITION","INTERFACE_TYPE_DEFINITION","ENUM_TYPE_DEFINITION","UNION_TYPE_DEFINITION","SCALAR_TYPE_DEFINITION","INPUT_OBJECT_TYPE_DEFINITION","typeName","name","value","getType","OBJECT_TYPE_EXTENSION","extendedTypeName","existingType","extensions","push","DIRECTIVE_DEFINITION","directiveName","existingDirective","getDirective","SCALAR_TYPE_EXTENSION","INTERFACE_TYPE_EXTENSION","UNION_TYPE_EXTENSION","ENUM_TYPE_EXTENSION","INPUT_OBJECT_TYPE_EXTENSION","Error","keys","definitionBuilder","node","extendType","existingQueryType","getQueryType","queryType","buildType","existingMutationType","getMutationType","mutationType","existingSubscriptionType","getSubscriptionType","subscriptionType","typeMap","getTypeMap","types","map","forEach","query","mutation","subscription","directives","getMergedDirectives","astNode","allowedLegacyNames","__allowedLegacyNames","slice","existingDirectives","getDirectives","newDirectives","directiveNode","buildDirective","concat","getTypeFromDef","typeDef","type","extendObjectType","extendInterfaceType","extendUnionType","extensionASTNodes","description","interfaces","extendImplementedInterfaces","fields","extendFieldMap","isTypeOf","resolveType","getTypes","getInterfaces","extension","namedType","newFieldMap","oldFieldMap","getFields","fieldName","field","deprecationReason","extendFieldType","args","arg","resolve","buildField","ofType"],"sources":["/Users/roaldmaravillas/ro/github/scaffold-appsync-events/node_modules/aws-appsync/node_modules/graphql/module/utilities/extendSchema.js"],"sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nimport invariant from '../jsutils/invariant';\nimport keyMap from '../jsutils/keyMap';\nimport { ASTDefinitionBuilder } from './buildASTSchema';\nimport { GraphQLError } from '../error/GraphQLError';\nimport { isSchema, GraphQLSchema } from '../type/schema';\n\nimport { isObjectType, isInterfaceType, isUnionType, isListType, isNonNullType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType } from '../type/definition';\nimport { GraphQLList, GraphQLNonNull } from '../type/wrappers';\n\nimport { GraphQLDirective } from '../type/directives';\n\nimport { Kind } from '../language/kinds';\n\n/**\n * Produces a new schema given an existing schema and a document which may\n * contain GraphQL type extensions and definitions. The original schema will\n * remain unaltered.\n *\n * Because a schema represents a graph of references, a schema cannot be\n * extended without effectively making an entire copy. We do not know until it's\n * too late if subgraphs remain unchanged.\n *\n * This algorithm copies the provided schema, applying extensions while\n * producing the copy. The original schema remains unaltered.\n *\n * Accepts options as a third argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\nexport function extendSchema(schema, documentAST, options) {\n  !isSchema(schema) ? invariant(0, 'Must provide valid GraphQLSchema') : void 0;\n\n  !(documentAST && documentAST.kind === Kind.DOCUMENT) ? invariant(0, 'Must provide valid Document AST') : void 0;\n\n  // Collect the type definitions and extensions found in the document.\n  var typeDefinitionMap = Object.create(null);\n  var typeExtensionsMap = Object.create(null);\n\n  // New directives and types are separate because a directives and types can\n  // have the same name. For example, a type named \"skip\".\n  var directiveDefinitions = [];\n\n  for (var i = 0; i < documentAST.definitions.length; i++) {\n    var def = documentAST.definitions[i];\n    switch (def.kind) {\n      case Kind.OBJECT_TYPE_DEFINITION:\n      case Kind.INTERFACE_TYPE_DEFINITION:\n      case Kind.ENUM_TYPE_DEFINITION:\n      case Kind.UNION_TYPE_DEFINITION:\n      case Kind.SCALAR_TYPE_DEFINITION:\n      case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n        // Sanity check that none of the defined types conflict with the\n        // schema's existing types.\n        var typeName = def.name.value;\n        if (schema.getType(typeName)) {\n          throw new GraphQLError('Type \"' + typeName + '\" already exists in the schema. It cannot also ' + 'be defined in this type definition.', [def]);\n        }\n        typeDefinitionMap[typeName] = def;\n        break;\n      case Kind.OBJECT_TYPE_EXTENSION:\n        // Sanity check that this type extension exists within the\n        // schema's existing types.\n        var extendedTypeName = def.name.value;\n        var existingType = schema.getType(extendedTypeName);\n        if (!existingType) {\n          throw new GraphQLError('Cannot extend type \"' + extendedTypeName + '\" because it does not ' + 'exist in the existing schema.', [def]);\n        }\n        if (!isObjectType(existingType)) {\n          throw new GraphQLError('Cannot extend non-object type \"' + extendedTypeName + '\".', [def]);\n        }\n        var extensions = typeExtensionsMap[extendedTypeName];\n        if (extensions) {\n          extensions.push(def);\n        } else {\n          extensions = [def];\n        }\n        typeExtensionsMap[extendedTypeName] = extensions;\n        break;\n      case Kind.DIRECTIVE_DEFINITION:\n        var directiveName = def.name.value;\n        var existingDirective = schema.getDirective(directiveName);\n        if (existingDirective) {\n          throw new GraphQLError('Directive \"' + directiveName + '\" already exists in the schema. It ' + 'cannot be redefined.', [def]);\n        }\n        directiveDefinitions.push(def);\n        break;\n      case Kind.SCALAR_TYPE_EXTENSION:\n      case Kind.INTERFACE_TYPE_EXTENSION:\n      case Kind.UNION_TYPE_EXTENSION:\n      case Kind.ENUM_TYPE_EXTENSION:\n      case Kind.INPUT_OBJECT_TYPE_EXTENSION:\n        throw new Error('The ' + def.kind + ' kind is not yet supported by extendSchema().');\n    }\n  }\n\n  // If this document contains no new types, extensions, or directives then\n  // return the same unmodified GraphQLSchema instance.\n  if (Object.keys(typeExtensionsMap).length === 0 && Object.keys(typeDefinitionMap).length === 0 && directiveDefinitions.length === 0) {\n    return schema;\n  }\n\n  var definitionBuilder = new ASTDefinitionBuilder(typeDefinitionMap, options, function (typeName, node) {\n    var existingType = schema.getType(typeName);\n    if (existingType) {\n      return extendType(existingType);\n    }\n\n    if (node) {\n      throw new GraphQLError('Unknown type: \"' + typeName + '\". Ensure that this type exists ' + 'either in the original schema, or is added in a type definition.', [node]);\n    }\n    throw GraphQLError('Missing type from schema');\n  });\n\n  // Get the root Query, Mutation, and Subscription object types.\n  // Note: While this could make early assertions to get the correctly\n  // typed values below, that would throw immediately while type system\n  // validation with validateSchema() will produce more actionable results.\n  var existingQueryType = schema.getQueryType();\n  var queryType = existingQueryType ? definitionBuilder.buildType(existingQueryType.name) : null;\n\n  var existingMutationType = schema.getMutationType();\n  var mutationType = existingMutationType ? definitionBuilder.buildType(existingMutationType.name) : null;\n\n  var existingSubscriptionType = schema.getSubscriptionType();\n  var subscriptionType = existingSubscriptionType ? definitionBuilder.buildType(existingSubscriptionType.name) : null;\n\n  // Iterate through all types, getting the type definition for each, ensuring\n  // that any type not directly referenced by a field will get created.\n  var typeMap = schema.getTypeMap();\n  var types = Object.keys(typeMap).map(function (typeName) {\n    return definitionBuilder.buildType(typeName);\n  });\n\n  // Do the same with new types, appending to the list of defined types.\n  Object.keys(typeDefinitionMap).forEach(function (typeName) {\n    types.push(definitionBuilder.buildType(typeName));\n  });\n\n  // Then produce and return a Schema with these types.\n  return new GraphQLSchema({\n    query: queryType,\n    mutation: mutationType,\n    subscription: subscriptionType,\n    types: types,\n    directives: getMergedDirectives(),\n    astNode: schema.astNode,\n    allowedLegacyNames: schema.__allowedLegacyNames && schema.__allowedLegacyNames.slice()\n  });\n\n  // Below are functions used for producing this schema that have closed over\n  // this scope and have access to the schema, cache, and newly defined types.\n\n  function getMergedDirectives() {\n    var existingDirectives = schema.getDirectives();\n    !existingDirectives ? invariant(0, 'schema must have default directives') : void 0;\n\n    var newDirectives = directiveDefinitions.map(function (directiveNode) {\n      return definitionBuilder.buildDirective(directiveNode);\n    });\n    return existingDirectives.concat(newDirectives);\n  }\n\n  function getTypeFromDef(typeDef) {\n    var type = definitionBuilder.buildType(typeDef.name);\n    return type;\n  }\n\n  // Given a type's introspection result, construct the correct\n  // GraphQLType instance.\n  function extendType(type) {\n    if (isObjectType(type)) {\n      return extendObjectType(type);\n    }\n    if (isInterfaceType(type)) {\n      return extendInterfaceType(type);\n    }\n    if (isUnionType(type)) {\n      return extendUnionType(type);\n    }\n    return type;\n  }\n\n  function extendObjectType(type) {\n    var name = type.name;\n    var extensionASTNodes = typeExtensionsMap[name] ? type.extensionASTNodes ? type.extensionASTNodes.concat(typeExtensionsMap[name]) : typeExtensionsMap[name] : type.extensionASTNodes;\n    return new GraphQLObjectType({\n      name: name,\n      description: type.description,\n      interfaces: function interfaces() {\n        return extendImplementedInterfaces(type);\n      },\n      fields: function fields() {\n        return extendFieldMap(type);\n      },\n      astNode: type.astNode,\n      extensionASTNodes: extensionASTNodes,\n      isTypeOf: type.isTypeOf\n    });\n  }\n\n  function extendInterfaceType(type) {\n    return new GraphQLInterfaceType({\n      name: type.name,\n      description: type.description,\n      fields: function fields() {\n        return extendFieldMap(type);\n      },\n      astNode: type.astNode,\n      resolveType: type.resolveType\n    });\n  }\n\n  function extendUnionType(type) {\n    return new GraphQLUnionType({\n      name: type.name,\n      description: type.description,\n      types: type.getTypes().map(getTypeFromDef),\n      astNode: type.astNode,\n      resolveType: type.resolveType\n    });\n  }\n\n  function extendImplementedInterfaces(type) {\n    var interfaces = type.getInterfaces().map(getTypeFromDef);\n\n    // If there are any extensions to the interfaces, apply those here.\n    var extensions = typeExtensionsMap[type.name];\n    if (extensions) {\n      extensions.forEach(function (extension) {\n        extension.interfaces.forEach(function (namedType) {\n          // Note: While this could make early assertions to get the correctly\n          // typed values, that would throw immediately while type system\n          // validation with validateSchema() will produce more actionable results.\n          interfaces.push(definitionBuilder.buildType(namedType));\n        });\n      });\n    }\n\n    return interfaces;\n  }\n\n  function extendFieldMap(type) {\n    var newFieldMap = Object.create(null);\n    var oldFieldMap = type.getFields();\n    Object.keys(oldFieldMap).forEach(function (fieldName) {\n      var field = oldFieldMap[fieldName];\n      newFieldMap[fieldName] = {\n        description: field.description,\n        deprecationReason: field.deprecationReason,\n        type: extendFieldType(field.type),\n        args: keyMap(field.args, function (arg) {\n          return arg.name;\n        }),\n        astNode: field.astNode,\n        resolve: field.resolve\n      };\n    });\n\n    // If there are any extensions to the fields, apply those here.\n    var extensions = typeExtensionsMap[type.name];\n    if (extensions) {\n      extensions.forEach(function (extension) {\n        extension.fields.forEach(function (field) {\n          var fieldName = field.name.value;\n          if (oldFieldMap[fieldName]) {\n            throw new GraphQLError('Field \"' + type.name + '.' + fieldName + '\" already exists in the ' + 'schema. It cannot also be defined in this type extension.', [field]);\n          }\n          newFieldMap[fieldName] = definitionBuilder.buildField(field);\n        });\n      });\n    }\n\n    return newFieldMap;\n  }\n\n  function extendFieldType(typeDef) {\n    if (isListType(typeDef)) {\n      return GraphQLList(extendFieldType(typeDef.ofType));\n    }\n    if (isNonNullType(typeDef)) {\n      return GraphQLNonNull(extendFieldType(typeDef.ofType));\n    }\n    return getTypeFromDef(typeDef);\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}