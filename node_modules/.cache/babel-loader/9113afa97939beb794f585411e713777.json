{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parse = parse;\nexports.parseValue = parseValue;\nexports.parseType = parseType;\nexports.parseConstValue = parseConstValue;\nexports.parseTypeReference = parseTypeReference;\nexports.parseNamedType = parseNamedType;\n\nvar _source = require('./source');\n\nvar _error = require('../error');\n\nvar _lexer = require('./lexer');\n\nvar _kinds = require('./kinds');\n/**\n * Given a GraphQL source, parses it into a Document.\n * Throws GraphQLError if a syntax error is encountered.\n */\n\n/**\n * Configuration options to control parser behavior\n */\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\nfunction parse(source, options) {\n  var sourceObj = typeof source === 'string' ? new _source.Source(source) : source;\n\n  if (!(sourceObj instanceof _source.Source)) {\n    throw new TypeError('Must provide Source. Received: ' + String(sourceObj));\n  }\n\n  var lexer = (0, _lexer.createLexer)(sourceObj, options || {});\n  return parseDocument(lexer);\n}\n/**\n * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for\n * that value.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Values directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: valueFromAST().\n */\n\n\nfunction parseValue(source, options) {\n  var sourceObj = typeof source === 'string' ? new _source.Source(source) : source;\n  var lexer = (0, _lexer.createLexer)(sourceObj, options || {});\n  expect(lexer, _lexer.TokenKind.SOF);\n  var value = parseValueLiteral(lexer, false);\n  expect(lexer, _lexer.TokenKind.EOF);\n  return value;\n}\n/**\n * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for\n * that type.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Types directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: typeFromAST().\n */\n\n\nfunction parseType(source, options) {\n  var sourceObj = typeof source === 'string' ? new _source.Source(source) : source;\n  var lexer = (0, _lexer.createLexer)(sourceObj, options || {});\n  expect(lexer, _lexer.TokenKind.SOF);\n  var type = parseTypeReference(lexer);\n  expect(lexer, _lexer.TokenKind.EOF);\n  return type;\n}\n/**\n * Converts a name lex token into a name parse node.\n */\n\n\nfunction parseName(lexer) {\n  var token = expect(lexer, _lexer.TokenKind.NAME);\n  return {\n    kind: _kinds.NAME,\n    value: token.value,\n    loc: loc(lexer, token)\n  };\n} // Implements the parsing rules in the Document section.\n\n/**\n * Document : Definition+\n */\n\n\nfunction parseDocument(lexer) {\n  var start = lexer.token;\n  expect(lexer, _lexer.TokenKind.SOF);\n  var definitions = [];\n\n  do {\n    definitions.push(parseDefinition(lexer));\n  } while (!skip(lexer, _lexer.TokenKind.EOF));\n\n  return {\n    kind: _kinds.DOCUMENT,\n    definitions: definitions,\n    loc: loc(lexer, start)\n  };\n}\n/**\n * Definition :\n *   - OperationDefinition\n *   - FragmentDefinition\n *   - TypeSystemDefinition\n */\n\n\nfunction parseDefinition(lexer) {\n  if (peek(lexer, _lexer.TokenKind.BRACE_L)) {\n    return parseOperationDefinition(lexer);\n  }\n\n  if (peek(lexer, _lexer.TokenKind.NAME)) {\n    switch (lexer.token.value) {\n      // Note: subscription is an experimental non-spec addition.\n      case 'query':\n      case 'mutation':\n      case 'subscription':\n        return parseOperationDefinition(lexer);\n\n      case 'fragment':\n        return parseFragmentDefinition(lexer);\n      // Note: the Type System IDL is an experimental non-spec addition.\n\n      case 'schema':\n      case 'scalar':\n      case 'type':\n      case 'interface':\n      case 'union':\n      case 'enum':\n      case 'input':\n      case 'extend':\n      case 'directive':\n        return parseTypeSystemDefinition(lexer);\n    }\n  }\n\n  throw unexpected(lexer);\n} // Implements the parsing rules in the Operations section.\n\n/**\n * OperationDefinition :\n *  - SelectionSet\n *  - OperationType Name? VariableDefinitions? Directives? SelectionSet\n */\n\n\nfunction parseOperationDefinition(lexer) {\n  var start = lexer.token;\n\n  if (peek(lexer, _lexer.TokenKind.BRACE_L)) {\n    return {\n      kind: _kinds.OPERATION_DEFINITION,\n      operation: 'query',\n      name: null,\n      variableDefinitions: null,\n      directives: [],\n      selectionSet: parseSelectionSet(lexer),\n      loc: loc(lexer, start)\n    };\n  }\n\n  var operation = parseOperationType(lexer);\n  var name = void 0;\n\n  if (peek(lexer, _lexer.TokenKind.NAME)) {\n    name = parseName(lexer);\n  }\n\n  return {\n    kind: _kinds.OPERATION_DEFINITION,\n    operation: operation,\n    name: name,\n    variableDefinitions: parseVariableDefinitions(lexer),\n    directives: parseDirectives(lexer),\n    selectionSet: parseSelectionSet(lexer),\n    loc: loc(lexer, start)\n  };\n}\n/**\n * OperationType : one of query mutation subscription\n */\n\n\nfunction parseOperationType(lexer) {\n  var operationToken = expect(lexer, _lexer.TokenKind.NAME);\n\n  switch (operationToken.value) {\n    case 'query':\n      return 'query';\n\n    case 'mutation':\n      return 'mutation';\n    // Note: subscription is an experimental non-spec addition.\n\n    case 'subscription':\n      return 'subscription';\n  }\n\n  throw unexpected(lexer, operationToken);\n}\n/**\n * VariableDefinitions : ( VariableDefinition+ )\n */\n\n\nfunction parseVariableDefinitions(lexer) {\n  return peek(lexer, _lexer.TokenKind.PAREN_L) ? many(lexer, _lexer.TokenKind.PAREN_L, parseVariableDefinition, _lexer.TokenKind.PAREN_R) : [];\n}\n/**\n * VariableDefinition : Variable : Type DefaultValue?\n */\n\n\nfunction parseVariableDefinition(lexer) {\n  var start = lexer.token;\n  return {\n    kind: _kinds.VARIABLE_DEFINITION,\n    variable: parseVariable(lexer),\n    type: (expect(lexer, _lexer.TokenKind.COLON), parseTypeReference(lexer)),\n    defaultValue: skip(lexer, _lexer.TokenKind.EQUALS) ? parseValueLiteral(lexer, true) : null,\n    loc: loc(lexer, start)\n  };\n}\n/**\n * Variable : $ Name\n */\n\n\nfunction parseVariable(lexer) {\n  var start = lexer.token;\n  expect(lexer, _lexer.TokenKind.DOLLAR);\n  return {\n    kind: _kinds.VARIABLE,\n    name: parseName(lexer),\n    loc: loc(lexer, start)\n  };\n}\n/**\n * SelectionSet : { Selection+ }\n */\n\n\nfunction parseSelectionSet(lexer) {\n  var start = lexer.token;\n  return {\n    kind: _kinds.SELECTION_SET,\n    selections: many(lexer, _lexer.TokenKind.BRACE_L, parseSelection, _lexer.TokenKind.BRACE_R),\n    loc: loc(lexer, start)\n  };\n}\n/**\n * Selection :\n *   - Field\n *   - FragmentSpread\n *   - InlineFragment\n */\n\n\nfunction parseSelection(lexer) {\n  return peek(lexer, _lexer.TokenKind.SPREAD) ? parseFragment(lexer) : parseField(lexer);\n}\n/**\n * Field : Alias? Name Arguments? Directives? SelectionSet?\n *\n * Alias : Name :\n */\n\n\nfunction parseField(lexer) {\n  var start = lexer.token;\n  var nameOrAlias = parseName(lexer);\n  var alias = void 0;\n  var name = void 0;\n\n  if (skip(lexer, _lexer.TokenKind.COLON)) {\n    alias = nameOrAlias;\n    name = parseName(lexer);\n  } else {\n    alias = null;\n    name = nameOrAlias;\n  }\n\n  return {\n    kind: _kinds.FIELD,\n    alias: alias,\n    name: name,\n    arguments: parseArguments(lexer),\n    directives: parseDirectives(lexer),\n    selectionSet: peek(lexer, _lexer.TokenKind.BRACE_L) ? parseSelectionSet(lexer) : null,\n    loc: loc(lexer, start)\n  };\n}\n/**\n * Arguments : ( Argument+ )\n */\n\n\nfunction parseArguments(lexer) {\n  return peek(lexer, _lexer.TokenKind.PAREN_L) ? many(lexer, _lexer.TokenKind.PAREN_L, parseArgument, _lexer.TokenKind.PAREN_R) : [];\n}\n/**\n * Argument : Name : Value\n */\n\n\nfunction parseArgument(lexer) {\n  var start = lexer.token;\n  return {\n    kind: _kinds.ARGUMENT,\n    name: parseName(lexer),\n    value: (expect(lexer, _lexer.TokenKind.COLON), parseValueLiteral(lexer, false)),\n    loc: loc(lexer, start)\n  };\n} // Implements the parsing rules in the Fragments section.\n\n/**\n * Corresponds to both FragmentSpread and InlineFragment in the spec.\n *\n * FragmentSpread : ... FragmentName Directives?\n *\n * InlineFragment : ... TypeCondition? Directives? SelectionSet\n */\n\n\nfunction parseFragment(lexer) {\n  var start = lexer.token;\n  expect(lexer, _lexer.TokenKind.SPREAD);\n\n  if (peek(lexer, _lexer.TokenKind.NAME) && lexer.token.value !== 'on') {\n    return {\n      kind: _kinds.FRAGMENT_SPREAD,\n      name: parseFragmentName(lexer),\n      directives: parseDirectives(lexer),\n      loc: loc(lexer, start)\n    };\n  }\n\n  var typeCondition = null;\n\n  if (lexer.token.value === 'on') {\n    lexer.advance();\n    typeCondition = parseNamedType(lexer);\n  }\n\n  return {\n    kind: _kinds.INLINE_FRAGMENT,\n    typeCondition: typeCondition,\n    directives: parseDirectives(lexer),\n    selectionSet: parseSelectionSet(lexer),\n    loc: loc(lexer, start)\n  };\n}\n/**\n * FragmentDefinition :\n *   - fragment FragmentName on TypeCondition Directives? SelectionSet\n *\n * TypeCondition : NamedType\n */\n\n\nfunction parseFragmentDefinition(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'fragment');\n  return {\n    kind: _kinds.FRAGMENT_DEFINITION,\n    name: parseFragmentName(lexer),\n    typeCondition: (expectKeyword(lexer, 'on'), parseNamedType(lexer)),\n    directives: parseDirectives(lexer),\n    selectionSet: parseSelectionSet(lexer),\n    loc: loc(lexer, start)\n  };\n}\n/**\n * FragmentName : Name but not `on`\n */\n\n\nfunction parseFragmentName(lexer) {\n  if (lexer.token.value === 'on') {\n    throw unexpected(lexer);\n  }\n\n  return parseName(lexer);\n} // Implements the parsing rules in the Values section.\n\n/**\n * Value[Const] :\n *   - [~Const] Variable\n *   - IntValue\n *   - FloatValue\n *   - StringValue\n *   - BooleanValue\n *   - NullValue\n *   - EnumValue\n *   - ListValue[?Const]\n *   - ObjectValue[?Const]\n *\n * BooleanValue : one of `true` `false`\n *\n * NullValue : `null`\n *\n * EnumValue : Name but not `true`, `false` or `null`\n */\n\n\nfunction parseValueLiteral(lexer, isConst) {\n  var token = lexer.token;\n\n  switch (token.kind) {\n    case _lexer.TokenKind.BRACKET_L:\n      return parseList(lexer, isConst);\n\n    case _lexer.TokenKind.BRACE_L:\n      return parseObject(lexer, isConst);\n\n    case _lexer.TokenKind.INT:\n      lexer.advance();\n      return {\n        kind: _kinds.INT,\n        value: token.value,\n        loc: loc(lexer, token)\n      };\n\n    case _lexer.TokenKind.FLOAT:\n      lexer.advance();\n      return {\n        kind: _kinds.FLOAT,\n        value: token.value,\n        loc: loc(lexer, token)\n      };\n\n    case _lexer.TokenKind.STRING:\n      lexer.advance();\n      return {\n        kind: _kinds.STRING,\n        value: token.value,\n        loc: loc(lexer, token)\n      };\n\n    case _lexer.TokenKind.NAME:\n      if (token.value === 'true' || token.value === 'false') {\n        lexer.advance();\n        return {\n          kind: _kinds.BOOLEAN,\n          value: token.value === 'true',\n          loc: loc(lexer, token)\n        };\n      } else if (token.value === 'null') {\n        lexer.advance();\n        return {\n          kind: _kinds.NULL,\n          loc: loc(lexer, token)\n        };\n      }\n\n      lexer.advance();\n      return {\n        kind: _kinds.ENUM,\n        value: token.value,\n        loc: loc(lexer, token)\n      };\n\n    case _lexer.TokenKind.DOLLAR:\n      if (!isConst) {\n        return parseVariable(lexer);\n      }\n\n      break;\n  }\n\n  throw unexpected(lexer);\n}\n\nfunction parseConstValue(lexer) {\n  return parseValueLiteral(lexer, true);\n}\n\nfunction parseValueValue(lexer) {\n  return parseValueLiteral(lexer, false);\n}\n/**\n * ListValue[Const] :\n *   - [ ]\n *   - [ Value[?Const]+ ]\n */\n\n\nfunction parseList(lexer, isConst) {\n  var start = lexer.token;\n  var item = isConst ? parseConstValue : parseValueValue;\n  return {\n    kind: _kinds.LIST,\n    values: any(lexer, _lexer.TokenKind.BRACKET_L, item, _lexer.TokenKind.BRACKET_R),\n    loc: loc(lexer, start)\n  };\n}\n/**\n * ObjectValue[Const] :\n *   - { }\n *   - { ObjectField[?Const]+ }\n */\n\n\nfunction parseObject(lexer, isConst) {\n  var start = lexer.token;\n  expect(lexer, _lexer.TokenKind.BRACE_L);\n  var fields = [];\n\n  while (!skip(lexer, _lexer.TokenKind.BRACE_R)) {\n    fields.push(parseObjectField(lexer, isConst));\n  }\n\n  return {\n    kind: _kinds.OBJECT,\n    fields: fields,\n    loc: loc(lexer, start)\n  };\n}\n/**\n * ObjectField[Const] : Name : Value[?Const]\n */\n\n\nfunction parseObjectField(lexer, isConst) {\n  var start = lexer.token;\n  return {\n    kind: _kinds.OBJECT_FIELD,\n    name: parseName(lexer),\n    value: (expect(lexer, _lexer.TokenKind.COLON), parseValueLiteral(lexer, isConst)),\n    loc: loc(lexer, start)\n  };\n} // Implements the parsing rules in the Directives section.\n\n/**\n * Directives : Directive+\n */\n\n\nfunction parseDirectives(lexer) {\n  var directives = [];\n\n  while (peek(lexer, _lexer.TokenKind.AT)) {\n    directives.push(parseDirective(lexer));\n  }\n\n  return directives;\n}\n/**\n * Directive : @ Name Arguments?\n */\n\n\nfunction parseDirective(lexer) {\n  var start = lexer.token;\n  expect(lexer, _lexer.TokenKind.AT);\n  return {\n    kind: _kinds.DIRECTIVE,\n    name: parseName(lexer),\n    arguments: parseArguments(lexer),\n    loc: loc(lexer, start)\n  };\n} // Implements the parsing rules in the Types section.\n\n/**\n * Type :\n *   - NamedType\n *   - ListType\n *   - NonNullType\n */\n\n\nfunction parseTypeReference(lexer) {\n  var start = lexer.token;\n  var type = void 0;\n\n  if (skip(lexer, _lexer.TokenKind.BRACKET_L)) {\n    type = parseTypeReference(lexer);\n    expect(lexer, _lexer.TokenKind.BRACKET_R);\n    type = {\n      kind: _kinds.LIST_TYPE,\n      type: type,\n      loc: loc(lexer, start)\n    };\n  } else {\n    type = parseNamedType(lexer);\n  }\n\n  if (skip(lexer, _lexer.TokenKind.BANG)) {\n    return {\n      kind: _kinds.NON_NULL_TYPE,\n      type: type,\n      loc: loc(lexer, start)\n    };\n  }\n\n  return type;\n}\n/**\n * NamedType : Name\n */\n\n\nfunction parseNamedType(lexer) {\n  var start = lexer.token;\n  return {\n    kind: _kinds.NAMED_TYPE,\n    name: parseName(lexer),\n    loc: loc(lexer, start)\n  };\n} // Implements the parsing rules in the Type Definition section.\n\n/**\n * TypeSystemDefinition :\n *   - SchemaDefinition\n *   - TypeDefinition\n *   - TypeExtensionDefinition\n *   - DirectiveDefinition\n *\n * TypeDefinition :\n *   - ScalarTypeDefinition\n *   - ObjectTypeDefinition\n *   - InterfaceTypeDefinition\n *   - UnionTypeDefinition\n *   - EnumTypeDefinition\n *   - InputObjectTypeDefinition\n */\n\n\nfunction parseTypeSystemDefinition(lexer) {\n  if (peek(lexer, _lexer.TokenKind.NAME)) {\n    switch (lexer.token.value) {\n      case 'schema':\n        return parseSchemaDefinition(lexer);\n\n      case 'scalar':\n        return parseScalarTypeDefinition(lexer);\n\n      case 'type':\n        return parseObjectTypeDefinition(lexer);\n\n      case 'interface':\n        return parseInterfaceTypeDefinition(lexer);\n\n      case 'union':\n        return parseUnionTypeDefinition(lexer);\n\n      case 'enum':\n        return parseEnumTypeDefinition(lexer);\n\n      case 'input':\n        return parseInputObjectTypeDefinition(lexer);\n\n      case 'extend':\n        return parseTypeExtensionDefinition(lexer);\n\n      case 'directive':\n        return parseDirectiveDefinition(lexer);\n    }\n  }\n\n  throw unexpected(lexer);\n}\n/**\n * SchemaDefinition : schema Directives? { OperationTypeDefinition+ }\n *\n * OperationTypeDefinition : OperationType : NamedType\n */\n\n\nfunction parseSchemaDefinition(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'schema');\n  var directives = parseDirectives(lexer);\n  var operationTypes = many(lexer, _lexer.TokenKind.BRACE_L, parseOperationTypeDefinition, _lexer.TokenKind.BRACE_R);\n  return {\n    kind: _kinds.SCHEMA_DEFINITION,\n    directives: directives,\n    operationTypes: operationTypes,\n    loc: loc(lexer, start)\n  };\n}\n\nfunction parseOperationTypeDefinition(lexer) {\n  var start = lexer.token;\n  var operation = parseOperationType(lexer);\n  expect(lexer, _lexer.TokenKind.COLON);\n  var type = parseNamedType(lexer);\n  return {\n    kind: _kinds.OPERATION_TYPE_DEFINITION,\n    operation: operation,\n    type: type,\n    loc: loc(lexer, start)\n  };\n}\n/**\n * ScalarTypeDefinition : scalar Name Directives?\n */\n\n\nfunction parseScalarTypeDefinition(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'scalar');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer);\n  return {\n    kind: _kinds.SCALAR_TYPE_DEFINITION,\n    name: name,\n    directives: directives,\n    loc: loc(lexer, start)\n  };\n}\n/**\n * ObjectTypeDefinition :\n *   - type Name ImplementsInterfaces? Directives? { FieldDefinition+ }\n */\n\n\nfunction parseObjectTypeDefinition(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'type');\n  var name = parseName(lexer);\n  var interfaces = parseImplementsInterfaces(lexer);\n  var directives = parseDirectives(lexer);\n  var fields = any(lexer, _lexer.TokenKind.BRACE_L, parseFieldDefinition, _lexer.TokenKind.BRACE_R);\n  return {\n    kind: _kinds.OBJECT_TYPE_DEFINITION,\n    name: name,\n    interfaces: interfaces,\n    directives: directives,\n    fields: fields,\n    loc: loc(lexer, start)\n  };\n}\n/**\n * ImplementsInterfaces : implements NamedType+\n */\n\n\nfunction parseImplementsInterfaces(lexer) {\n  var types = [];\n\n  if (lexer.token.value === 'implements') {\n    lexer.advance();\n\n    do {\n      types.push(parseNamedType(lexer));\n    } while (peek(lexer, _lexer.TokenKind.NAME));\n  }\n\n  return types;\n}\n/**\n * FieldDefinition : Name ArgumentsDefinition? : Type Directives?\n */\n\n\nfunction parseFieldDefinition(lexer) {\n  var start = lexer.token;\n  var name = parseName(lexer);\n  var args = parseArgumentDefs(lexer);\n  expect(lexer, _lexer.TokenKind.COLON);\n  var type = parseTypeReference(lexer);\n  var directives = parseDirectives(lexer);\n  return {\n    kind: _kinds.FIELD_DEFINITION,\n    name: name,\n    arguments: args,\n    type: type,\n    directives: directives,\n    loc: loc(lexer, start)\n  };\n}\n/**\n * ArgumentsDefinition : ( InputValueDefinition+ )\n */\n\n\nfunction parseArgumentDefs(lexer) {\n  if (!peek(lexer, _lexer.TokenKind.PAREN_L)) {\n    return [];\n  }\n\n  return many(lexer, _lexer.TokenKind.PAREN_L, parseInputValueDef, _lexer.TokenKind.PAREN_R);\n}\n/**\n * InputValueDefinition : Name : Type DefaultValue? Directives?\n */\n\n\nfunction parseInputValueDef(lexer) {\n  var start = lexer.token;\n  var name = parseName(lexer);\n  expect(lexer, _lexer.TokenKind.COLON);\n  var type = parseTypeReference(lexer);\n  var defaultValue = null;\n\n  if (skip(lexer, _lexer.TokenKind.EQUALS)) {\n    defaultValue = parseConstValue(lexer);\n  }\n\n  var directives = parseDirectives(lexer);\n  return {\n    kind: _kinds.INPUT_VALUE_DEFINITION,\n    name: name,\n    type: type,\n    defaultValue: defaultValue,\n    directives: directives,\n    loc: loc(lexer, start)\n  };\n}\n/**\n * InterfaceTypeDefinition : interface Name Directives? { FieldDefinition+ }\n */\n\n\nfunction parseInterfaceTypeDefinition(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'interface');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer);\n  var fields = any(lexer, _lexer.TokenKind.BRACE_L, parseFieldDefinition, _lexer.TokenKind.BRACE_R);\n  return {\n    kind: _kinds.INTERFACE_TYPE_DEFINITION,\n    name: name,\n    directives: directives,\n    fields: fields,\n    loc: loc(lexer, start)\n  };\n}\n/**\n * UnionTypeDefinition : union Name Directives? = UnionMembers\n */\n\n\nfunction parseUnionTypeDefinition(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'union');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer);\n  expect(lexer, _lexer.TokenKind.EQUALS);\n  var types = parseUnionMembers(lexer);\n  return {\n    kind: _kinds.UNION_TYPE_DEFINITION,\n    name: name,\n    directives: directives,\n    types: types,\n    loc: loc(lexer, start)\n  };\n}\n/**\n * UnionMembers :\n *   - `|`? NamedType\n *   - UnionMembers | NamedType\n */\n\n\nfunction parseUnionMembers(lexer) {\n  // Optional leading pipe\n  skip(lexer, _lexer.TokenKind.PIPE);\n  var members = [];\n\n  do {\n    members.push(parseNamedType(lexer));\n  } while (skip(lexer, _lexer.TokenKind.PIPE));\n\n  return members;\n}\n/**\n * EnumTypeDefinition : enum Name Directives? { EnumValueDefinition+ }\n */\n\n\nfunction parseEnumTypeDefinition(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'enum');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer);\n  var values = many(lexer, _lexer.TokenKind.BRACE_L, parseEnumValueDefinition, _lexer.TokenKind.BRACE_R);\n  return {\n    kind: _kinds.ENUM_TYPE_DEFINITION,\n    name: name,\n    directives: directives,\n    values: values,\n    loc: loc(lexer, start)\n  };\n}\n/**\n * EnumValueDefinition : EnumValue Directives?\n *\n * EnumValue : Name\n */\n\n\nfunction parseEnumValueDefinition(lexer) {\n  var start = lexer.token;\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer);\n  return {\n    kind: _kinds.ENUM_VALUE_DEFINITION,\n    name: name,\n    directives: directives,\n    loc: loc(lexer, start)\n  };\n}\n/**\n * InputObjectTypeDefinition : input Name Directives? { InputValueDefinition+ }\n */\n\n\nfunction parseInputObjectTypeDefinition(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'input');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer);\n  var fields = any(lexer, _lexer.TokenKind.BRACE_L, parseInputValueDef, _lexer.TokenKind.BRACE_R);\n  return {\n    kind: _kinds.INPUT_OBJECT_TYPE_DEFINITION,\n    name: name,\n    directives: directives,\n    fields: fields,\n    loc: loc(lexer, start)\n  };\n}\n/**\n * TypeExtensionDefinition : extend ObjectTypeDefinition\n */\n\n\nfunction parseTypeExtensionDefinition(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'extend');\n  var definition = parseObjectTypeDefinition(lexer);\n  return {\n    kind: _kinds.TYPE_EXTENSION_DEFINITION,\n    definition: definition,\n    loc: loc(lexer, start)\n  };\n}\n/**\n * DirectiveDefinition :\n *   - directive @ Name ArgumentsDefinition? on DirectiveLocations\n */\n\n\nfunction parseDirectiveDefinition(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'directive');\n  expect(lexer, _lexer.TokenKind.AT);\n  var name = parseName(lexer);\n  var args = parseArgumentDefs(lexer);\n  expectKeyword(lexer, 'on');\n  var locations = parseDirectiveLocations(lexer);\n  return {\n    kind: _kinds.DIRECTIVE_DEFINITION,\n    name: name,\n    arguments: args,\n    locations: locations,\n    loc: loc(lexer, start)\n  };\n}\n/**\n * DirectiveLocations :\n *   - `|`? Name\n *   - DirectiveLocations | Name\n */\n\n\nfunction parseDirectiveLocations(lexer) {\n  // Optional leading pipe\n  skip(lexer, _lexer.TokenKind.PIPE);\n  var locations = [];\n\n  do {\n    locations.push(parseName(lexer));\n  } while (skip(lexer, _lexer.TokenKind.PIPE));\n\n  return locations;\n} // Core parsing utility functions\n\n/**\n * Returns a location object, used to identify the place in\n * the source that created a given parsed object.\n */\n\n\nfunction loc(lexer, startToken) {\n  if (!lexer.options.noLocation) {\n    return new Loc(startToken, lexer.lastToken, lexer.source);\n  }\n}\n\nfunction Loc(startToken, endToken, source) {\n  this.start = startToken.start;\n  this.end = endToken.end;\n  this.startToken = startToken;\n  this.endToken = endToken;\n  this.source = source;\n} // Print a simplified form when appearing in JSON/util.inspect.\n\n\nLoc.prototype.toJSON = Loc.prototype.inspect = function toJSON() {\n  return {\n    start: this.start,\n    end: this.end\n  };\n};\n/**\n * Determines if the next token is of a given kind\n */\n\n\nfunction peek(lexer, kind) {\n  return lexer.token.kind === kind;\n}\n/**\n * If the next token is of the given kind, return true after advancing\n * the lexer. Otherwise, do not change the parser state and return false.\n */\n\n\nfunction skip(lexer, kind) {\n  var match = lexer.token.kind === kind;\n\n  if (match) {\n    lexer.advance();\n  }\n\n  return match;\n}\n/**\n * If the next token is of the given kind, return that token after advancing\n * the lexer. Otherwise, do not change the parser state and throw an error.\n */\n\n\nfunction expect(lexer, kind) {\n  var token = lexer.token;\n\n  if (token.kind === kind) {\n    lexer.advance();\n    return token;\n  }\n\n  throw (0, _error.syntaxError)(lexer.source, token.start, 'Expected ' + kind + ', found ' + (0, _lexer.getTokenDesc)(token));\n}\n/**\n * If the next token is a keyword with the given value, return that token after\n * advancing the lexer. Otherwise, do not change the parser state and return\n * false.\n */\n\n\nfunction expectKeyword(lexer, value) {\n  var token = lexer.token;\n\n  if (token.kind === _lexer.TokenKind.NAME && token.value === value) {\n    lexer.advance();\n    return token;\n  }\n\n  throw (0, _error.syntaxError)(lexer.source, token.start, 'Expected \"' + value + '\", found ' + (0, _lexer.getTokenDesc)(token));\n}\n/**\n * Helper function for creating an error when an unexpected lexed token\n * is encountered.\n */\n\n\nfunction unexpected(lexer, atToken) {\n  var token = atToken || lexer.token;\n  return (0, _error.syntaxError)(lexer.source, token.start, 'Unexpected ' + (0, _lexer.getTokenDesc)(token));\n}\n/**\n * Returns a possibly empty list of parse nodes, determined by\n * the parseFn. This list begins with a lex token of openKind\n * and ends with a lex token of closeKind. Advances the parser\n * to the next lex token after the closing token.\n */\n\n\nfunction any(lexer, openKind, parseFn, closeKind) {\n  expect(lexer, openKind);\n  var nodes = [];\n\n  while (!skip(lexer, closeKind)) {\n    nodes.push(parseFn(lexer));\n  }\n\n  return nodes;\n}\n/**\n * Returns a non-empty list of parse nodes, determined by\n * the parseFn. This list begins with a lex token of openKind\n * and ends with a lex token of closeKind. Advances the parser\n * to the next lex token after the closing token.\n */\n\n\nfunction many(lexer, openKind, parseFn, closeKind) {\n  expect(lexer, openKind);\n  var nodes = [parseFn(lexer)];\n\n  while (!skip(lexer, closeKind)) {\n    nodes.push(parseFn(lexer));\n  }\n\n  return nodes;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","parse","parseValue","parseType","parseConstValue","parseTypeReference","parseNamedType","_source","require","_error","_lexer","_kinds","source","options","sourceObj","Source","TypeError","String","lexer","createLexer","parseDocument","expect","TokenKind","SOF","parseValueLiteral","EOF","type","parseName","token","NAME","kind","loc","start","definitions","push","parseDefinition","skip","DOCUMENT","peek","BRACE_L","parseOperationDefinition","parseFragmentDefinition","parseTypeSystemDefinition","unexpected","OPERATION_DEFINITION","operation","name","variableDefinitions","directives","selectionSet","parseSelectionSet","parseOperationType","parseVariableDefinitions","parseDirectives","operationToken","PAREN_L","many","parseVariableDefinition","PAREN_R","VARIABLE_DEFINITION","variable","parseVariable","COLON","defaultValue","EQUALS","DOLLAR","VARIABLE","SELECTION_SET","selections","parseSelection","BRACE_R","SPREAD","parseFragment","parseField","nameOrAlias","alias","FIELD","arguments","parseArguments","parseArgument","ARGUMENT","FRAGMENT_SPREAD","parseFragmentName","typeCondition","advance","INLINE_FRAGMENT","expectKeyword","FRAGMENT_DEFINITION","isConst","BRACKET_L","parseList","parseObject","INT","FLOAT","STRING","BOOLEAN","NULL","ENUM","parseValueValue","item","LIST","values","any","BRACKET_R","fields","parseObjectField","OBJECT","OBJECT_FIELD","AT","parseDirective","DIRECTIVE","LIST_TYPE","BANG","NON_NULL_TYPE","NAMED_TYPE","parseSchemaDefinition","parseScalarTypeDefinition","parseObjectTypeDefinition","parseInterfaceTypeDefinition","parseUnionTypeDefinition","parseEnumTypeDefinition","parseInputObjectTypeDefinition","parseTypeExtensionDefinition","parseDirectiveDefinition","operationTypes","parseOperationTypeDefinition","SCHEMA_DEFINITION","OPERATION_TYPE_DEFINITION","SCALAR_TYPE_DEFINITION","interfaces","parseImplementsInterfaces","parseFieldDefinition","OBJECT_TYPE_DEFINITION","types","args","parseArgumentDefs","FIELD_DEFINITION","parseInputValueDef","INPUT_VALUE_DEFINITION","INTERFACE_TYPE_DEFINITION","parseUnionMembers","UNION_TYPE_DEFINITION","PIPE","members","parseEnumValueDefinition","ENUM_TYPE_DEFINITION","ENUM_VALUE_DEFINITION","INPUT_OBJECT_TYPE_DEFINITION","definition","TYPE_EXTENSION_DEFINITION","locations","parseDirectiveLocations","DIRECTIVE_DEFINITION","startToken","noLocation","Loc","lastToken","endToken","end","prototype","toJSON","inspect","match","syntaxError","getTokenDesc","atToken","openKind","parseFn","closeKind","nodes"],"sources":["/Users/roaldmaravillas/ro/sandbox/aws-mobile-appsync-events-starter-react/node_modules/graphql/language/parser.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parse = parse;\nexports.parseValue = parseValue;\nexports.parseType = parseType;\nexports.parseConstValue = parseConstValue;\nexports.parseTypeReference = parseTypeReference;\nexports.parseNamedType = parseNamedType;\n\nvar _source = require('./source');\n\nvar _error = require('../error');\n\nvar _lexer = require('./lexer');\n\nvar _kinds = require('./kinds');\n\n/**\n * Given a GraphQL source, parses it into a Document.\n * Throws GraphQLError if a syntax error is encountered.\n */\n\n\n/**\n * Configuration options to control parser behavior\n */\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nfunction parse(source, options) {\n  var sourceObj = typeof source === 'string' ? new _source.Source(source) : source;\n  if (!(sourceObj instanceof _source.Source)) {\n    throw new TypeError('Must provide Source. Received: ' + String(sourceObj));\n  }\n  var lexer = (0, _lexer.createLexer)(sourceObj, options || {});\n  return parseDocument(lexer);\n}\n\n/**\n * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for\n * that value.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Values directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: valueFromAST().\n */\nfunction parseValue(source, options) {\n  var sourceObj = typeof source === 'string' ? new _source.Source(source) : source;\n  var lexer = (0, _lexer.createLexer)(sourceObj, options || {});\n  expect(lexer, _lexer.TokenKind.SOF);\n  var value = parseValueLiteral(lexer, false);\n  expect(lexer, _lexer.TokenKind.EOF);\n  return value;\n}\n\n/**\n * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for\n * that type.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Types directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: typeFromAST().\n */\nfunction parseType(source, options) {\n  var sourceObj = typeof source === 'string' ? new _source.Source(source) : source;\n  var lexer = (0, _lexer.createLexer)(sourceObj, options || {});\n  expect(lexer, _lexer.TokenKind.SOF);\n  var type = parseTypeReference(lexer);\n  expect(lexer, _lexer.TokenKind.EOF);\n  return type;\n}\n\n/**\n * Converts a name lex token into a name parse node.\n */\nfunction parseName(lexer) {\n  var token = expect(lexer, _lexer.TokenKind.NAME);\n  return {\n    kind: _kinds.NAME,\n    value: token.value,\n    loc: loc(lexer, token)\n  };\n}\n\n// Implements the parsing rules in the Document section.\n\n/**\n * Document : Definition+\n */\nfunction parseDocument(lexer) {\n  var start = lexer.token;\n  expect(lexer, _lexer.TokenKind.SOF);\n  var definitions = [];\n  do {\n    definitions.push(parseDefinition(lexer));\n  } while (!skip(lexer, _lexer.TokenKind.EOF));\n\n  return {\n    kind: _kinds.DOCUMENT,\n    definitions: definitions,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * Definition :\n *   - OperationDefinition\n *   - FragmentDefinition\n *   - TypeSystemDefinition\n */\nfunction parseDefinition(lexer) {\n  if (peek(lexer, _lexer.TokenKind.BRACE_L)) {\n    return parseOperationDefinition(lexer);\n  }\n\n  if (peek(lexer, _lexer.TokenKind.NAME)) {\n    switch (lexer.token.value) {\n      // Note: subscription is an experimental non-spec addition.\n      case 'query':\n      case 'mutation':\n      case 'subscription':\n        return parseOperationDefinition(lexer);\n\n      case 'fragment':\n        return parseFragmentDefinition(lexer);\n\n      // Note: the Type System IDL is an experimental non-spec addition.\n      case 'schema':\n      case 'scalar':\n      case 'type':\n      case 'interface':\n      case 'union':\n      case 'enum':\n      case 'input':\n      case 'extend':\n      case 'directive':\n        return parseTypeSystemDefinition(lexer);\n    }\n  }\n\n  throw unexpected(lexer);\n}\n\n// Implements the parsing rules in the Operations section.\n\n/**\n * OperationDefinition :\n *  - SelectionSet\n *  - OperationType Name? VariableDefinitions? Directives? SelectionSet\n */\nfunction parseOperationDefinition(lexer) {\n  var start = lexer.token;\n  if (peek(lexer, _lexer.TokenKind.BRACE_L)) {\n    return {\n      kind: _kinds.OPERATION_DEFINITION,\n      operation: 'query',\n      name: null,\n      variableDefinitions: null,\n      directives: [],\n      selectionSet: parseSelectionSet(lexer),\n      loc: loc(lexer, start)\n    };\n  }\n  var operation = parseOperationType(lexer);\n  var name = void 0;\n  if (peek(lexer, _lexer.TokenKind.NAME)) {\n    name = parseName(lexer);\n  }\n  return {\n    kind: _kinds.OPERATION_DEFINITION,\n    operation: operation,\n    name: name,\n    variableDefinitions: parseVariableDefinitions(lexer),\n    directives: parseDirectives(lexer),\n    selectionSet: parseSelectionSet(lexer),\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * OperationType : one of query mutation subscription\n */\nfunction parseOperationType(lexer) {\n  var operationToken = expect(lexer, _lexer.TokenKind.NAME);\n  switch (operationToken.value) {\n    case 'query':\n      return 'query';\n    case 'mutation':\n      return 'mutation';\n    // Note: subscription is an experimental non-spec addition.\n    case 'subscription':\n      return 'subscription';\n  }\n\n  throw unexpected(lexer, operationToken);\n}\n\n/**\n * VariableDefinitions : ( VariableDefinition+ )\n */\nfunction parseVariableDefinitions(lexer) {\n  return peek(lexer, _lexer.TokenKind.PAREN_L) ? many(lexer, _lexer.TokenKind.PAREN_L, parseVariableDefinition, _lexer.TokenKind.PAREN_R) : [];\n}\n\n/**\n * VariableDefinition : Variable : Type DefaultValue?\n */\nfunction parseVariableDefinition(lexer) {\n  var start = lexer.token;\n  return {\n    kind: _kinds.VARIABLE_DEFINITION,\n    variable: parseVariable(lexer),\n    type: (expect(lexer, _lexer.TokenKind.COLON), parseTypeReference(lexer)),\n    defaultValue: skip(lexer, _lexer.TokenKind.EQUALS) ? parseValueLiteral(lexer, true) : null,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * Variable : $ Name\n */\nfunction parseVariable(lexer) {\n  var start = lexer.token;\n  expect(lexer, _lexer.TokenKind.DOLLAR);\n  return {\n    kind: _kinds.VARIABLE,\n    name: parseName(lexer),\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * SelectionSet : { Selection+ }\n */\nfunction parseSelectionSet(lexer) {\n  var start = lexer.token;\n  return {\n    kind: _kinds.SELECTION_SET,\n    selections: many(lexer, _lexer.TokenKind.BRACE_L, parseSelection, _lexer.TokenKind.BRACE_R),\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * Selection :\n *   - Field\n *   - FragmentSpread\n *   - InlineFragment\n */\nfunction parseSelection(lexer) {\n  return peek(lexer, _lexer.TokenKind.SPREAD) ? parseFragment(lexer) : parseField(lexer);\n}\n\n/**\n * Field : Alias? Name Arguments? Directives? SelectionSet?\n *\n * Alias : Name :\n */\nfunction parseField(lexer) {\n  var start = lexer.token;\n\n  var nameOrAlias = parseName(lexer);\n  var alias = void 0;\n  var name = void 0;\n  if (skip(lexer, _lexer.TokenKind.COLON)) {\n    alias = nameOrAlias;\n    name = parseName(lexer);\n  } else {\n    alias = null;\n    name = nameOrAlias;\n  }\n\n  return {\n    kind: _kinds.FIELD,\n    alias: alias,\n    name: name,\n    arguments: parseArguments(lexer),\n    directives: parseDirectives(lexer),\n    selectionSet: peek(lexer, _lexer.TokenKind.BRACE_L) ? parseSelectionSet(lexer) : null,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * Arguments : ( Argument+ )\n */\nfunction parseArguments(lexer) {\n  return peek(lexer, _lexer.TokenKind.PAREN_L) ? many(lexer, _lexer.TokenKind.PAREN_L, parseArgument, _lexer.TokenKind.PAREN_R) : [];\n}\n\n/**\n * Argument : Name : Value\n */\nfunction parseArgument(lexer) {\n  var start = lexer.token;\n  return {\n    kind: _kinds.ARGUMENT,\n    name: parseName(lexer),\n    value: (expect(lexer, _lexer.TokenKind.COLON), parseValueLiteral(lexer, false)),\n    loc: loc(lexer, start)\n  };\n}\n\n// Implements the parsing rules in the Fragments section.\n\n/**\n * Corresponds to both FragmentSpread and InlineFragment in the spec.\n *\n * FragmentSpread : ... FragmentName Directives?\n *\n * InlineFragment : ... TypeCondition? Directives? SelectionSet\n */\nfunction parseFragment(lexer) {\n  var start = lexer.token;\n  expect(lexer, _lexer.TokenKind.SPREAD);\n  if (peek(lexer, _lexer.TokenKind.NAME) && lexer.token.value !== 'on') {\n    return {\n      kind: _kinds.FRAGMENT_SPREAD,\n      name: parseFragmentName(lexer),\n      directives: parseDirectives(lexer),\n      loc: loc(lexer, start)\n    };\n  }\n  var typeCondition = null;\n  if (lexer.token.value === 'on') {\n    lexer.advance();\n    typeCondition = parseNamedType(lexer);\n  }\n  return {\n    kind: _kinds.INLINE_FRAGMENT,\n    typeCondition: typeCondition,\n    directives: parseDirectives(lexer),\n    selectionSet: parseSelectionSet(lexer),\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * FragmentDefinition :\n *   - fragment FragmentName on TypeCondition Directives? SelectionSet\n *\n * TypeCondition : NamedType\n */\nfunction parseFragmentDefinition(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'fragment');\n  return {\n    kind: _kinds.FRAGMENT_DEFINITION,\n    name: parseFragmentName(lexer),\n    typeCondition: (expectKeyword(lexer, 'on'), parseNamedType(lexer)),\n    directives: parseDirectives(lexer),\n    selectionSet: parseSelectionSet(lexer),\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * FragmentName : Name but not `on`\n */\nfunction parseFragmentName(lexer) {\n  if (lexer.token.value === 'on') {\n    throw unexpected(lexer);\n  }\n  return parseName(lexer);\n}\n\n// Implements the parsing rules in the Values section.\n\n/**\n * Value[Const] :\n *   - [~Const] Variable\n *   - IntValue\n *   - FloatValue\n *   - StringValue\n *   - BooleanValue\n *   - NullValue\n *   - EnumValue\n *   - ListValue[?Const]\n *   - ObjectValue[?Const]\n *\n * BooleanValue : one of `true` `false`\n *\n * NullValue : `null`\n *\n * EnumValue : Name but not `true`, `false` or `null`\n */\nfunction parseValueLiteral(lexer, isConst) {\n  var token = lexer.token;\n  switch (token.kind) {\n    case _lexer.TokenKind.BRACKET_L:\n      return parseList(lexer, isConst);\n    case _lexer.TokenKind.BRACE_L:\n      return parseObject(lexer, isConst);\n    case _lexer.TokenKind.INT:\n      lexer.advance();\n      return {\n        kind: _kinds.INT,\n        value: token.value,\n        loc: loc(lexer, token)\n      };\n    case _lexer.TokenKind.FLOAT:\n      lexer.advance();\n      return {\n        kind: _kinds.FLOAT,\n        value: token.value,\n        loc: loc(lexer, token)\n      };\n    case _lexer.TokenKind.STRING:\n      lexer.advance();\n      return {\n        kind: _kinds.STRING,\n        value: token.value,\n        loc: loc(lexer, token)\n      };\n    case _lexer.TokenKind.NAME:\n      if (token.value === 'true' || token.value === 'false') {\n        lexer.advance();\n        return {\n          kind: _kinds.BOOLEAN,\n          value: token.value === 'true',\n          loc: loc(lexer, token)\n        };\n      } else if (token.value === 'null') {\n        lexer.advance();\n        return {\n          kind: _kinds.NULL,\n          loc: loc(lexer, token)\n        };\n      }\n      lexer.advance();\n      return {\n        kind: _kinds.ENUM,\n        value: token.value,\n        loc: loc(lexer, token)\n      };\n    case _lexer.TokenKind.DOLLAR:\n      if (!isConst) {\n        return parseVariable(lexer);\n      }\n      break;\n  }\n  throw unexpected(lexer);\n}\n\nfunction parseConstValue(lexer) {\n  return parseValueLiteral(lexer, true);\n}\n\nfunction parseValueValue(lexer) {\n  return parseValueLiteral(lexer, false);\n}\n\n/**\n * ListValue[Const] :\n *   - [ ]\n *   - [ Value[?Const]+ ]\n */\nfunction parseList(lexer, isConst) {\n  var start = lexer.token;\n  var item = isConst ? parseConstValue : parseValueValue;\n  return {\n    kind: _kinds.LIST,\n    values: any(lexer, _lexer.TokenKind.BRACKET_L, item, _lexer.TokenKind.BRACKET_R),\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * ObjectValue[Const] :\n *   - { }\n *   - { ObjectField[?Const]+ }\n */\nfunction parseObject(lexer, isConst) {\n  var start = lexer.token;\n  expect(lexer, _lexer.TokenKind.BRACE_L);\n  var fields = [];\n  while (!skip(lexer, _lexer.TokenKind.BRACE_R)) {\n    fields.push(parseObjectField(lexer, isConst));\n  }\n  return {\n    kind: _kinds.OBJECT,\n    fields: fields,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * ObjectField[Const] : Name : Value[?Const]\n */\nfunction parseObjectField(lexer, isConst) {\n  var start = lexer.token;\n  return {\n    kind: _kinds.OBJECT_FIELD,\n    name: parseName(lexer),\n    value: (expect(lexer, _lexer.TokenKind.COLON), parseValueLiteral(lexer, isConst)),\n    loc: loc(lexer, start)\n  };\n}\n\n// Implements the parsing rules in the Directives section.\n\n/**\n * Directives : Directive+\n */\nfunction parseDirectives(lexer) {\n  var directives = [];\n  while (peek(lexer, _lexer.TokenKind.AT)) {\n    directives.push(parseDirective(lexer));\n  }\n  return directives;\n}\n\n/**\n * Directive : @ Name Arguments?\n */\nfunction parseDirective(lexer) {\n  var start = lexer.token;\n  expect(lexer, _lexer.TokenKind.AT);\n  return {\n    kind: _kinds.DIRECTIVE,\n    name: parseName(lexer),\n    arguments: parseArguments(lexer),\n    loc: loc(lexer, start)\n  };\n}\n\n// Implements the parsing rules in the Types section.\n\n/**\n * Type :\n *   - NamedType\n *   - ListType\n *   - NonNullType\n */\nfunction parseTypeReference(lexer) {\n  var start = lexer.token;\n  var type = void 0;\n  if (skip(lexer, _lexer.TokenKind.BRACKET_L)) {\n    type = parseTypeReference(lexer);\n    expect(lexer, _lexer.TokenKind.BRACKET_R);\n    type = {\n      kind: _kinds.LIST_TYPE,\n      type: type,\n      loc: loc(lexer, start)\n    };\n  } else {\n    type = parseNamedType(lexer);\n  }\n  if (skip(lexer, _lexer.TokenKind.BANG)) {\n    return {\n      kind: _kinds.NON_NULL_TYPE,\n      type: type,\n      loc: loc(lexer, start)\n    };\n  }\n  return type;\n}\n\n/**\n * NamedType : Name\n */\nfunction parseNamedType(lexer) {\n  var start = lexer.token;\n  return {\n    kind: _kinds.NAMED_TYPE,\n    name: parseName(lexer),\n    loc: loc(lexer, start)\n  };\n}\n\n// Implements the parsing rules in the Type Definition section.\n\n/**\n * TypeSystemDefinition :\n *   - SchemaDefinition\n *   - TypeDefinition\n *   - TypeExtensionDefinition\n *   - DirectiveDefinition\n *\n * TypeDefinition :\n *   - ScalarTypeDefinition\n *   - ObjectTypeDefinition\n *   - InterfaceTypeDefinition\n *   - UnionTypeDefinition\n *   - EnumTypeDefinition\n *   - InputObjectTypeDefinition\n */\nfunction parseTypeSystemDefinition(lexer) {\n  if (peek(lexer, _lexer.TokenKind.NAME)) {\n    switch (lexer.token.value) {\n      case 'schema':\n        return parseSchemaDefinition(lexer);\n      case 'scalar':\n        return parseScalarTypeDefinition(lexer);\n      case 'type':\n        return parseObjectTypeDefinition(lexer);\n      case 'interface':\n        return parseInterfaceTypeDefinition(lexer);\n      case 'union':\n        return parseUnionTypeDefinition(lexer);\n      case 'enum':\n        return parseEnumTypeDefinition(lexer);\n      case 'input':\n        return parseInputObjectTypeDefinition(lexer);\n      case 'extend':\n        return parseTypeExtensionDefinition(lexer);\n      case 'directive':\n        return parseDirectiveDefinition(lexer);\n    }\n  }\n\n  throw unexpected(lexer);\n}\n\n/**\n * SchemaDefinition : schema Directives? { OperationTypeDefinition+ }\n *\n * OperationTypeDefinition : OperationType : NamedType\n */\nfunction parseSchemaDefinition(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'schema');\n  var directives = parseDirectives(lexer);\n  var operationTypes = many(lexer, _lexer.TokenKind.BRACE_L, parseOperationTypeDefinition, _lexer.TokenKind.BRACE_R);\n  return {\n    kind: _kinds.SCHEMA_DEFINITION,\n    directives: directives,\n    operationTypes: operationTypes,\n    loc: loc(lexer, start)\n  };\n}\n\nfunction parseOperationTypeDefinition(lexer) {\n  var start = lexer.token;\n  var operation = parseOperationType(lexer);\n  expect(lexer, _lexer.TokenKind.COLON);\n  var type = parseNamedType(lexer);\n  return {\n    kind: _kinds.OPERATION_TYPE_DEFINITION,\n    operation: operation,\n    type: type,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * ScalarTypeDefinition : scalar Name Directives?\n */\nfunction parseScalarTypeDefinition(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'scalar');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer);\n  return {\n    kind: _kinds.SCALAR_TYPE_DEFINITION,\n    name: name,\n    directives: directives,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * ObjectTypeDefinition :\n *   - type Name ImplementsInterfaces? Directives? { FieldDefinition+ }\n */\nfunction parseObjectTypeDefinition(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'type');\n  var name = parseName(lexer);\n  var interfaces = parseImplementsInterfaces(lexer);\n  var directives = parseDirectives(lexer);\n  var fields = any(lexer, _lexer.TokenKind.BRACE_L, parseFieldDefinition, _lexer.TokenKind.BRACE_R);\n  return {\n    kind: _kinds.OBJECT_TYPE_DEFINITION,\n    name: name,\n    interfaces: interfaces,\n    directives: directives,\n    fields: fields,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * ImplementsInterfaces : implements NamedType+\n */\nfunction parseImplementsInterfaces(lexer) {\n  var types = [];\n  if (lexer.token.value === 'implements') {\n    lexer.advance();\n    do {\n      types.push(parseNamedType(lexer));\n    } while (peek(lexer, _lexer.TokenKind.NAME));\n  }\n  return types;\n}\n\n/**\n * FieldDefinition : Name ArgumentsDefinition? : Type Directives?\n */\nfunction parseFieldDefinition(lexer) {\n  var start = lexer.token;\n  var name = parseName(lexer);\n  var args = parseArgumentDefs(lexer);\n  expect(lexer, _lexer.TokenKind.COLON);\n  var type = parseTypeReference(lexer);\n  var directives = parseDirectives(lexer);\n  return {\n    kind: _kinds.FIELD_DEFINITION,\n    name: name,\n    arguments: args,\n    type: type,\n    directives: directives,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * ArgumentsDefinition : ( InputValueDefinition+ )\n */\nfunction parseArgumentDefs(lexer) {\n  if (!peek(lexer, _lexer.TokenKind.PAREN_L)) {\n    return [];\n  }\n  return many(lexer, _lexer.TokenKind.PAREN_L, parseInputValueDef, _lexer.TokenKind.PAREN_R);\n}\n\n/**\n * InputValueDefinition : Name : Type DefaultValue? Directives?\n */\nfunction parseInputValueDef(lexer) {\n  var start = lexer.token;\n  var name = parseName(lexer);\n  expect(lexer, _lexer.TokenKind.COLON);\n  var type = parseTypeReference(lexer);\n  var defaultValue = null;\n  if (skip(lexer, _lexer.TokenKind.EQUALS)) {\n    defaultValue = parseConstValue(lexer);\n  }\n  var directives = parseDirectives(lexer);\n  return {\n    kind: _kinds.INPUT_VALUE_DEFINITION,\n    name: name,\n    type: type,\n    defaultValue: defaultValue,\n    directives: directives,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * InterfaceTypeDefinition : interface Name Directives? { FieldDefinition+ }\n */\nfunction parseInterfaceTypeDefinition(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'interface');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer);\n  var fields = any(lexer, _lexer.TokenKind.BRACE_L, parseFieldDefinition, _lexer.TokenKind.BRACE_R);\n  return {\n    kind: _kinds.INTERFACE_TYPE_DEFINITION,\n    name: name,\n    directives: directives,\n    fields: fields,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * UnionTypeDefinition : union Name Directives? = UnionMembers\n */\nfunction parseUnionTypeDefinition(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'union');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer);\n  expect(lexer, _lexer.TokenKind.EQUALS);\n  var types = parseUnionMembers(lexer);\n  return {\n    kind: _kinds.UNION_TYPE_DEFINITION,\n    name: name,\n    directives: directives,\n    types: types,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * UnionMembers :\n *   - `|`? NamedType\n *   - UnionMembers | NamedType\n */\nfunction parseUnionMembers(lexer) {\n  // Optional leading pipe\n  skip(lexer, _lexer.TokenKind.PIPE);\n  var members = [];\n  do {\n    members.push(parseNamedType(lexer));\n  } while (skip(lexer, _lexer.TokenKind.PIPE));\n  return members;\n}\n\n/**\n * EnumTypeDefinition : enum Name Directives? { EnumValueDefinition+ }\n */\nfunction parseEnumTypeDefinition(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'enum');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer);\n  var values = many(lexer, _lexer.TokenKind.BRACE_L, parseEnumValueDefinition, _lexer.TokenKind.BRACE_R);\n  return {\n    kind: _kinds.ENUM_TYPE_DEFINITION,\n    name: name,\n    directives: directives,\n    values: values,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * EnumValueDefinition : EnumValue Directives?\n *\n * EnumValue : Name\n */\nfunction parseEnumValueDefinition(lexer) {\n  var start = lexer.token;\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer);\n  return {\n    kind: _kinds.ENUM_VALUE_DEFINITION,\n    name: name,\n    directives: directives,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * InputObjectTypeDefinition : input Name Directives? { InputValueDefinition+ }\n */\nfunction parseInputObjectTypeDefinition(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'input');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer);\n  var fields = any(lexer, _lexer.TokenKind.BRACE_L, parseInputValueDef, _lexer.TokenKind.BRACE_R);\n  return {\n    kind: _kinds.INPUT_OBJECT_TYPE_DEFINITION,\n    name: name,\n    directives: directives,\n    fields: fields,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * TypeExtensionDefinition : extend ObjectTypeDefinition\n */\nfunction parseTypeExtensionDefinition(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'extend');\n  var definition = parseObjectTypeDefinition(lexer);\n  return {\n    kind: _kinds.TYPE_EXTENSION_DEFINITION,\n    definition: definition,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * DirectiveDefinition :\n *   - directive @ Name ArgumentsDefinition? on DirectiveLocations\n */\nfunction parseDirectiveDefinition(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'directive');\n  expect(lexer, _lexer.TokenKind.AT);\n  var name = parseName(lexer);\n  var args = parseArgumentDefs(lexer);\n  expectKeyword(lexer, 'on');\n  var locations = parseDirectiveLocations(lexer);\n  return {\n    kind: _kinds.DIRECTIVE_DEFINITION,\n    name: name,\n    arguments: args,\n    locations: locations,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * DirectiveLocations :\n *   - `|`? Name\n *   - DirectiveLocations | Name\n */\nfunction parseDirectiveLocations(lexer) {\n  // Optional leading pipe\n  skip(lexer, _lexer.TokenKind.PIPE);\n  var locations = [];\n  do {\n    locations.push(parseName(lexer));\n  } while (skip(lexer, _lexer.TokenKind.PIPE));\n  return locations;\n}\n\n// Core parsing utility functions\n\n/**\n * Returns a location object, used to identify the place in\n * the source that created a given parsed object.\n */\nfunction loc(lexer, startToken) {\n  if (!lexer.options.noLocation) {\n    return new Loc(startToken, lexer.lastToken, lexer.source);\n  }\n}\n\nfunction Loc(startToken, endToken, source) {\n  this.start = startToken.start;\n  this.end = endToken.end;\n  this.startToken = startToken;\n  this.endToken = endToken;\n  this.source = source;\n}\n\n// Print a simplified form when appearing in JSON/util.inspect.\nLoc.prototype.toJSON = Loc.prototype.inspect = function toJSON() {\n  return { start: this.start, end: this.end };\n};\n\n/**\n * Determines if the next token is of a given kind\n */\nfunction peek(lexer, kind) {\n  return lexer.token.kind === kind;\n}\n\n/**\n * If the next token is of the given kind, return true after advancing\n * the lexer. Otherwise, do not change the parser state and return false.\n */\nfunction skip(lexer, kind) {\n  var match = lexer.token.kind === kind;\n  if (match) {\n    lexer.advance();\n  }\n  return match;\n}\n\n/**\n * If the next token is of the given kind, return that token after advancing\n * the lexer. Otherwise, do not change the parser state and throw an error.\n */\nfunction expect(lexer, kind) {\n  var token = lexer.token;\n  if (token.kind === kind) {\n    lexer.advance();\n    return token;\n  }\n  throw (0, _error.syntaxError)(lexer.source, token.start, 'Expected ' + kind + ', found ' + (0, _lexer.getTokenDesc)(token));\n}\n\n/**\n * If the next token is a keyword with the given value, return that token after\n * advancing the lexer. Otherwise, do not change the parser state and return\n * false.\n */\nfunction expectKeyword(lexer, value) {\n  var token = lexer.token;\n  if (token.kind === _lexer.TokenKind.NAME && token.value === value) {\n    lexer.advance();\n    return token;\n  }\n  throw (0, _error.syntaxError)(lexer.source, token.start, 'Expected \"' + value + '\", found ' + (0, _lexer.getTokenDesc)(token));\n}\n\n/**\n * Helper function for creating an error when an unexpected lexed token\n * is encountered.\n */\nfunction unexpected(lexer, atToken) {\n  var token = atToken || lexer.token;\n  return (0, _error.syntaxError)(lexer.source, token.start, 'Unexpected ' + (0, _lexer.getTokenDesc)(token));\n}\n\n/**\n * Returns a possibly empty list of parse nodes, determined by\n * the parseFn. This list begins with a lex token of openKind\n * and ends with a lex token of closeKind. Advances the parser\n * to the next lex token after the closing token.\n */\nfunction any(lexer, openKind, parseFn, closeKind) {\n  expect(lexer, openKind);\n  var nodes = [];\n  while (!skip(lexer, closeKind)) {\n    nodes.push(parseFn(lexer));\n  }\n  return nodes;\n}\n\n/**\n * Returns a non-empty list of parse nodes, determined by\n * the parseFn. This list begins with a lex token of openKind\n * and ends with a lex token of closeKind. Advances the parser\n * to the next lex token after the closing token.\n */\nfunction many(lexer, openKind, parseFn, closeKind) {\n  expect(lexer, openKind);\n  var nodes = [parseFn(lexer)];\n  while (!skip(lexer, closeKind)) {\n    nodes.push(parseFn(lexer));\n  }\n  return nodes;\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}