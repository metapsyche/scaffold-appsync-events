{"ast":null,"code":"export function buildDelayFunction(_a) {\n  var _b = _a === void 0 ? {} : _a,\n      _c = _b.initial,\n      initial = _c === void 0 ? 300 : _c,\n      _d = _b.max,\n      max = _d === void 0 ? Infinity : _d,\n      _e = _b.jitter,\n      jitter = _e === void 0 ? true : _e;\n\n  var baseDelay;\n\n  if (jitter) {\n    // If we're jittering, baseDelay is half of the maximum delay for that\n    // attempt (and is, on average, the delay we will encounter).\n    baseDelay = initial;\n  } else {\n    // If we're not jittering, adjust baseDelay so that the first attempt\n    // lines up with initialDelay, for everyone's sanity.\n    baseDelay = initial / 2;\n  }\n\n  return function delayFunction(count) {\n    var delay = Math.min(max, baseDelay * Math.pow(2, count));\n\n    if (jitter) {\n      // We opt for a full jitter approach for a mostly uniform distribution,\n      // but bound it within initialDelay and delay for everyone's sanity.\n      delay = Math.random() * delay;\n    }\n\n    return delay;\n  };\n}","map":{"version":3,"sources":["../src/delayFunction.ts"],"names":[],"mappings":"AA2CA,OAAM,SAAU,kBAAV,CAA6B,EAA7B,EAIsB;MAJO,EAAA,GAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAA,E;MACjC,EAAA,GAAA,EAAA,CAAA,O;MAAA,OAAA,GAAA,EAAA,KAAA,KAAA,CAAA,GAAA,GAAA,GAAA,E;MACA,EAAA,GAAA,EAAA,CAAA,G;MAAA,GAAA,GAAA,EAAA,KAAA,KAAA,CAAA,GAAA,QAAA,GAAA,E;MACA,EAAA,GAAA,EAAA,CAAA,M;MAAA,MAAA,GAAA,EAAA,KAAA,KAAA,CAAA,GAAA,IAAA,GAAA,E;;EAEA,IAAI,SAAJ;;EACA,IAAI,MAAJ,EAAY;IACV;IACA;IACA,SAAS,GAAG,OAAZ;EACD,CAJD,MAIO;IACL;IACA;IACA,SAAS,GAAG,OAAO,GAAG,CAAtB;EACD;;EAED,OAAO,SAAS,aAAT,CAAuB,KAAvB,EAAoC;IACzC,IAAI,KAAK,GAAG,IAAI,CAAC,GAAL,CAAS,GAAT,EAAc,SAAS,GAAG,IAAA,CAAA,GAAA,CAAA,CAAA,EAAK,KAAL,CAA1B,CAAZ;;IACA,IAAI,MAAJ,EAAY;MACV;MACA;MACA,KAAK,GAAG,IAAI,CAAC,MAAL,KAAgB,KAAxB;IACD;;IAED,OAAO,KAAP;EACD,CATD;AAUD","sourceRoot":"","sourcesContent":["export function buildDelayFunction(_a) {\n    var _b = _a === void 0 ? {} : _a, _c = _b.initial, initial = _c === void 0 ? 300 : _c, _d = _b.max, max = _d === void 0 ? Infinity : _d, _e = _b.jitter, jitter = _e === void 0 ? true : _e;\n    var baseDelay;\n    if (jitter) {\n        // If we're jittering, baseDelay is half of the maximum delay for that\n        // attempt (and is, on average, the delay we will encounter).\n        baseDelay = initial;\n    }\n    else {\n        // If we're not jittering, adjust baseDelay so that the first attempt\n        // lines up with initialDelay, for everyone's sanity.\n        baseDelay = initial / 2;\n    }\n    return function delayFunction(count) {\n        var delay = Math.min(max, baseDelay * Math.pow(2, count));\n        if (jitter) {\n            // We opt for a full jitter approach for a mostly uniform distribution,\n            // but bound it within initialDelay and delay for everyone's sanity.\n            delay = Math.random() * delay;\n        }\n        return delay;\n    };\n}\n//# sourceMappingURL=delayFunction.js.map"]},"metadata":{},"sourceType":"module"}