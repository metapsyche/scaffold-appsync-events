{"ast":null,"code":"/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { GraphQLError } from '../error';\nimport find from '../jsutils/find';\nimport isInvalid from '../jsutils/isInvalid';\nimport keyMap from '../jsutils/keyMap';\nimport { coerceValue } from '../utilities/coerceValue';\nimport { typeFromAST } from '../utilities/typeFromAST';\nimport { valueFromAST } from '../utilities/valueFromAST';\nimport { Kind } from '../language/kinds';\nimport { print } from '../language/printer';\nimport { isInputType, isNonNullType } from '../type/definition';\n/**\n * Prepares an object map of variableValues of the correct type based on the\n * provided variable definitions and arbitrary input. If the input cannot be\n * parsed to match the variable definitions, a GraphQLError will be thrown.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\n\nexport function getVariableValues(schema, varDefNodes, inputs) {\n  var errors = [];\n  var coercedValues = {};\n\n  for (var i = 0; i < varDefNodes.length; i++) {\n    var varDefNode = varDefNodes[i];\n    var varName = varDefNode.variable.name.value;\n    var varType = typeFromAST(schema, varDefNode.type);\n\n    if (!isInputType(varType)) {\n      errors.push(new GraphQLError('Variable \"$' + varName + '\" expected value of type ' + ('\"' + print(varDefNode.type) + '\" which cannot be used as an input type.'), [varDefNode.type]));\n    } else {\n      var value = inputs[varName];\n\n      if (isInvalid(value)) {\n        if (isNonNullType(varType)) {\n          errors.push(new GraphQLError('Variable \"$' + varName + '\" of required type ' + ('\"' + String(varType) + '\" was not provided.'), [varDefNode]));\n        } else if (varDefNode.defaultValue) {\n          coercedValues[varName] = valueFromAST(varDefNode.defaultValue, varType);\n        }\n      } else {\n        var _coerced = coerceValue(value, varType, varDefNode);\n\n        var coercionErrors = _coerced.errors;\n\n        if (coercionErrors) {\n          (function () {\n            var messagePrelude = 'Variable \"$' + varName + '\" got invalid value ' + JSON.stringify(value) + '; ';\n            coercionErrors.forEach(function (error) {\n              error.message = messagePrelude + error.message;\n            });\n            errors.push.apply(errors, coercionErrors);\n          })();\n        } else {\n          coercedValues[varName] = _coerced.value;\n        }\n      }\n    }\n  }\n\n  return errors.length === 0 ? {\n    errors: undefined,\n    coerced: coercedValues\n  } : {\n    errors: errors,\n    coerced: undefined\n  };\n}\n/**\n * Prepares an object map of argument values given a list of argument\n * definitions and list of argument AST nodes.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\n\nexport function getArgumentValues(def, node, variableValues) {\n  var coercedValues = {};\n  var argDefs = def.args;\n  var argNodes = node.arguments;\n\n  if (!argDefs || !argNodes) {\n    return coercedValues;\n  }\n\n  var argNodeMap = keyMap(argNodes, function (arg) {\n    return arg.name.value;\n  });\n\n  for (var i = 0; i < argDefs.length; i++) {\n    var argDef = argDefs[i];\n    var name = argDef.name;\n    var argType = argDef.type;\n    var argumentNode = argNodeMap[name];\n    var defaultValue = argDef.defaultValue;\n\n    if (!argumentNode) {\n      if (!isInvalid(defaultValue)) {\n        coercedValues[name] = defaultValue;\n      } else if (isNonNullType(argType)) {\n        throw new GraphQLError('Argument \"' + name + '\" of required type ' + ('\"' + String(argType) + '\" was not provided.'), [node]);\n      }\n    } else if (argumentNode.value.kind === Kind.VARIABLE) {\n      var variableName = argumentNode.value.name.value;\n\n      if (variableValues && Object.prototype.hasOwnProperty.call(variableValues, variableName) && !isInvalid(variableValues[variableName])) {\n        // Note: this does not check that this variable value is correct.\n        // This assumes that this query has been validated and the variable\n        // usage here is of the correct type.\n        coercedValues[name] = variableValues[variableName];\n      } else if (!isInvalid(defaultValue)) {\n        coercedValues[name] = defaultValue;\n      } else if (isNonNullType(argType)) {\n        throw new GraphQLError('Argument \"' + name + '\" of required type \"' + String(argType) + '\" was ' + ('provided the variable \"$' + variableName + '\" which was not provided ') + 'a runtime value.', [argumentNode.value]);\n      }\n    } else {\n      var valueNode = argumentNode.value;\n      var coercedValue = valueFromAST(valueNode, argType, variableValues);\n\n      if (isInvalid(coercedValue)) {\n        // Note: ValuesOfCorrectType validation should catch this before\n        // execution. This is a runtime check to ensure execution does not\n        // continue with an invalid argument value.\n        throw new GraphQLError('Argument \"' + name + '\" has invalid value ' + print(valueNode) + '.', [argumentNode.value]);\n      }\n\n      coercedValues[name] = coercedValue;\n    }\n  }\n\n  return coercedValues;\n}\n/**\n * Prepares an object map of argument values given a directive definition\n * and a AST node which may contain directives. Optionally also accepts a map\n * of variable values.\n *\n * If the directive does not exist on the node, returns undefined.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\n\nexport function getDirectiveValues(directiveDef, node, variableValues) {\n  var directiveNode = node.directives && find(node.directives, function (directive) {\n    return directive.name.value === directiveDef.name;\n  });\n\n  if (directiveNode) {\n    return getArgumentValues(directiveDef, directiveNode, variableValues);\n  }\n}","map":{"version":3,"names":["GraphQLError","find","isInvalid","keyMap","coerceValue","typeFromAST","valueFromAST","Kind","print","isInputType","isNonNullType","getVariableValues","schema","varDefNodes","inputs","errors","coercedValues","i","length","varDefNode","varName","variable","name","value","varType","type","push","String","defaultValue","_coerced","coercionErrors","messagePrelude","JSON","stringify","forEach","error","message","apply","undefined","coerced","getArgumentValues","def","node","variableValues","argDefs","args","argNodes","arguments","argNodeMap","arg","argDef","argType","argumentNode","kind","VARIABLE","variableName","Object","prototype","hasOwnProperty","call","valueNode","coercedValue","getDirectiveValues","directiveDef","directiveNode","directives","directive"],"sources":["/Users/roaldmaravillas/ro/sandbox/aws-mobile-appsync-events-starter-react/node_modules/aws-appsync/node_modules/graphql/module/execution/values.js"],"sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nimport { GraphQLError } from '../error';\nimport find from '../jsutils/find';\nimport isInvalid from '../jsutils/isInvalid';\nimport keyMap from '../jsutils/keyMap';\nimport { coerceValue } from '../utilities/coerceValue';\nimport { typeFromAST } from '../utilities/typeFromAST';\nimport { valueFromAST } from '../utilities/valueFromAST';\nimport { Kind } from '../language/kinds';\nimport { print } from '../language/printer';\nimport { isInputType, isNonNullType } from '../type/definition';\n\n\n/**\n * Prepares an object map of variableValues of the correct type based on the\n * provided variable definitions and arbitrary input. If the input cannot be\n * parsed to match the variable definitions, a GraphQLError will be thrown.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\nexport function getVariableValues(schema, varDefNodes, inputs) {\n  var errors = [];\n  var coercedValues = {};\n  for (var i = 0; i < varDefNodes.length; i++) {\n    var varDefNode = varDefNodes[i];\n    var varName = varDefNode.variable.name.value;\n    var varType = typeFromAST(schema, varDefNode.type);\n    if (!isInputType(varType)) {\n      errors.push(new GraphQLError('Variable \"$' + varName + '\" expected value of type ' + ('\"' + print(varDefNode.type) + '\" which cannot be used as an input type.'), [varDefNode.type]));\n    } else {\n      var value = inputs[varName];\n      if (isInvalid(value)) {\n        if (isNonNullType(varType)) {\n          errors.push(new GraphQLError('Variable \"$' + varName + '\" of required type ' + ('\"' + String(varType) + '\" was not provided.'), [varDefNode]));\n        } else if (varDefNode.defaultValue) {\n          coercedValues[varName] = valueFromAST(varDefNode.defaultValue, varType);\n        }\n      } else {\n        var _coerced = coerceValue(value, varType, varDefNode);\n        var coercionErrors = _coerced.errors;\n        if (coercionErrors) {\n          (function () {\n            var messagePrelude = 'Variable \"$' + varName + '\" got invalid value ' + JSON.stringify(value) + '; ';\n            coercionErrors.forEach(function (error) {\n              error.message = messagePrelude + error.message;\n            });\n            errors.push.apply(errors, coercionErrors);\n          })();\n        } else {\n          coercedValues[varName] = _coerced.value;\n        }\n      }\n    }\n  }\n  return errors.length === 0 ? { errors: undefined, coerced: coercedValues } : { errors: errors, coerced: undefined };\n}\n\n/**\n * Prepares an object map of argument values given a list of argument\n * definitions and list of argument AST nodes.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\nexport function getArgumentValues(def, node, variableValues) {\n  var coercedValues = {};\n  var argDefs = def.args;\n  var argNodes = node.arguments;\n  if (!argDefs || !argNodes) {\n    return coercedValues;\n  }\n  var argNodeMap = keyMap(argNodes, function (arg) {\n    return arg.name.value;\n  });\n  for (var i = 0; i < argDefs.length; i++) {\n    var argDef = argDefs[i];\n    var name = argDef.name;\n    var argType = argDef.type;\n    var argumentNode = argNodeMap[name];\n    var defaultValue = argDef.defaultValue;\n    if (!argumentNode) {\n      if (!isInvalid(defaultValue)) {\n        coercedValues[name] = defaultValue;\n      } else if (isNonNullType(argType)) {\n        throw new GraphQLError('Argument \"' + name + '\" of required type ' + ('\"' + String(argType) + '\" was not provided.'), [node]);\n      }\n    } else if (argumentNode.value.kind === Kind.VARIABLE) {\n      var variableName = argumentNode.value.name.value;\n      if (variableValues && Object.prototype.hasOwnProperty.call(variableValues, variableName) && !isInvalid(variableValues[variableName])) {\n        // Note: this does not check that this variable value is correct.\n        // This assumes that this query has been validated and the variable\n        // usage here is of the correct type.\n        coercedValues[name] = variableValues[variableName];\n      } else if (!isInvalid(defaultValue)) {\n        coercedValues[name] = defaultValue;\n      } else if (isNonNullType(argType)) {\n        throw new GraphQLError('Argument \"' + name + '\" of required type \"' + String(argType) + '\" was ' + ('provided the variable \"$' + variableName + '\" which was not provided ') + 'a runtime value.', [argumentNode.value]);\n      }\n    } else {\n      var valueNode = argumentNode.value;\n      var coercedValue = valueFromAST(valueNode, argType, variableValues);\n      if (isInvalid(coercedValue)) {\n        // Note: ValuesOfCorrectType validation should catch this before\n        // execution. This is a runtime check to ensure execution does not\n        // continue with an invalid argument value.\n        throw new GraphQLError('Argument \"' + name + '\" has invalid value ' + print(valueNode) + '.', [argumentNode.value]);\n      }\n      coercedValues[name] = coercedValue;\n    }\n  }\n  return coercedValues;\n}\n\n/**\n * Prepares an object map of argument values given a directive definition\n * and a AST node which may contain directives. Optionally also accepts a map\n * of variable values.\n *\n * If the directive does not exist on the node, returns undefined.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\nexport function getDirectiveValues(directiveDef, node, variableValues) {\n  var directiveNode = node.directives && find(node.directives, function (directive) {\n    return directive.name.value === directiveDef.name;\n  });\n\n  if (directiveNode) {\n    return getArgumentValues(directiveDef, directiveNode, variableValues);\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}