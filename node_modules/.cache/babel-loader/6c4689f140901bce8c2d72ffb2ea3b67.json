{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nimport { GraphQLError } from '../../error';\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nimport find from '../../jsutils/find';\nimport { Kind } from '../../language/kinds';\nimport { print } from '../../language/printer';\nimport { getNamedType, isNonNullType, isLeafType, isObjectType, isListType, isInterfaceType } from '../../type/definition';\nimport { typeFromAST } from '../../utilities/typeFromAST';\nexport function fieldsConflictMessage(responseName, reason) {\n  return 'Fields \"' + responseName + '\" conflict because ' + reasonMessage(reason) + '. Use different aliases on the fields to fetch both if this was ' + 'intentional.';\n}\n\nfunction reasonMessage(reason) {\n  if (Array.isArray(reason)) {\n    return reason.map(function (_ref) {\n      var responseName = _ref[0],\n          subreason = _ref[1];\n      return 'subfields \"' + responseName + '\" conflict because ' + reasonMessage(subreason);\n    }).join(' and ');\n  }\n\n  return reason;\n}\n/**\n * Overlapping fields can be merged\n *\n * A selection set is only valid if all fields (including spreading any\n * fragments) either correspond to distinct response names or can be merged\n * without ambiguity.\n */\n\n\nexport function OverlappingFieldsCanBeMerged(context) {\n  // A memoization for when two fragments are compared \"between\" each other for\n  // conflicts. Two fragments may be compared many times, so memoizing this can\n  // dramatically improve the performance of this validator.\n  var comparedFragmentPairs = new PairSet(); // A cache for the \"field map\" and list of fragment names found in any given\n  // selection set. Selection sets may be asked for this information multiple\n  // times, so this improves the performance of this validator.\n\n  var cachedFieldsAndFragmentNames = new Map();\n  return {\n    SelectionSet: function SelectionSet(selectionSet) {\n      var conflicts = findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, context.getParentType(), selectionSet);\n      conflicts.forEach(function (_ref2) {\n        var _ref2$ = _ref2[0],\n            responseName = _ref2$[0],\n            reason = _ref2$[1],\n            fields1 = _ref2[1],\n            fields2 = _ref2[2];\n        return context.reportError(new GraphQLError(fieldsConflictMessage(responseName, reason), fields1.concat(fields2)));\n      });\n    }\n  };\n} // Field name and reason.\n// Reason is a string, or a nested list of conflicts.\n// Tuple defining a field node in a context.\n// Map of array of those.\n\n/**\n * Algorithm:\n *\n * Conflicts occur when two fields exist in a query which will produce the same\n * response name, but represent differing values, thus creating a conflict.\n * The algorithm below finds all conflicts via making a series of comparisons\n * between fields. In order to compare as few fields as possible, this makes\n * a series of comparisons \"within\" sets of fields and \"between\" sets of fields.\n *\n * Given any selection set, a collection produces both a set of fields by\n * also including all inline fragments, as well as a list of fragments\n * referenced by fragment spreads.\n *\n * A) Each selection set represented in the document first compares \"within\" its\n * collected set of fields, finding any conflicts between every pair of\n * overlapping fields.\n * Note: This is the *only time* that a the fields \"within\" a set are compared\n * to each other. After this only fields \"between\" sets are compared.\n *\n * B) Also, if any fragment is referenced in a selection set, then a\n * comparison is made \"between\" the original set of fields and the\n * referenced fragment.\n *\n * C) Also, if multiple fragments are referenced, then comparisons\n * are made \"between\" each referenced fragment.\n *\n * D) When comparing \"between\" a set of fields and a referenced fragment, first\n * a comparison is made between each field in the original set of fields and\n * each field in the the referenced set of fields.\n *\n * E) Also, if any fragment is referenced in the referenced selection set,\n * then a comparison is made \"between\" the original set of fields and the\n * referenced fragment (recursively referring to step D).\n *\n * F) When comparing \"between\" two fragments, first a comparison is made between\n * each field in the first referenced set of fields and each field in the the\n * second referenced set of fields.\n *\n * G) Also, any fragments referenced by the first must be compared to the\n * second, and any fragments referenced by the second must be compared to the\n * first (recursively referring to step F).\n *\n * H) When comparing two fields, if both have selection sets, then a comparison\n * is made \"between\" both selection sets, first comparing the set of fields in\n * the first selection set with the set of fields in the second.\n *\n * I) Also, if any fragment is referenced in either selection set, then a\n * comparison is made \"between\" the other set of fields and the\n * referenced fragment.\n *\n * J) Also, if two fragments are referenced in both selection sets, then a\n * comparison is made \"between\" the two fragments.\n *\n */\n// Find all conflicts found \"within\" a selection set, including those found\n// via spreading in fragments. Called when visiting each SelectionSet in the\n// GraphQL Document.\n\nfunction findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentType, selectionSet) {\n  var conflicts = [];\n\n  var _getFieldsAndFragment = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet),\n      fieldMap = _getFieldsAndFragment[0],\n      fragmentNames = _getFieldsAndFragment[1]; // (A) Find find all conflicts \"within\" the fields of this selection set.\n  // Note: this is the *only place* `collectConflictsWithin` is called.\n\n\n  collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap);\n\n  if (fragmentNames.length !== 0) {\n    // (B) Then collect conflicts between these fields and those represented by\n    // each spread fragment name found.\n    var comparedFragments = Object.create(null);\n\n    for (var i = 0; i < fragmentNames.length; i++) {\n      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, comparedFragmentPairs, false, fieldMap, fragmentNames[i]); // (C) Then compare this fragment with all other fragments found in this\n      // selection set to collect conflicts between fragments spread together.\n      // This compares each item in the list of fragment names to every other\n      // item in that same list (except for itself).\n\n      for (var j = i + 1; j < fragmentNames.length; j++) {\n        collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fragmentNames[i], fragmentNames[j]);\n      }\n    }\n  }\n\n  return conflicts;\n} // Collect all conflicts found between a set of fields and a fragment reference\n// including via spreading in any nested fragments.\n\n\nfunction collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {\n  // Memoize so a fragment is not compared for conflicts more than once.\n  if (comparedFragments[fragmentName]) {\n    return;\n  }\n\n  comparedFragments[fragmentName] = true;\n  var fragment = context.getFragment(fragmentName);\n\n  if (!fragment) {\n    return;\n  }\n\n  var _getReferencedFieldsA = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment),\n      fieldMap2 = _getReferencedFieldsA[0],\n      fragmentNames2 = _getReferencedFieldsA[1]; // Do not compare a fragment's fieldMap to itself.\n\n\n  if (fieldMap === fieldMap2) {\n    return;\n  } // (D) First collect any conflicts between the provided collection of fields\n  // and the collection of fields represented by the given fragment.\n\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fieldMap2); // (E) Then collect any conflicts between the provided collection of fields\n  // and any fragment names found in the given fragment.\n\n  for (var i = 0; i < fragmentNames2.length; i++) {\n    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentNames2[i]);\n  }\n} // Collect all conflicts found between two fragments, including via spreading in\n// any nested fragments.\n\n\nfunction collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {\n  // No need to compare a fragment to itself.\n  if (fragmentName1 === fragmentName2) {\n    return;\n  } // Memoize so two fragments are not compared for conflicts more than once.\n\n\n  if (comparedFragmentPairs.has(fragmentName1, fragmentName2, areMutuallyExclusive)) {\n    return;\n  }\n\n  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);\n  var fragment1 = context.getFragment(fragmentName1);\n  var fragment2 = context.getFragment(fragmentName2);\n\n  if (!fragment1 || !fragment2) {\n    return;\n  }\n\n  var _getReferencedFieldsA2 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment1),\n      fieldMap1 = _getReferencedFieldsA2[0],\n      fragmentNames1 = _getReferencedFieldsA2[1];\n\n  var _getReferencedFieldsA3 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment2),\n      fieldMap2 = _getReferencedFieldsA3[0],\n      fragmentNames2 = _getReferencedFieldsA3[1]; // (F) First, collect all conflicts between these two collections of fields\n  // (not including any nested fragments).\n\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2); // (G) Then collect conflicts between the first fragment and any nested\n  // fragments spread in the second fragment.\n\n  for (var j = 0; j < fragmentNames2.length; j++) {\n    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentNames2[j]);\n  } // (G) Then collect conflicts between the second fragment and any nested\n  // fragments spread in the first fragment.\n\n\n  for (var i = 0; i < fragmentNames1.length; i++) {\n    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentNames1[i], fragmentName2);\n  }\n} // Find all conflicts found between two selection sets, including those found\n// via spreading in fragments. Called when determining if conflicts exist\n// between the sub-fields of two overlapping fields.\n\n\nfunction findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {\n  var conflicts = [];\n\n  var _getFieldsAndFragment2 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType1, selectionSet1),\n      fieldMap1 = _getFieldsAndFragment2[0],\n      fragmentNames1 = _getFieldsAndFragment2[1];\n\n  var _getFieldsAndFragment3 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType2, selectionSet2),\n      fieldMap2 = _getFieldsAndFragment3[0],\n      fragmentNames2 = _getFieldsAndFragment3[1]; // (H) First, collect all conflicts between these two collections of field.\n\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2); // (I) Then collect conflicts between the first collection of fields and\n  // those referenced by each fragment name associated with the second.\n\n  if (fragmentNames2.length !== 0) {\n    var comparedFragments = Object.create(null);\n\n    for (var j = 0; j < fragmentNames2.length; j++) {\n      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fragmentNames2[j]);\n    }\n  } // (I) Then collect conflicts between the second collection of fields and\n  // those referenced by each fragment name associated with the first.\n\n\n  if (fragmentNames1.length !== 0) {\n    var _comparedFragments = Object.create(null);\n\n    for (var i = 0; i < fragmentNames1.length; i++) {\n      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, _comparedFragments, comparedFragmentPairs, areMutuallyExclusive, fieldMap2, fragmentNames1[i]);\n    }\n  } // (J) Also collect conflicts between any fragment names by the first and\n  // fragment names by the second. This compares each item in the first set of\n  // names to each item in the second set of names.\n\n\n  for (var _i = 0; _i < fragmentNames1.length; _i++) {\n    for (var _j = 0; _j < fragmentNames2.length; _j++) {\n      collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentNames1[_i], fragmentNames2[_j]);\n    }\n  }\n\n  return conflicts;\n} // Collect all Conflicts \"within\" one collection of fields.\n\n\nfunction collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For every response name, if there are multiple fields, they\n  // must be compared to find a potential conflict.\n  Object.keys(fieldMap).forEach(function (responseName) {\n    var fields = fieldMap[responseName]; // This compares every field in the list to every other field in this list\n    // (except to itself). If the list only has one item, nothing needs to\n    // be compared.\n\n    if (fields.length > 1) {\n      for (var i = 0; i < fields.length; i++) {\n        for (var j = i + 1; j < fields.length; j++) {\n          var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, // within one collection is never mutually exclusive\n          responseName, fields[i], fields[j]);\n\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  });\n} // Collect all Conflicts between two collections of fields. This is similar to,\n// but different from the `collectConflictsWithin` function above. This check\n// assumes that `collectConflictsWithin` has already been called on each\n// provided collection of fields. This is true because this validator traverses\n// each individual selection set.\n\n\nfunction collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For any response name which appears in both provided field\n  // maps, each field from the first field map must be compared to every field\n  // in the second field map to find potential conflicts.\n  Object.keys(fieldMap1).forEach(function (responseName) {\n    var fields2 = fieldMap2[responseName];\n\n    if (fields2) {\n      var fields1 = fieldMap1[responseName];\n\n      for (var i = 0; i < fields1.length; i++) {\n        for (var j = 0; j < fields2.length; j++) {\n          var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, fields1[i], fields2[j]);\n\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  });\n} // Determines if there is a conflict between two particular fields, including\n// comparing their sub-fields.\n\n\nfunction findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {\n  var parentType1 = field1[0],\n      node1 = field1[1],\n      def1 = field1[2];\n  var parentType2 = field2[0],\n      node2 = field2[1],\n      def2 = field2[2]; // If it is known that two fields could not possibly apply at the same\n  // time, due to the parent types, then it is safe to permit them to diverge\n  // in aliased field or arguments used as they will not present any ambiguity\n  // by differing.\n  // It is known that two parent types could never overlap if they are\n  // different Object types. Interface or Union types might overlap - if not\n  // in the current state of the schema, then perhaps in some future version,\n  // thus may not safely diverge.\n\n  var areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && isObjectType(parentType1) && isObjectType(parentType2); // The return type for each field.\n\n  var type1 = def1 && def1.type;\n  var type2 = def2 && def2.type;\n\n  if (!areMutuallyExclusive) {\n    // Two aliases must refer to the same field.\n    var name1 = node1.name.value;\n    var name2 = node2.name.value;\n\n    if (name1 !== name2) {\n      return [[responseName, name1 + ' and ' + name2 + ' are different fields'], [node1], [node2]];\n    } // Two field calls must have the same arguments.\n\n\n    if (!sameArguments(node1.arguments || [], node2.arguments || [])) {\n      return [[responseName, 'they have differing arguments'], [node1], [node2]];\n    }\n  }\n\n  if (type1 && type2 && doTypesConflict(type1, type2)) {\n    return [[responseName, 'they return conflicting types ' + String(type1) + ' and ' + String(type2)], [node1], [node2]];\n  } // Collect and compare sub-fields. Use the same \"visited fragment names\" list\n  // for both collections so fields in a fragment reference are never\n  // compared to themselves.\n\n\n  var selectionSet1 = node1.selectionSet;\n  var selectionSet2 = node2.selectionSet;\n\n  if (selectionSet1 && selectionSet2) {\n    var conflicts = findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, getNamedType(type1), selectionSet1, getNamedType(type2), selectionSet2);\n    return subfieldConflicts(conflicts, responseName, node1, node2);\n  }\n}\n\nfunction sameArguments(arguments1, arguments2) {\n  if (arguments1.length !== arguments2.length) {\n    return false;\n  }\n\n  return arguments1.every(function (argument1) {\n    var argument2 = find(arguments2, function (argument) {\n      return argument.name.value === argument1.name.value;\n    });\n\n    if (!argument2) {\n      return false;\n    }\n\n    return sameValue(argument1.value, argument2.value);\n  });\n}\n\nfunction sameValue(value1, value2) {\n  return !value1 && !value2 || print(value1) === print(value2);\n} // Two types conflict if both types could not apply to a value simultaneously.\n// Composite types are ignored as their individual field types will be compared\n// later recursively. However List and Non-Null types must match.\n\n\nfunction doTypesConflict(type1, type2) {\n  if (isListType(type1)) {\n    return isListType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;\n  }\n\n  if (isListType(type2)) {\n    return true;\n  }\n\n  if (isNonNullType(type1)) {\n    return isNonNullType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;\n  }\n\n  if (isNonNullType(type2)) {\n    return true;\n  }\n\n  if (isLeafType(type1) || isLeafType(type2)) {\n    return type1 !== type2;\n  }\n\n  return false;\n} // Given a selection set, return the collection of fields (a mapping of response\n// name to field nodes and definitions) as well as a list of fragment names\n// referenced via fragment spreads.\n\n\nfunction getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {\n  var cached = cachedFieldsAndFragmentNames.get(selectionSet);\n\n  if (!cached) {\n    var nodeAndDefs = Object.create(null);\n    var fragmentNames = Object.create(null);\n\n    _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames);\n\n    cached = [nodeAndDefs, Object.keys(fragmentNames)];\n    cachedFieldsAndFragmentNames.set(selectionSet, cached);\n  }\n\n  return cached;\n} // Given a reference to a fragment, return the represented collection of fields\n// as well as a list of nested fragment names referenced via fragment spreads.\n\n\nfunction getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {\n  // Short-circuit building a type from the node if possible.\n  var cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);\n\n  if (cached) {\n    return cached;\n  }\n\n  var fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);\n  return getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragmentType, fragment.selectionSet);\n}\n\nfunction _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {\n  for (var i = 0; i < selectionSet.selections.length; i++) {\n    var selection = selectionSet.selections[i];\n\n    switch (selection.kind) {\n      case Kind.FIELD:\n        var fieldName = selection.name.value;\n        var fieldDef = void 0;\n\n        if (isObjectType(parentType) || isInterfaceType(parentType)) {\n          fieldDef = parentType.getFields()[fieldName];\n        }\n\n        var responseName = selection.alias ? selection.alias.value : fieldName;\n\n        if (!nodeAndDefs[responseName]) {\n          nodeAndDefs[responseName] = [];\n        }\n\n        nodeAndDefs[responseName].push([parentType, selection, fieldDef]);\n        break;\n\n      case Kind.FRAGMENT_SPREAD:\n        fragmentNames[selection.name.value] = true;\n        break;\n\n      case Kind.INLINE_FRAGMENT:\n        var typeCondition = selection.typeCondition;\n        var inlineFragmentType = typeCondition ? typeFromAST(context.getSchema(), typeCondition) : parentType;\n\n        _collectFieldsAndFragmentNames(context, inlineFragmentType, selection.selectionSet, nodeAndDefs, fragmentNames);\n\n        break;\n    }\n  }\n} // Given a series of Conflicts which occurred between two sub-fields, generate\n// a single Conflict.\n\n\nfunction subfieldConflicts(conflicts, responseName, node1, node2) {\n  if (conflicts.length > 0) {\n    return [[responseName, conflicts.map(function (_ref3) {\n      var reason = _ref3[0];\n      return reason;\n    })], conflicts.reduce(function (allFields, _ref4) {\n      var fields1 = _ref4[1];\n      return allFields.concat(fields1);\n    }, [node1]), conflicts.reduce(function (allFields, _ref5) {\n      var fields2 = _ref5[2];\n      return allFields.concat(fields2);\n    }, [node2])];\n  }\n}\n/**\n * A way to keep track of pairs of things when the ordering of the pair does\n * not matter. We do this by maintaining a sort of double adjacency sets.\n */\n\n\nvar PairSet = function () {\n  function PairSet() {\n    _classCallCheck(this, PairSet);\n\n    this._data = Object.create(null);\n  }\n\n  PairSet.prototype.has = function has(a, b, areMutuallyExclusive) {\n    var first = this._data[a];\n    var result = first && first[b];\n\n    if (result === undefined) {\n      return false;\n    } // areMutuallyExclusive being false is a superset of being true,\n    // hence if we want to know if this PairSet \"has\" these two with no\n    // exclusivity, we have to ensure it was added as such.\n\n\n    if (areMutuallyExclusive === false) {\n      return result === false;\n    }\n\n    return true;\n  };\n\n  PairSet.prototype.add = function add(a, b, areMutuallyExclusive) {\n    _pairSetAdd(this._data, a, b, areMutuallyExclusive);\n\n    _pairSetAdd(this._data, b, a, areMutuallyExclusive);\n  };\n\n  return PairSet;\n}();\n\nfunction _pairSetAdd(data, a, b, areMutuallyExclusive) {\n  var map = data[a];\n\n  if (!map) {\n    map = Object.create(null);\n    data[a] = map;\n  }\n\n  map[b] = areMutuallyExclusive;\n}","map":{"version":3,"names":["_classCallCheck","instance","Constructor","TypeError","GraphQLError","find","Kind","print","getNamedType","isNonNullType","isLeafType","isObjectType","isListType","isInterfaceType","typeFromAST","fieldsConflictMessage","responseName","reason","reasonMessage","Array","isArray","map","_ref","subreason","join","OverlappingFieldsCanBeMerged","context","comparedFragmentPairs","PairSet","cachedFieldsAndFragmentNames","Map","SelectionSet","selectionSet","conflicts","findConflictsWithinSelectionSet","getParentType","forEach","_ref2","_ref2$","fields1","fields2","reportError","concat","parentType","_getFieldsAndFragment","getFieldsAndFragmentNames","fieldMap","fragmentNames","collectConflictsWithin","length","comparedFragments","Object","create","i","collectConflictsBetweenFieldsAndFragment","j","collectConflictsBetweenFragments","areMutuallyExclusive","fragmentName","fragment","getFragment","_getReferencedFieldsA","getReferencedFieldsAndFragmentNames","fieldMap2","fragmentNames2","collectConflictsBetween","fragmentName1","fragmentName2","has","add","fragment1","fragment2","_getReferencedFieldsA2","fieldMap1","fragmentNames1","_getReferencedFieldsA3","findConflictsBetweenSubSelectionSets","parentType1","selectionSet1","parentType2","selectionSet2","_getFieldsAndFragment2","_getFieldsAndFragment3","_comparedFragments","_i","_j","keys","fields","conflict","findConflict","push","parentFieldsAreMutuallyExclusive","field1","field2","node1","def1","node2","def2","type1","type","type2","name1","name","value","name2","sameArguments","arguments","doTypesConflict","String","subfieldConflicts","arguments1","arguments2","every","argument1","argument2","argument","sameValue","value1","value2","ofType","cached","get","nodeAndDefs","_collectFieldsAndFragmentNames","set","fragmentType","getSchema","typeCondition","selections","selection","kind","FIELD","fieldName","fieldDef","getFields","alias","FRAGMENT_SPREAD","INLINE_FRAGMENT","inlineFragmentType","_ref3","reduce","allFields","_ref4","_ref5","_data","prototype","a","b","first","result","undefined","_pairSetAdd","data"],"sources":["/Users/roaldmaravillas/ro/github/scaffold-appsync-events/node_modules/aws-appsync/node_modules/graphql/module/validation/rules/OverlappingFieldsCanBeMerged.js"],"sourcesContent":["function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nimport { GraphQLError } from '../../error'; /**\n                                             * Copyright (c) 2015-present, Facebook, Inc.\n                                             *\n                                             * This source code is licensed under the MIT license found in the\n                                             * LICENSE file in the root directory of this source tree.\n                                             *\n                                             * \n                                             */\n\nimport find from '../../jsutils/find';\n\nimport { Kind } from '../../language/kinds';\nimport { print } from '../../language/printer';\n\nimport { getNamedType, isNonNullType, isLeafType, isObjectType, isListType, isInterfaceType } from '../../type/definition';\n\nimport { typeFromAST } from '../../utilities/typeFromAST';\n\nexport function fieldsConflictMessage(responseName, reason) {\n  return 'Fields \"' + responseName + '\" conflict because ' + reasonMessage(reason) + '. Use different aliases on the fields to fetch both if this was ' + 'intentional.';\n}\n\nfunction reasonMessage(reason) {\n  if (Array.isArray(reason)) {\n    return reason.map(function (_ref) {\n      var responseName = _ref[0],\n          subreason = _ref[1];\n      return 'subfields \"' + responseName + '\" conflict because ' + reasonMessage(subreason);\n    }).join(' and ');\n  }\n  return reason;\n}\n\n/**\n * Overlapping fields can be merged\n *\n * A selection set is only valid if all fields (including spreading any\n * fragments) either correspond to distinct response names or can be merged\n * without ambiguity.\n */\nexport function OverlappingFieldsCanBeMerged(context) {\n  // A memoization for when two fragments are compared \"between\" each other for\n  // conflicts. Two fragments may be compared many times, so memoizing this can\n  // dramatically improve the performance of this validator.\n  var comparedFragmentPairs = new PairSet();\n\n  // A cache for the \"field map\" and list of fragment names found in any given\n  // selection set. Selection sets may be asked for this information multiple\n  // times, so this improves the performance of this validator.\n  var cachedFieldsAndFragmentNames = new Map();\n\n  return {\n    SelectionSet: function SelectionSet(selectionSet) {\n      var conflicts = findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, context.getParentType(), selectionSet);\n      conflicts.forEach(function (_ref2) {\n        var _ref2$ = _ref2[0],\n            responseName = _ref2$[0],\n            reason = _ref2$[1],\n            fields1 = _ref2[1],\n            fields2 = _ref2[2];\n        return context.reportError(new GraphQLError(fieldsConflictMessage(responseName, reason), fields1.concat(fields2)));\n      });\n    }\n  };\n}\n// Field name and reason.\n\n// Reason is a string, or a nested list of conflicts.\n\n// Tuple defining a field node in a context.\n\n// Map of array of those.\n\n\n/**\n * Algorithm:\n *\n * Conflicts occur when two fields exist in a query which will produce the same\n * response name, but represent differing values, thus creating a conflict.\n * The algorithm below finds all conflicts via making a series of comparisons\n * between fields. In order to compare as few fields as possible, this makes\n * a series of comparisons \"within\" sets of fields and \"between\" sets of fields.\n *\n * Given any selection set, a collection produces both a set of fields by\n * also including all inline fragments, as well as a list of fragments\n * referenced by fragment spreads.\n *\n * A) Each selection set represented in the document first compares \"within\" its\n * collected set of fields, finding any conflicts between every pair of\n * overlapping fields.\n * Note: This is the *only time* that a the fields \"within\" a set are compared\n * to each other. After this only fields \"between\" sets are compared.\n *\n * B) Also, if any fragment is referenced in a selection set, then a\n * comparison is made \"between\" the original set of fields and the\n * referenced fragment.\n *\n * C) Also, if multiple fragments are referenced, then comparisons\n * are made \"between\" each referenced fragment.\n *\n * D) When comparing \"between\" a set of fields and a referenced fragment, first\n * a comparison is made between each field in the original set of fields and\n * each field in the the referenced set of fields.\n *\n * E) Also, if any fragment is referenced in the referenced selection set,\n * then a comparison is made \"between\" the original set of fields and the\n * referenced fragment (recursively referring to step D).\n *\n * F) When comparing \"between\" two fragments, first a comparison is made between\n * each field in the first referenced set of fields and each field in the the\n * second referenced set of fields.\n *\n * G) Also, any fragments referenced by the first must be compared to the\n * second, and any fragments referenced by the second must be compared to the\n * first (recursively referring to step F).\n *\n * H) When comparing two fields, if both have selection sets, then a comparison\n * is made \"between\" both selection sets, first comparing the set of fields in\n * the first selection set with the set of fields in the second.\n *\n * I) Also, if any fragment is referenced in either selection set, then a\n * comparison is made \"between\" the other set of fields and the\n * referenced fragment.\n *\n * J) Also, if two fragments are referenced in both selection sets, then a\n * comparison is made \"between\" the two fragments.\n *\n */\n\n// Find all conflicts found \"within\" a selection set, including those found\n// via spreading in fragments. Called when visiting each SelectionSet in the\n// GraphQL Document.\nfunction findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentType, selectionSet) {\n  var conflicts = [];\n\n  var _getFieldsAndFragment = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet),\n      fieldMap = _getFieldsAndFragment[0],\n      fragmentNames = _getFieldsAndFragment[1];\n\n  // (A) Find find all conflicts \"within\" the fields of this selection set.\n  // Note: this is the *only place* `collectConflictsWithin` is called.\n\n\n  collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap);\n\n  if (fragmentNames.length !== 0) {\n    // (B) Then collect conflicts between these fields and those represented by\n    // each spread fragment name found.\n    var comparedFragments = Object.create(null);\n    for (var i = 0; i < fragmentNames.length; i++) {\n      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, comparedFragmentPairs, false, fieldMap, fragmentNames[i]);\n      // (C) Then compare this fragment with all other fragments found in this\n      // selection set to collect conflicts between fragments spread together.\n      // This compares each item in the list of fragment names to every other\n      // item in that same list (except for itself).\n      for (var j = i + 1; j < fragmentNames.length; j++) {\n        collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fragmentNames[i], fragmentNames[j]);\n      }\n    }\n  }\n  return conflicts;\n}\n\n// Collect all conflicts found between a set of fields and a fragment reference\n// including via spreading in any nested fragments.\nfunction collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {\n  // Memoize so a fragment is not compared for conflicts more than once.\n  if (comparedFragments[fragmentName]) {\n    return;\n  }\n  comparedFragments[fragmentName] = true;\n\n  var fragment = context.getFragment(fragmentName);\n  if (!fragment) {\n    return;\n  }\n\n  var _getReferencedFieldsA = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment),\n      fieldMap2 = _getReferencedFieldsA[0],\n      fragmentNames2 = _getReferencedFieldsA[1];\n\n  // Do not compare a fragment's fieldMap to itself.\n\n\n  if (fieldMap === fieldMap2) {\n    return;\n  }\n\n  // (D) First collect any conflicts between the provided collection of fields\n  // and the collection of fields represented by the given fragment.\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fieldMap2);\n\n  // (E) Then collect any conflicts between the provided collection of fields\n  // and any fragment names found in the given fragment.\n  for (var i = 0; i < fragmentNames2.length; i++) {\n    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentNames2[i]);\n  }\n}\n\n// Collect all conflicts found between two fragments, including via spreading in\n// any nested fragments.\nfunction collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {\n  // No need to compare a fragment to itself.\n  if (fragmentName1 === fragmentName2) {\n    return;\n  }\n\n  // Memoize so two fragments are not compared for conflicts more than once.\n  if (comparedFragmentPairs.has(fragmentName1, fragmentName2, areMutuallyExclusive)) {\n    return;\n  }\n  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);\n\n  var fragment1 = context.getFragment(fragmentName1);\n  var fragment2 = context.getFragment(fragmentName2);\n  if (!fragment1 || !fragment2) {\n    return;\n  }\n\n  var _getReferencedFieldsA2 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment1),\n      fieldMap1 = _getReferencedFieldsA2[0],\n      fragmentNames1 = _getReferencedFieldsA2[1];\n\n  var _getReferencedFieldsA3 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment2),\n      fieldMap2 = _getReferencedFieldsA3[0],\n      fragmentNames2 = _getReferencedFieldsA3[1];\n\n  // (F) First, collect all conflicts between these two collections of fields\n  // (not including any nested fragments).\n\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2);\n\n  // (G) Then collect conflicts between the first fragment and any nested\n  // fragments spread in the second fragment.\n  for (var j = 0; j < fragmentNames2.length; j++) {\n    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentNames2[j]);\n  }\n\n  // (G) Then collect conflicts between the second fragment and any nested\n  // fragments spread in the first fragment.\n  for (var i = 0; i < fragmentNames1.length; i++) {\n    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentNames1[i], fragmentName2);\n  }\n}\n\n// Find all conflicts found between two selection sets, including those found\n// via spreading in fragments. Called when determining if conflicts exist\n// between the sub-fields of two overlapping fields.\nfunction findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {\n  var conflicts = [];\n\n  var _getFieldsAndFragment2 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType1, selectionSet1),\n      fieldMap1 = _getFieldsAndFragment2[0],\n      fragmentNames1 = _getFieldsAndFragment2[1];\n\n  var _getFieldsAndFragment3 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType2, selectionSet2),\n      fieldMap2 = _getFieldsAndFragment3[0],\n      fragmentNames2 = _getFieldsAndFragment3[1];\n\n  // (H) First, collect all conflicts between these two collections of field.\n\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2);\n\n  // (I) Then collect conflicts between the first collection of fields and\n  // those referenced by each fragment name associated with the second.\n  if (fragmentNames2.length !== 0) {\n    var comparedFragments = Object.create(null);\n    for (var j = 0; j < fragmentNames2.length; j++) {\n      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fragmentNames2[j]);\n    }\n  }\n\n  // (I) Then collect conflicts between the second collection of fields and\n  // those referenced by each fragment name associated with the first.\n  if (fragmentNames1.length !== 0) {\n    var _comparedFragments = Object.create(null);\n    for (var i = 0; i < fragmentNames1.length; i++) {\n      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, _comparedFragments, comparedFragmentPairs, areMutuallyExclusive, fieldMap2, fragmentNames1[i]);\n    }\n  }\n\n  // (J) Also collect conflicts between any fragment names by the first and\n  // fragment names by the second. This compares each item in the first set of\n  // names to each item in the second set of names.\n  for (var _i = 0; _i < fragmentNames1.length; _i++) {\n    for (var _j = 0; _j < fragmentNames2.length; _j++) {\n      collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentNames1[_i], fragmentNames2[_j]);\n    }\n  }\n  return conflicts;\n}\n\n// Collect all Conflicts \"within\" one collection of fields.\nfunction collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For every response name, if there are multiple fields, they\n  // must be compared to find a potential conflict.\n  Object.keys(fieldMap).forEach(function (responseName) {\n    var fields = fieldMap[responseName];\n    // This compares every field in the list to every other field in this list\n    // (except to itself). If the list only has one item, nothing needs to\n    // be compared.\n    if (fields.length > 1) {\n      for (var i = 0; i < fields.length; i++) {\n        for (var j = i + 1; j < fields.length; j++) {\n          var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, // within one collection is never mutually exclusive\n          responseName, fields[i], fields[j]);\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  });\n}\n\n// Collect all Conflicts between two collections of fields. This is similar to,\n// but different from the `collectConflictsWithin` function above. This check\n// assumes that `collectConflictsWithin` has already been called on each\n// provided collection of fields. This is true because this validator traverses\n// each individual selection set.\nfunction collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For any response name which appears in both provided field\n  // maps, each field from the first field map must be compared to every field\n  // in the second field map to find potential conflicts.\n  Object.keys(fieldMap1).forEach(function (responseName) {\n    var fields2 = fieldMap2[responseName];\n    if (fields2) {\n      var fields1 = fieldMap1[responseName];\n      for (var i = 0; i < fields1.length; i++) {\n        for (var j = 0; j < fields2.length; j++) {\n          var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, fields1[i], fields2[j]);\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  });\n}\n\n// Determines if there is a conflict between two particular fields, including\n// comparing their sub-fields.\nfunction findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {\n  var parentType1 = field1[0],\n      node1 = field1[1],\n      def1 = field1[2];\n  var parentType2 = field2[0],\n      node2 = field2[1],\n      def2 = field2[2];\n\n  // If it is known that two fields could not possibly apply at the same\n  // time, due to the parent types, then it is safe to permit them to diverge\n  // in aliased field or arguments used as they will not present any ambiguity\n  // by differing.\n  // It is known that two parent types could never overlap if they are\n  // different Object types. Interface or Union types might overlap - if not\n  // in the current state of the schema, then perhaps in some future version,\n  // thus may not safely diverge.\n\n  var areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && isObjectType(parentType1) && isObjectType(parentType2);\n\n  // The return type for each field.\n  var type1 = def1 && def1.type;\n  var type2 = def2 && def2.type;\n\n  if (!areMutuallyExclusive) {\n    // Two aliases must refer to the same field.\n    var name1 = node1.name.value;\n    var name2 = node2.name.value;\n    if (name1 !== name2) {\n      return [[responseName, name1 + ' and ' + name2 + ' are different fields'], [node1], [node2]];\n    }\n\n    // Two field calls must have the same arguments.\n    if (!sameArguments(node1.arguments || [], node2.arguments || [])) {\n      return [[responseName, 'they have differing arguments'], [node1], [node2]];\n    }\n  }\n\n  if (type1 && type2 && doTypesConflict(type1, type2)) {\n    return [[responseName, 'they return conflicting types ' + String(type1) + ' and ' + String(type2)], [node1], [node2]];\n  }\n\n  // Collect and compare sub-fields. Use the same \"visited fragment names\" list\n  // for both collections so fields in a fragment reference are never\n  // compared to themselves.\n  var selectionSet1 = node1.selectionSet;\n  var selectionSet2 = node2.selectionSet;\n  if (selectionSet1 && selectionSet2) {\n    var conflicts = findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, getNamedType(type1), selectionSet1, getNamedType(type2), selectionSet2);\n    return subfieldConflicts(conflicts, responseName, node1, node2);\n  }\n}\n\nfunction sameArguments(arguments1, arguments2) {\n  if (arguments1.length !== arguments2.length) {\n    return false;\n  }\n  return arguments1.every(function (argument1) {\n    var argument2 = find(arguments2, function (argument) {\n      return argument.name.value === argument1.name.value;\n    });\n    if (!argument2) {\n      return false;\n    }\n    return sameValue(argument1.value, argument2.value);\n  });\n}\n\nfunction sameValue(value1, value2) {\n  return !value1 && !value2 || print(value1) === print(value2);\n}\n\n// Two types conflict if both types could not apply to a value simultaneously.\n// Composite types are ignored as their individual field types will be compared\n// later recursively. However List and Non-Null types must match.\nfunction doTypesConflict(type1, type2) {\n  if (isListType(type1)) {\n    return isListType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;\n  }\n  if (isListType(type2)) {\n    return true;\n  }\n  if (isNonNullType(type1)) {\n    return isNonNullType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;\n  }\n  if (isNonNullType(type2)) {\n    return true;\n  }\n  if (isLeafType(type1) || isLeafType(type2)) {\n    return type1 !== type2;\n  }\n  return false;\n}\n\n// Given a selection set, return the collection of fields (a mapping of response\n// name to field nodes and definitions) as well as a list of fragment names\n// referenced via fragment spreads.\nfunction getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {\n  var cached = cachedFieldsAndFragmentNames.get(selectionSet);\n  if (!cached) {\n    var nodeAndDefs = Object.create(null);\n    var fragmentNames = Object.create(null);\n    _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames);\n    cached = [nodeAndDefs, Object.keys(fragmentNames)];\n    cachedFieldsAndFragmentNames.set(selectionSet, cached);\n  }\n  return cached;\n}\n\n// Given a reference to a fragment, return the represented collection of fields\n// as well as a list of nested fragment names referenced via fragment spreads.\nfunction getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {\n  // Short-circuit building a type from the node if possible.\n  var cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);\n  if (cached) {\n    return cached;\n  }\n\n  var fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);\n  return getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragmentType, fragment.selectionSet);\n}\n\nfunction _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {\n  for (var i = 0; i < selectionSet.selections.length; i++) {\n    var selection = selectionSet.selections[i];\n    switch (selection.kind) {\n      case Kind.FIELD:\n        var fieldName = selection.name.value;\n        var fieldDef = void 0;\n        if (isObjectType(parentType) || isInterfaceType(parentType)) {\n          fieldDef = parentType.getFields()[fieldName];\n        }\n        var responseName = selection.alias ? selection.alias.value : fieldName;\n        if (!nodeAndDefs[responseName]) {\n          nodeAndDefs[responseName] = [];\n        }\n        nodeAndDefs[responseName].push([parentType, selection, fieldDef]);\n        break;\n      case Kind.FRAGMENT_SPREAD:\n        fragmentNames[selection.name.value] = true;\n        break;\n      case Kind.INLINE_FRAGMENT:\n        var typeCondition = selection.typeCondition;\n        var inlineFragmentType = typeCondition ? typeFromAST(context.getSchema(), typeCondition) : parentType;\n        _collectFieldsAndFragmentNames(context, inlineFragmentType, selection.selectionSet, nodeAndDefs, fragmentNames);\n        break;\n    }\n  }\n}\n\n// Given a series of Conflicts which occurred between two sub-fields, generate\n// a single Conflict.\nfunction subfieldConflicts(conflicts, responseName, node1, node2) {\n  if (conflicts.length > 0) {\n    return [[responseName, conflicts.map(function (_ref3) {\n      var reason = _ref3[0];\n      return reason;\n    })], conflicts.reduce(function (allFields, _ref4) {\n      var fields1 = _ref4[1];\n      return allFields.concat(fields1);\n    }, [node1]), conflicts.reduce(function (allFields, _ref5) {\n      var fields2 = _ref5[2];\n      return allFields.concat(fields2);\n    }, [node2])];\n  }\n}\n\n/**\n * A way to keep track of pairs of things when the ordering of the pair does\n * not matter. We do this by maintaining a sort of double adjacency sets.\n */\n\nvar PairSet = function () {\n  function PairSet() {\n    _classCallCheck(this, PairSet);\n\n    this._data = Object.create(null);\n  }\n\n  PairSet.prototype.has = function has(a, b, areMutuallyExclusive) {\n    var first = this._data[a];\n    var result = first && first[b];\n    if (result === undefined) {\n      return false;\n    }\n    // areMutuallyExclusive being false is a superset of being true,\n    // hence if we want to know if this PairSet \"has\" these two with no\n    // exclusivity, we have to ensure it was added as such.\n    if (areMutuallyExclusive === false) {\n      return result === false;\n    }\n    return true;\n  };\n\n  PairSet.prototype.add = function add(a, b, areMutuallyExclusive) {\n    _pairSetAdd(this._data, a, b, areMutuallyExclusive);\n    _pairSetAdd(this._data, b, a, areMutuallyExclusive);\n  };\n\n  return PairSet;\n}();\n\nfunction _pairSetAdd(data, a, b, areMutuallyExclusive) {\n  var map = data[a];\n  if (!map) {\n    map = Object.create(null);\n    data[a] = map;\n  }\n  map[b] = areMutuallyExclusive;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}