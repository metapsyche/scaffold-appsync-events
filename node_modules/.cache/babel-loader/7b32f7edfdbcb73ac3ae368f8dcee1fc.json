{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.typeIncompatibleSpreadMessage = typeIncompatibleSpreadMessage;\nexports.typeIncompatibleAnonSpreadMessage = typeIncompatibleAnonSpreadMessage;\nexports.PossibleFragmentSpreads = PossibleFragmentSpreads;\n\nvar _error = require('../../error');\n\nvar _typeComparators = require('../../utilities/typeComparators');\n\nvar _typeFromAST = require('../../utilities/typeFromAST');\n\nvar _definition = require('../../type/definition');\n\nfunction typeIncompatibleSpreadMessage(fragName, parentType, fragType) {\n  return 'Fragment \"' + fragName + '\" cannot be spread here as objects of ' + ('type \"' + String(parentType) + '\" can never be of type \"' + String(fragType) + '\".');\n}\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\nfunction typeIncompatibleAnonSpreadMessage(parentType, fragType) {\n  return 'Fragment cannot be spread here as objects of ' + ('type \"' + String(parentType) + '\" can never be of type \"' + String(fragType) + '\".');\n}\n/**\n * Possible fragment spread\n *\n * A fragment spread is only valid if the type condition could ever possibly\n * be true: if there is a non-empty intersection of the possible parent types,\n * and possible types which pass the type condition.\n */\n\n\nfunction PossibleFragmentSpreads(context) {\n  return {\n    InlineFragment: function InlineFragment(node) {\n      var fragType = context.getType();\n      var parentType = context.getParentType();\n\n      if ((0, _definition.isCompositeType)(fragType) && (0, _definition.isCompositeType)(parentType) && !(0, _typeComparators.doTypesOverlap)(context.getSchema(), fragType, parentType)) {\n        context.reportError(new _error.GraphQLError(typeIncompatibleAnonSpreadMessage(parentType, fragType), [node]));\n      }\n    },\n    FragmentSpread: function FragmentSpread(node) {\n      var fragName = node.name.value;\n      var fragType = getFragmentType(context, fragName);\n      var parentType = context.getParentType();\n\n      if (fragType && parentType && !(0, _typeComparators.doTypesOverlap)(context.getSchema(), fragType, parentType)) {\n        context.reportError(new _error.GraphQLError(typeIncompatibleSpreadMessage(fragName, parentType, fragType), [node]));\n      }\n    }\n  };\n}\n\nfunction getFragmentType(context, name) {\n  var frag = context.getFragment(name);\n  return frag && (0, _typeFromAST.typeFromAST)(context.getSchema(), frag.typeCondition);\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","typeIncompatibleSpreadMessage","typeIncompatibleAnonSpreadMessage","PossibleFragmentSpreads","_error","require","_typeComparators","_typeFromAST","_definition","fragName","parentType","fragType","String","context","InlineFragment","node","getType","getParentType","isCompositeType","doTypesOverlap","getSchema","reportError","GraphQLError","FragmentSpread","name","getFragmentType","frag","getFragment","typeFromAST","typeCondition"],"sources":["/Users/roaldmaravillas/ro/sandbox/aws-mobile-appsync-events-starter-react/node_modules/graphql/validation/rules/PossibleFragmentSpreads.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.typeIncompatibleSpreadMessage = typeIncompatibleSpreadMessage;\nexports.typeIncompatibleAnonSpreadMessage = typeIncompatibleAnonSpreadMessage;\nexports.PossibleFragmentSpreads = PossibleFragmentSpreads;\n\nvar _error = require('../../error');\n\nvar _typeComparators = require('../../utilities/typeComparators');\n\nvar _typeFromAST = require('../../utilities/typeFromAST');\n\nvar _definition = require('../../type/definition');\n\nfunction typeIncompatibleSpreadMessage(fragName, parentType, fragType) {\n  return 'Fragment \"' + fragName + '\" cannot be spread here as objects of ' + ('type \"' + String(parentType) + '\" can never be of type \"' + String(fragType) + '\".');\n} /**\n   * Copyright (c) 2015-present, Facebook, Inc.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   *\n   * \n   */\n\nfunction typeIncompatibleAnonSpreadMessage(parentType, fragType) {\n  return 'Fragment cannot be spread here as objects of ' + ('type \"' + String(parentType) + '\" can never be of type \"' + String(fragType) + '\".');\n}\n\n/**\n * Possible fragment spread\n *\n * A fragment spread is only valid if the type condition could ever possibly\n * be true: if there is a non-empty intersection of the possible parent types,\n * and possible types which pass the type condition.\n */\nfunction PossibleFragmentSpreads(context) {\n  return {\n    InlineFragment: function InlineFragment(node) {\n      var fragType = context.getType();\n      var parentType = context.getParentType();\n      if ((0, _definition.isCompositeType)(fragType) && (0, _definition.isCompositeType)(parentType) && !(0, _typeComparators.doTypesOverlap)(context.getSchema(), fragType, parentType)) {\n        context.reportError(new _error.GraphQLError(typeIncompatibleAnonSpreadMessage(parentType, fragType), [node]));\n      }\n    },\n    FragmentSpread: function FragmentSpread(node) {\n      var fragName = node.name.value;\n      var fragType = getFragmentType(context, fragName);\n      var parentType = context.getParentType();\n      if (fragType && parentType && !(0, _typeComparators.doTypesOverlap)(context.getSchema(), fragType, parentType)) {\n        context.reportError(new _error.GraphQLError(typeIncompatibleSpreadMessage(fragName, parentType, fragType), [node]));\n      }\n    }\n  };\n}\n\nfunction getFragmentType(context, name) {\n  var frag = context.getFragment(name);\n  return frag && (0, _typeFromAST.typeFromAST)(context.getSchema(), frag.typeCondition);\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}